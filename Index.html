<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>RadlMap Navigation 🚲</title>

  <!-- Meta Tags für Social Media Vorschau -->
  <meta property="og:title" content="🏠🚲 RadlMap Tourplaner" />
  <meta property="og:description" content="Plane deine nächste Radtour mit Hütten! Mit Live-GPS, Tourenspeicher, Gruppenfunktion & mehr." />
  <meta property="og:image" content="https://radlmap.net/img/preview.png" />
  <meta property="og:url" content="https://radlmap.net" />
  <meta name="twitter:card" content="summary_large_image" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🚲</text></svg>">

  <!-- Externe Bibliotheken -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>
  <script src="https://unpkg.com/@mapbox/polyline"></script>
  <link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"/>
  <script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script>
  <script src="https://unpkg.com/leaflet-geometryutil"></script>


  <style>
    /* Inter Schriftart für ein modernes UI */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      -webkit-tap-highlight-color: transparent;
    }

    #map {
      height: 100%;
      width: 100%;
      background: #f0f0f0;
      z-index: 1;
    }

    /* Lade-Overlay */
    #loader {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(8px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease;
    }
    .loader-spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-left-color: #2563eb;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Dark Mode Variablen & Übergänge */
    :root {
      --bg-color: #ffffff;
      --text-color: #1f2937;
      --ui-bg: rgba(255, 255, 255, 0.85);
      --border-color: #e5e7eb;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .dark {
      --bg-color: #111827;
      --text-color: #f9fafb;
      --ui-bg: rgba(31, 41, 55, 0.85);
      --border-color: #374151;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    body, .ui-element {
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .leaflet-popup-content-wrapper, .leaflet-popup-tip {
      background: var(--ui-bg) !important;
      color: var(--text-color) !important;
      backdrop-filter: blur(10px);
      border-radius: 12px; /* Rounded popups */
    }
     .leaflet-popup-content {
        margin: 14px 20px; /* More padding inside popup */
        line-height: 1.5;
    }


    /* Toast-Nachrichten */
    #toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #1f2937;
      color: white;
      padding: 10px 20px;
      border-radius: 9999px;
      font-size: 14px;
      z-index: 9000;
      box-shadow: var(--shadow);
      opacity: 0;
      transition: transform 0.4s ease, opacity 0.4s ease;
      pointer-events: none;
    }
    #toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* Haupt-Toolbar */
    #toolbar {
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      background: var(--ui-bg);
      border: 1px solid var(--border-color);
    }
    #toolbar button {
      transition: background-color 0.2s, transform 0.1s;
    }
    #toolbar button:active {
      transform: scale(0.95);
    }

    /* Seitenleisten-Panel (Dashboard) */
    #sidebar-panel {
        position: fixed;
        top: 0;
        right: 0;
        height: 100%;
        width: 320px;
        max-width: 90vw;
        background: var(--bg-color);
        z-index: 5000;
        transform: translateX(100%);
        transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        box-shadow: -10px 0 25px rgba(0,0,0,0.1);
        border-left: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
    }
    #sidebar-panel.open {
        transform: translateX(0);
    }
    #sidebar-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.4);
        z-index: 4999;
        opacity: 0;
        transition: opacity 0.4s ease;
        pointer-events: none;
    }
    #sidebar-panel.open + #sidebar-overlay {
        opacity: 1;
        pointer-events: auto;
    }

    /* Verbesserte Scrollbars */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
    .dark ::-webkit-scrollbar-thumb { background: #555; }

    /* Navigations-Hinweise */
    #navHint {
        position: absolute;
        top: 80px; /* Angepasste Position */
        left: 50%;
        backdrop-filter: blur(10px);
        box-shadow: var(--shadow);
        border: 1px solid var(--border-color);
        transition: transform 0.4s ease, opacity 0.4s ease;
        transform: translate(-50%, 50px);
        opacity: 0;
        font-size: 1.2rem;
        font-weight: 600;
        pointer-events: auto;
    }
     #navHint.visible {
        transform: translate(-50%, 0);
        opacity: 1;
    }

    /* User Marker SVG mit Animation */
    @keyframes pulse {
      0% { r: 0; opacity: 0.6; }
      100% { r: 40; opacity: 0; }
    }
    .pulse-circle {
      animation: pulse 2s infinite ease-out;
    }

    /* Popup Styling */
    .popup-card {
        max-height: 520px;
        overflow-y: auto;
        font-size: 0.9rem; /* Slightly smaller text */
        padding: 0 !important; /* Remove default padding for card design */
    }
    .leaflet-popup-content-wrapper { padding: 0 !important; overflow: hidden; } /* Ensure card design takes full space */

    .popup-swiper img {
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
        width: 100%;
        height: 150px;
        object-fit: cover;
    }
    .group-marker {
        text-align: center;
        font-weight: bold;
        color: #fff;
    }

    .hutten-bubble {
        background: rgba(255, 255, 255, 0.8);
        border: none;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 10px;
        font-weight: 600;
        color: #333;
    }
    .dark .hutten-bubble {
        background: rgba(31, 41, 55, 0.8);
        color: #f9fafb;
    }
    .warning-icon {
        background: none;
        border: none;
        font-size: 20px; /* Make warning icon slightly larger */
    }
     .leaflet-div-icon {
        background: none;
        border: none;
    }

  </style>
</head>
<body class="antialiased">

  <!-- Ladebildschirm -->
  <div id="loader">
    <div class="loader-spinner"></div>
    <p class="mt-4 text-gray-600">Karte wird geladen...</p>
  </div>

  <!-- Karten-Container -->
  <div id="map"></div>

  <!-- Toast Element -->
  <div id="toast"></div>
  
  <!-- UI Elemente über der Karte -->
  <div class="absolute top-4 right-4 z-10 space-y-3">
    <button onclick="uiManager.toggleSidebar()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
    </button>
     <button id="theme-toggle-btn" onclick="uiManager.toggleTheme()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
        <!-- Icon wird per JS gesetzt -->
    </button>
  </div>
  
  <!-- Wetter Widget -->
  <div id="weather-widget" class="absolute top-4 left-4 z-10 bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)] flex items-center gap-2 text-lg font-semibold">
      <span>-</span><span>-°C</span>
  </div>
  
  <!-- Schnellnavigation -->
  <div class="absolute left-4 top-1/2 -translate-y-1/2 z-10 flex flex-col gap-3">
       <a href="index.html" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon></svg>
      </a>
      <button onclick="uiManager.toggleSidebar()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>
      </button>
  </div>

  <div class="absolute top-0 left-0 right-0 p-4 z-10 pointer-events-none">
     <!-- Navigationshinweise oben -->
    <div id="navHint" class="hidden items-center gap-3 bg-[var(--ui-bg)] text-[var(--text-color)] rounded-full px-4 py-2 max-w-sm mx-auto">
        <!-- Inhalt wird per JS gefüllt -->
    </div>
  </div>

  <!-- Dashboard/Seitenleiste -->
  <aside id="sidebar-panel">
    <div class="flex items-center justify-between p-4 border-b border-[var(--border-color)]">
        <h2 class="text-xl font-bold">Dashboard</h2>
        <button onclick="uiManager.toggleSidebar()" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
    </div>
    
    <!-- Tab Navigation -->
    <nav class="flex border-b border-[var(--border-color)] p-2">
      <button data-tab="tab-tour" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center">Tour</button>
      <button data-tab="tab-raum" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center">Raum</button>
      <button data-tab="tab-nutzer" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center">Profil</button>
      <button data-tab="tab-einstellungen" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center">Setup</button>
    </nav>
    
    <div class="flex-1 overflow-y-auto p-4 space-y-6">
      <!-- Tour Tab -->
      <section id="tab-tour" class="tab-panel space-y-4">
        <!-- Gemini Tour Suggestion -->
        <div class="p-3 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-800 rounded-lg">
            <h3 class="font-bold text-blue-800 dark:text-blue-300">✨ KI Tour-Planer</h3>
            <p class="text-xs text-blue-600 dark:text-blue-400 mt-1 mb-3">Keine Idee? Lass dir eine Tour vorschlagen!</p>
            <div class="flex gap-2">
                <select id="tour-difficulty" class="flex-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent text-sm">
                    <option value="einfache">Leicht</option>
                    <option value="mittelschwere">Mittel</option>
                    <option value="anspruchsvolle">Anspruchsvoll</option>
                </select>
                <button id="suggest-tour-btn" onclick="geminiManager.suggestTour()" class="bg-blue-500 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-blue-600 transition">Vorschlagen</button>
            </div>
        </div>
        
        <h3 class="font-bold">📋 Ausgewählte Stopps</h3>
        <p class="text-xs text-gray-500 -mt-3">Reihenfolge per Drag & Drop ändern.</p>
        <ul id="selectedList" class="space-y-2" ondragover="event.preventDefault()"></ul>
        <div id="tour-actions" class="hidden space-y-2">
            <p id="challenge-status" class="text-sm font-semibold text-center text-green-600"></p>
            <p id="tour-stats" class="text-sm text-gray-500 my-2 text-center"></p>
            <button onclick="routeManager.recalculatePreviewRoute()" class="w-full bg-gray-500 text-white p-2 rounded-lg text-sm font-medium hover:bg-gray-600 transition">
                🔄 Vorschau aktualisieren
            </button>
            <button id="summarize-tour-btn" onclick="geminiManager.summarizeTour()" class="w-full bg-purple-500 text-white p-2 rounded-lg text-sm font-medium hover:bg-purple-600 transition">
                ✨ Tour-Zusammenfassung
            </button>
        </div>
      </section>
      
      <!-- Raum Tab -->
      <section id="tab-raum" class="tab-panel hidden space-y-4">
        <h3 class="font-bold">👥 Raum-Verwaltung</h3>
        <div id="room-active-view" class="hidden space-y-2">
            <p class="text-sm">Du bist im Raum: <strong id="current-room-id" class="font-mono bg-gray-100 dark:bg-gray-700 px-1 rounded"></strong></p>
            <p id="guide-info" class="text-sm"></p>
            <button id="guide-btn" onclick="firebaseManager.setGuide()" class="w-full bg-blue-500 text-white p-2 rounded-lg text-sm font-medium">Guide werden</button>
            <div id="guided-tour-info" class="hidden text-sm p-2 bg-yellow-100 dark:bg-yellow-900 rounded-lg text-center">Eine geführte Tour ist aktiv.</div>

            <button onclick="firebaseManager.leaveRoom()" class="w-full bg-red-500 text-white p-2 rounded-lg text-sm font-medium">Raum verlassen</button>
            <div class="mt-4">
                <h4 class="font-semibold text-sm mb-2">Aktive Nutzer im Raum:</h4>
                <ul id="room-user-list" class="space-y-1 text-sm text-gray-600 dark:text-gray-300"></ul>
            </div>
        </div>
        <div id="room-join-view" class="space-y-2">
            <input id="roomIdInput" type="text" placeholder="Raum-ID (leer für neu)" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
            <button onclick="firebaseManager.joinRoom()" class="w-full bg-green-500 text-white p-2 rounded-lg text-sm font-medium">Beitreten / Erstellen</button>
        </div>
      </section>

      <!-- Nutzer Tab -->
      <section id="tab-nutzer" class="tab-panel hidden space-y-4">
          <h3 class="font-bold">👤 Mein Profil</h3>
          <div>
              <label class="text-sm font-medium">Dein Name</label>
              <div class="flex gap-2 mt-1">
                  <input id="usernameInput" type="text" class="flex-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent" placeholder="Dein Anzeigename">
                  <button onclick="userManager.saveUsername()" class="bg-blue-500 text-white px-4 py-2 rounded-lg text-sm font-medium">Speichern</button>
              </div>
          </div>
           <button onclick="userManager.sendSOS()" class="w-full flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 text-white px-4 py-3 rounded-lg font-bold shadow-lg transition">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>
            SOS Notruf
          </button>
      </section>

      <!-- Einstellungen Tab -->
      <section id="tab-einstellungen" class="tab-panel hidden space-y-4">
        <h3 class="font-bold">⚙️ Einstellungen</h3>
        <div>
          <label for="voiceLang" class="block text-sm font-medium mb-1">🗣️ Sprachausgabe</label>
          <select id="voiceLang" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent"></select>
        </div>
        <div>
            <a href="#" onclick="uiManager.openPopup('Datenschutz', 'Hier stehen die Datenschutzbestimmungen...')" class="text-blue-500 hover:underline text-sm">Datenschutz & Impressum</a>
        </div>
      </section>
    </div>
  </aside>
  <div id="sidebar-overlay" onclick="uiManager.toggleSidebar()"></div>
  

  <!-- Haupt-Toolbar unten -->
  <div id="toolbar" class="absolute bottom-5 left-1/2 -translate-x-1/2 z-10 flex items-center gap-2 p-2 rounded-full">
    <button id="startBtn" onclick="routeManager.startNavigation()" class="bg-green-500 text-white rounded-full px-6 py-3 font-bold text-lg">Start</button>
    <button id="stopBtn" onclick="routeManager.stopNavigation()" class="bg-red-500 text-white rounded-full px-6 py-3 font-bold text-lg hidden">Stop</button>
    <button id="resetBtn" onclick="routeManager.resetRoute()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
    </button>
    <button id="voice-toggle" onclick="appState.toggleVoice()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3">
        <!-- Icon wird per JS gesetzt -->
    </button>
    <button id="follow-toggle" onclick="appState.toggleFollow()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3 hidden">
        <!-- Icon wird per JS gesetzt -->
    </button>
  </div>

  <!-- Popup für Datenschutz, KI-Ergebnisse etc. -->
  <div id="popupOverlay" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9990] flex items-center justify-center p-4" onclick="uiManager.closePopup()">
    <div id="popupContent" class="bg-[var(--bg-color)] rounded-2xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto p-6 relative" onclick="event.stopPropagation()">
        <!-- Inhalt wird dynamisch geladen -->
    </div>
  </div>

  <!-- Modal zum Melden einer Gefahr -->
    <div id="add-warning-modal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9990] flex items-center justify-center p-4">
        <div class="bg-[var(--bg-color)] rounded-2xl shadow-xl max-w-sm w-full p-6 space-y-4">
            <h3 class="font-bold text-lg">Gefahr an dieser Stelle melden</h3>
            <div>
                <label for="warning-type" class="text-sm font-medium">Art der Gefahr</label>
                <select id="warning-type" class="w-full mt-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
                    <option>Schlagloch</option>
                    <option>Hindernis</option>
                    <option>Gefährliche Kreuzung</option>
                    <option>Sonstiges</option>
                </select>
            </div>
            <div>
                <label for="warning-description" class="text-sm font-medium">Kurze Beschreibung (optional)</label>
                <input id="warning-description" type="text" class="w-full mt-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent" placeholder="z.B. Tiefe Spurrille">
            </div>
            <div class="flex gap-2 justify-end">
                <button onclick="uiManager.hideAddWarningModal()" class="px-4 py-2 rounded-lg">Abbrechen</button>
                <button onclick="firebaseManager.addWarning()" class="px-4 py-2 bg-blue-500 text-white rounded-lg">Melden</button>
            </div>
        </div>
    </div>


  <!-- Scripte: Firebase & Logik -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  
  <script>
    // ==========================================================
    //  🚲 RADLMAP - V5.3 - FINAL
    // ==========================================================

    // ----------------------------------------------------------
    //  1. KONFIGURATION & ZUSTAND
    // ----------------------------------------------------------

    const config = {
      firebase: { 
        apiKey: "5b3ce3597851110001cf624866907189b4974b88e5541b15dfed2e1603067f5b85cd6da44c68ee87",
        authDomain: "eierhuettentour.firebaseapp.com",
        projectId: "eierhuettentour"
      },
      map: {
        defaultCenter: [47.3, 11.4],
        defaultZoom: 13,
        navigationZoom: 18,
      },
      routing: {
        profile: 'cycling-regular',
        deviationThresholdMeters: 10,
        recalcDebounceMs: 8000,
      },
      noImagePlaceholders: [
        "https://radlmap.net/img/noimg/1.jpg",
        "https://radlmap.net/img/noimg/2.jpg",
        "https://radlmap.net/img/noimg/3.jpg",
      ]
    };
    
    const appState = {
      isFollowing: true,
      isVoiceOn: true,
      isDarkTheme: false,
      isNavigating: false,
      isSidebarOpen: false,
      selectedHuts: [],
      allHuts: [],
      allWarnings: [],
      warnedAbout: new Set(),
      currentRoom: { id: null, guideId: null },
      roomUnsubscribe: null,
      userPositionsUnsubscribe: null,
      visitedStops: new Set(),
      
      toggleFollow() {
        this.isFollowing = !this.isFollowing;
        uiManager.updateFollowButton();
        uiManager.showToast(`Follow-Modus ${this.isFollowing ? 'aktiviert' : 'pausiert'}`);
        if(this.isFollowing && mapManager.userMarker) {
            mapManager.map.setView(mapManager.userMarker.getLatLng(), config.map.navigationZoom);
        }
      },
      toggleVoice() {
        this.isVoiceOn = !this.isVoiceOn;
        uiManager.updateVoiceButton();
        uiManager.showToast(`Sprachansagen ${this.isVoiceOn ? 'aktiviert' : 'deaktiviert'}`);
      },
    };

    // ----------------------------------------------------------
    //  2. UI MANAGER - Alles was die Oberfläche betrifft
    // ----------------------------------------------------------
    const uiManager = {
        init() {
            this.initTheme();
            this.initTabs();
            this.updateVoiceButton();
            this.updateFollowButton();
            ttsManager.init();
        },

        toggleSidebar() {
            appState.isSidebarOpen = !appState.isSidebarOpen;
            document.getElementById('sidebar-panel').classList.toggle('open', appState.isSidebarOpen);
            if(mapManager.map) {
                setTimeout(() => mapManager.map.invalidateSize(), 400);
            }
        },

        initTheme() {
            const savedTheme = localStorage.getItem('theme');
            appState.isDarkTheme = savedTheme === 'dark';
            document.body.classList.toggle('dark', appState.isDarkTheme);
            this.updateThemeButton();
        },

        toggleTheme() {
            appState.isDarkTheme = !appState.isDarkTheme;
            localStorage.setItem('theme', appState.isDarkTheme ? 'dark' : 'light');
            document.body.classList.toggle('dark', appState.isDarkTheme);
            this.updateThemeButton();
            if(mapManager.tileLayer) {
                mapManager.map.removeLayer(mapManager.tileLayer);
                mapManager.addTileLayer();
            }
        },
        
        updateThemeButton() {
            const icon = appState.isDarkTheme ? '☀️' : '🌙';
            document.getElementById('theme-toggle-btn').textContent = icon;
        },

        updateVoiceButton() {
            const icon = appState.isVoiceOn 
                ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`
                : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v-2a7 7 0 0 0-11.21-.83"></path></svg>`;
            document.getElementById('voice-toggle').innerHTML = icon;
        },

        updateFollowButton() {
            const icon = appState.isFollowing 
                ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Z M12 2.25a.75.75 0 0 1 .75.75v.31A9.743 9.743 0 0 1 21.435 12a.75.75 0 0 1-1.493.102 8.243 8.243 0 0 0-7.942-7.942A.75.75 0 0 1 12 2.25Z"/></svg>` 
                : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>`;
            document.getElementById('follow-toggle').innerHTML = icon;
        },
        
        setLoading(isLoading, text = 'Lade...') {
            const loader = document.getElementById('loader');
            if (isLoading) {
                loader.querySelector('p').textContent = text;
                loader.style.display = 'flex';
                loader.style.opacity = '1';
            } else {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }
        },

        showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        },

        updateSelectedList() {
            const listEl = document.getElementById('selectedList');
            if (appState.selectedHuts.length === 0) {
                listEl.innerHTML = `<li class="text-sm text-gray-500">Noch keine Stopps ausgewählt. Klicke auf der Karte auf eine Hütte oder lass dir eine Tour vorschlagen.</li>`;
                document.getElementById('tour-actions').classList.add('hidden');
                return;
            }

            listEl.innerHTML = appState.selectedHuts.map((hut, index) => `
                <li draggable="true" ondragstart="dragAndDrop.start(event, ${index})" ondrop="dragAndDrop.drop(event, ${index})" class="flex items-center justify-between p-2 rounded-lg bg-gray-100 dark:bg-gray-700 cursor-grab" data-index="${index}">
                    <span class="font-medium text-sm">#${index + 1}: ${hut.name}</span>
                    <button onclick="routeManager.removeSelected(${index})" class="p-1 text-red-500 hover:text-red-700">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </li>
            `).join('');
            
            this.updateChallengeStatus();
            document.getElementById('tour-actions').classList.toggle('hidden', appState.selectedHuts.length < 1);
        },

        updateChallengeStatus() {
            const statusEl = document.getElementById('challenge-status');
            if (appState.selectedHuts.length > 0) {
                statusEl.textContent = `🏆 Stopps besucht: ${appState.visitedStops.size} / ${appState.selectedHuts.length}`;
            } else {
                statusEl.textContent = '';
            }
        },

        setNavigationState(isNavigating) {
            const isGuide = appState.currentRoom.guideId === userManager.userId;
            const guidedTourActive = !!appState.currentRoom.guideId && !isGuide;

            appState.isNavigating = isNavigating;
            document.getElementById('startBtn').classList.toggle('hidden', isNavigating || guidedTourActive);
            document.getElementById('stopBtn').classList.toggle('hidden', !isNavigating || guidedTourActive);
            document.getElementById('resetBtn').disabled = guidedTourActive;
            document.getElementById('follow-toggle').classList.toggle('hidden', !isNavigating);
            if(!isNavigating) document.getElementById('navHint').classList.add('hidden');
        },
        
        initTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabPanels = document.querySelectorAll('.tab-panel');
            
            tabButtons[0].classList.add('bg-gray-200', 'dark:bg-gray-700');
            tabPanels[0].classList.remove('hidden');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('bg-gray-200', 'dark:bg-gray-700'));
                    button.classList.add('bg-gray-200', 'dark:bg-gray-700');
                    tabPanels.forEach(panel => panel.classList.add('hidden'));
                    document.getElementById(button.dataset.tab).classList.remove('hidden');
                });
            });
        },

        showNavHint(icon, text) {
            const hintEl = document.getElementById('navHint');
            hintEl.innerHTML = `${icon} <span class="text-sm font-semibold">${text}</span>`;
            hintEl.classList.remove('hidden');
            hintEl.classList.add('visible');

            if (this.navHintTimer) clearTimeout(this.navHintTimer);
            this.navHintTimer = setTimeout(() => {
                hintEl.classList.remove('visible');
            }, 8000);
        },
        
       getTurnIcon(type) { // Angepasst für OSRM instruction types
            if (type.includes('left')) {
                if (type.includes('sharp')) return '↙️';
                if (type.includes('slight')) return '↖️';
                return '⬅️';
            }
            if (type.includes('right')) {
                 if (type.includes('sharp')) return '↘️';
                 if (type.includes('slight')) return '↗️';
                return '➡️';
            }
            if (type.includes('roundabout')) return '🔄';
            if (type.includes('arrive')) return '🏁';
            if (type.includes('depart')) return '🏁'; // Start considered finish of prev leg
            return '⬆️'; // continue, new name, etc.
        },

        updateRoomUI(roomData, users = []) {
            const inRoom = !!roomData.id;
            document.getElementById('room-active-view').classList.toggle('hidden', !inRoom);
            document.getElementById('room-join-view').classList.toggle('hidden', inRoom);

            if(inRoom) {
                document.getElementById('current-room-id').textContent = roomData.id;
                
                const guideInfo = document.getElementById('guide-info');
                const guideBtn = document.getElementById('guide-btn');
                const isSelfGuide = roomData.guideId === userManager.userId;

                if (roomData.guideId) {
                    guideInfo.textContent = isSelfGuide ? "Du bist der Guide." : `Guide: ${roomData.guideName || 'Unbekannt'}`;
                    guideBtn.textContent = isSelfGuide ? "Guide-Rolle abgeben" : "Guide werden";
                    guideBtn.disabled = !isSelfGuide && !!roomData.guideId;
                } else {
                    guideInfo.textContent = "Niemand führt die Tour.";
                    guideBtn.textContent = "Guide werden";
                    guideBtn.disabled = false;
                }
                
                const guidedTourInfo = document.getElementById('guided-tour-info');
                guidedTourInfo.classList.toggle('hidden', !roomData.isNavigating || isSelfGuide);


                const userListEl = document.getElementById('room-user-list');
                if(users.length > 0) {
                    userListEl.innerHTML = users.map(user => `<li>- ${user.name || 'Anonym'}</li>`).join('');
                } else {
                    userListEl.innerHTML = `<li>Keine anderen Nutzer aktiv.</li>`;
                }
            }
        },
        
        openPopup(title, htmlContent) {
            const overlay = document.getElementById("popupOverlay");
            const content = document.getElementById("popupContent");
            overlay.classList.remove("hidden");
            content.innerHTML = `
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">${title}</h2>
                    <button onclick="uiManager.closePopup()" class="p-2 -mr-2 text-2xl">&times;</button>
                </div>
                <div>${htmlContent}</div>`;
        },

        closePopup() {
            document.getElementById("popupOverlay").classList.add("hidden");
        },

        showAddWarningModal(latlng) {
            this.tempWarningLatLng = latlng;
            document.getElementById('add-warning-modal').classList.remove('hidden');
        },
        hideAddWarningModal() {
            document.getElementById('add-warning-modal').classList.add('hidden');
            document.getElementById('warning-description').value = ''; // Clear description
        },
    };

    // ----------------------------------------------------------
    //  3. KARTEN MANAGER - Alles rund um Leaflet
    // ----------------------------------------------------------
    const mapManager = {
        map: null,
        userMarker: null,
        tileLayer: null,
        clusterGroup: null,
        routeLine: null,
        previewLine: null,
        pastRouteLine: null,
        groupMarkers: {},
        warningMarkers: {},

        init(center, zoom) {
            this.map = L.map('map', { center, zoom, zoomControl: false });
            L.control.zoom({ position: 'bottomright' }).addTo(this.map);
            this.addTileLayer();

            this.clusterGroup = L.markerClusterGroup();
            this.map.addLayer(this.clusterGroup);

            this.map.on('dragstart', () => { if(appState.isFollowing) appState.toggleFollow() });
            this.map.on('contextmenu', (e) => uiManager.showAddWarningModal(e.latlng)); // Right-click or long-press
            
            this.map.on('popupopen', (e) => {
              const swiperEl = e.popup.getElement().querySelector('.popup-swiper');
              if (swiperEl && !swiperEl.swiper) {
                new Swiper(swiperEl, {
                  loop: true,
                  pagination: { el: '.swiper-pagination', clickable: true },
                  navigation: {
                    nextEl: '.swiper-button-next',
                    prevEl: '.swiper-button-prev',
                  },
                });
              }
            });
        },

        addTileLayer() {
            const url = appState.isDarkTheme
                ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
                : 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
            const attr = '&copy; OpenStreetMap &copy; CARTO';
            
            this.tileLayer = L.tileLayer(url, { attribution: attr, maxZoom: 19 });
            this.tileLayer.addTo(this.map);
        },
        
        updateUserMarker(latlng, accuracy, bearing) {
            const iconHtml = `
                <svg width="48" height="48" viewBox="0 0 48 48" style="transform: rotate(${bearing}deg); transition: transform 0.2s linear;">
                    <circle cx="24" cy="24" r="20" fill="#4285F4" fill-opacity="0.2" class="pulse-circle"/>
                    <path d="M24 4 L34 28 H14 Z" fill="#4285F4" stroke="white" stroke-width="2" style="filter: drop-shadow(0px 2px 4px rgba(0,0,0,0.4));"/>
                </svg>
            `;
            const userIcon = L.divIcon({
                html: iconHtml,
                className: '',
                iconSize: [48, 48],
                iconAnchor: [24, 24]
            });

            if (!this.userMarker) {
                this.userMarker = L.marker(latlng, { icon: userIcon }).addTo(this.map);
            } else {
                this.userMarker.setLatLng(latlng).setIcon(userIcon);
            }
        },
        
        updateGroupMarker(user) {
            const icon = L.divIcon({
                className: 'group-marker',
                html: `<div style="background-color: ${user.color};" class="p-1 rounded-full shadow-lg">🚴</div><div class="text-xs -mt-1" style="color: ${user.color};">${user.name.substring(0,5)}</div>`
            });

            if (this.groupMarkers[user.id]) {
                this.groupMarkers[user.id].setLatLng([user.lat, user.lng]);
            } else {
                this.groupMarkers[user.id] = L.marker([user.lat, user.lng], { icon }).addTo(this.map);
            }
        },
        
        addWarningMarker(warning) {
            const icon = L.divIcon({
                className: 'warning-icon',
                html: '⚠️',
                iconSize: [24, 24]
            });
            const marker = L.marker([warning.lat, warning.lng], { icon: icon })
                .bindPopup(`<b>${warning.type}</b><br>${warning.description || ''}`)
                .addTo(this.map);
            this.warningMarkers[warning.id] = marker;
        },

        removeWarningMarker(warningId) {
             if (this.warningMarkers[warningId]) {
                this.map.removeLayer(this.warningMarkers[warningId]);
                delete this.warningMarkers[warningId];
            }
        },

        removeGroupMarker(userId) {
            if (this.groupMarkers[userId]) {
                this.map.removeLayer(this.groupMarkers[userId]);
                delete this.groupMarkers[userId];
            }
        },

        drawRoute(coordinates, isPreview = false) {
            const options = isPreview
                ? { color: "#9ca3af", weight: 5, dashArray: "10, 10" }
                : { color: "#3b82f6", weight: 6, opacity: 0.8 };

            if(isPreview) {
                if(this.previewLine) this.map.removeLayer(this.previewLine);
                this.previewLine = L.polyline(coordinates, options).addTo(this.map);
            } else {
                if(this.routeLine) this.map.removeLayer(this.routeLine);
                this.routeLine = L.polyline(coordinates, options).addTo(this.map);
                if(this.pastRouteLine) this.map.removeLayer(this.pastRouteLine);
                this.pastRouteLine = L.polyline([], { color: 'gray', weight: 4 }).addTo(this.map);
            }
        },

        clearRoute() {
            if(this.routeLine) this.map.removeLayer(this.routeLine);
            if(this.previewLine) this.map.removeLayer(this.previewLine);
            if(this.pastRouteLine) this.map.removeLayer(this.pastRouteLine);
            this.routeLine = null;
            this.previewLine = null;
            this.pastRouteLine = null;
        }
    };
    
    // ----------------------------------------------------------
    //  4. WEITERE MANAGER (Routing, Gemini, Firebase, Nutzer, TTS, DragDrop)
    // ----------------------------------------------------------

    const ttsManager = {
        init() {
            const select = document.getElementById("voiceLang");
            if (!select || !window.speechSynthesis) return;

            const populateVoices = () => {
                const voices = speechSynthesis.getVoices();
                select.innerHTML = '';
                voices.forEach(voice => {
                    if (voice.lang.startsWith('de')) {
                        const option = document.createElement('option');
                        option.textContent = `${voice.name} (${voice.lang})`;
                        option.value = voice.lang;
                        select.appendChild(option);
                    }
                });
                select.value = localStorage.getItem('voiceLang') || 'de-DE';
            };
            
            populateVoices();
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = populateVoices;
            }
            select.onchange = () => localStorage.setItem('voiceLang', select.value);
        },
        speak(text) {
            if (!appState.isVoiceOn || !text) return;
            speechSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = document.getElementById("voiceLang").value || 'de-DE';
            speechSynthesis.speak(utterance);
        }
    };

    const routeManager = {
        routeData: null,
        recalcTimer: null,
        announcedSteps: {},
        lastRecalcTime: 0,

        async fetchRoute(startCoords, waypoints) {
            const coordinatesString = [
                `${startCoords.lng},${startCoords.lat}`,
                ...waypoints.map(h => `${h.lng},${h.lat}`)
            ].join(';');
            
            const url = `https://router.project-osrm.org/route/v1/bicycle/${coordinatesString}?overview=full&geometries=geojson&steps=true`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`OSRM API Fehler: ${response.statusText}`);
                const data = await response.json();
                if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) throw new Error('OSRM konnte keine Route finden.');
                
                const route = data.routes[0];
                this.routeData = {
                    coords: route.geometry.coordinates.map(p => [p[1], p[0]]),
                    distance: route.distance,
                    duration: route.duration,
                    steps: route.legs.flatMap(leg => leg.steps)
                };
                return this.routeData;
            } catch (error) {
                console.error("Fehler bei der Routenberechnung:", error);
                uiManager.showToast("Route konnte nicht berechnet werden.");
                return null;
            }
        },
        
        checkNextManeuver(userPos) {
            if (!this.routeData || !this.routeData.steps) return;
        
            for (let i = 0; i < this.routeData.steps.length; i++) {
                const step = this.routeData.steps[i];
                let instructionText = step.maneuver.instruction;

                // Fallback for missing instruction text - corrected logic
                if (!instructionText || instructionText.trim() === '') {
                    const type = step.maneuver.type;
                    const modifier = step.maneuver.modifier || '';
                    const road = step.name ? ` auf ${step.name}` : '';
                    
                    if (type === 'continue' || type === 'new name') instructionText = `Weiter geradeaus ${road}`;
                    else if (type === 'arrive') instructionText = `Sie haben Ihr Ziel erreicht${road}`;
                    else if (type === 'depart') instructionText = `Starten Sie ${road}`;
                    else instructionText = `${modifier.replace(/_/g, ' ')}${road}`; // More generic for turns etc.
                    instructionText = instructionText.charAt(0).toUpperCase() + instructionText.slice(1); // Capitalize
                }


                const stepLocation = L.latLng(step.maneuver.location[1], step.maneuver.location[0]);
                const distance = userPos.distanceTo(stepLocation);
        
                if (!this.announcedSteps[i]) this.announcedSteps[i] = { pre: false, imminent: false };
        
                if (distance < 150 && distance > 40 && !this.announcedSteps[i].pre) {
                    this.announcedSteps[i].pre = true;
                    const instruction = `In ${Math.round(distance/10)*10} Metern ${instructionText}`;
                    const icon = uiManager.getTurnIcon(step.maneuver.type);
                    uiManager.showNavHint(icon, instruction);
                    ttsManager.speak(instruction);
                    break;
                }
        
                if (distance < 25 && !this.announcedSteps[i].imminent) {
                    this.announcedSteps[i].imminent = true;
                    const instruction = `Jetzt ${instructionText}`;
                    const icon = uiManager.getTurnIcon(step.maneuver.type);
                    uiManager.showNavHint(icon, instruction);
                    ttsManager.speak(instruction);
                    
                    const nextHut = appState.selectedHuts.find(hut => L.latLng(hut.lat, hut.lng).distanceTo(stepLocation) < 50);
                    if (nextHut && !appState.visitedStops.has(nextHut.id)) {
                       appState.visitedStops.add(nextHut.id);
                       uiManager.updateChallengeStatus();
                       if(appState.visitedStops.size === appState.selectedHuts.length) {
                           uiManager.showToast("🏆 Alle Stopps erreicht!");
                           ttsManager.speak("Herzlichen Glückwunsch, du hast alle Ziele erreicht!");
                       }
                    }
                    break; 
                }
            }
        },

        checkDeviation(userPos) {
            if (!appState.isNavigating || !mapManager.routeLine) return;

            const now = Date.now();
            if (now - this.lastRecalcTime < config.routing.recalcDebounceMs) return;

            // Ensure routeLine has coordinates
            const routeLatLngs = mapManager.routeLine.getLatLngs();
            if (!routeLatLngs || routeLatLngs.length < 2) return; 

            const closestPoint = L.GeometryUtil.closest(mapManager.map, routeLatLngs, userPos);
             if (!closestPoint || !closestPoint.latlng) return; // Check if closest point is valid

            const distance = userPos.distanceTo(closestPoint.latlng);

            if (distance > config.routing.deviationThresholdMeters) {
                this.lastRecalcTime = now;
                uiManager.showToast("Route verlassen, neue Route wird berechnet...");
                this.startNavigation(); // Recalculate from current position
            }
        },
        
        toggleSelect(hut) {
            const index = appState.selectedHuts.findIndex(h => h.id === hut.id);
            if (index > -1) {
                appState.selectedHuts.splice(index, 1);
            } else {
                appState.selectedHuts.push(hut);
            }
            uiManager.updateSelectedList();
            this.recalculatePreviewRoute();
            if(appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        },
        
        removeSelected(index) {
            appState.selectedHuts.splice(index, 1);
            uiManager.updateSelectedList();
            this.recalculatePreviewRoute();
             if(appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        },

        async recalculatePreviewRoute() {
            if (appState.selectedHuts.length < 1) {
                mapManager.clearRoute();
                document.getElementById('tour-stats').textContent = '';
                return;
            }
            if (appState.selectedHuts.length < 2) {
                if(mapManager.previewLine) mapManager.map.removeLayer(mapManager.previewLine);
                document.getElementById('tour-stats').textContent = 'Füge einen weiteren Stopp für eine Route hinzu.';
                return;
            }
            
            uiManager.setLoading(true, 'Routenvorschau wird berechnet...');
            const startPos = await userManager.getCurrentPosition();
            const route = await this.fetchRoute(startPos, appState.selectedHuts);
            if(route) {
                mapManager.drawRoute(route.coords, true);
                mapManager.map.fitBounds(mapManager.previewLine.getBounds(), {padding: [50,50]});
                
                const distanceKm = (route.distance / 1000).toFixed(1);
                const durationMin = Math.round(route.duration / 60);
                document.getElementById('tour-stats').textContent = `Tour: ${distanceKm} km, ca. ${durationMin} min`;
            }
            uiManager.setLoading(false);
        },

        async startNavigation() {
            if (appState.currentRoom.id && appState.currentRoom.guideId && appState.currentRoom.guideId !== userManager.userId) {
                uiManager.showToast("Nur der Guide kann die Navigation starten.");
                return;
            }

            if(appState.selectedHuts.length < 1) {
                uiManager.showToast("Bitte wähle zuerst mindestens einen Stopp.");
                return;
            }
            uiManager.setLoading(true, 'Navigation wird gestartet...');
            const startPos = await userManager.getCurrentPosition();
            const route = await this.fetchRoute(startPos, appState.selectedHuts);
            uiManager.setLoading(false);

            if(route) {
                this.announcedSteps = {};
                appState.visitedStops.clear();
                uiManager.updateChallengeStatus();
                mapManager.drawRoute(route.coords);
                mapManager.map.fitBounds(mapManager.routeLine.getBounds(), {padding: [50,50]});
                uiManager.setNavigationState(true);
                userManager.startWatchingPosition();
                uiManager.showToast("Navigation gestartet!");
                
                if (appState.currentRoom.id && appState.currentRoom.guideId === userManager.userId) {
                     // Pass only serializable data
                    const serializableRoute = {
                        coords: route.coords,
                        distance: route.distance,
                        duration: route.duration,
                        steps: route.steps // steps should be serializable
                    };
                    firebaseManager.updateGuidedRoute(true, serializableRoute);
                }
            }
        },

        stopNavigation() {
            if (appState.currentRoom.id && appState.currentRoom.guideId && appState.currentRoom.guideId !== userManager.userId) {
                uiManager.showToast("Nur der Guide kann die Navigation beenden.");
                return;
            }

            userManager.stopWatchingPosition();
            mapManager.clearRoute();
            this.routeData = null;
            this.announcedSteps = {};
            uiManager.setNavigationState(false);
            uiManager.showToast("Navigation beendet.");

            if (appState.currentRoom.id && appState.currentRoom.guideId === userManager.userId) {
                firebaseManager.updateGuidedRoute(false, null);
            }
        },
        
        resetRoute() {
            this.stopNavigation();
            appState.selectedHuts = [];
            appState.visitedStops.clear();
            uiManager.updateSelectedList();
            if(appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        }
    };

    const userManager = {
        watchId: null,
        lastPosition: null,
        userId: localStorage.getItem('radlMapUserId') || `user_${Math.random().toString(36).substring(2, 9)}`,
        warnedAbout: new Set(),

        init() {
            localStorage.setItem('radlMapUserId', this.userId);
            const savedName = localStorage.getItem('username');
            if(savedName) document.getElementById('usernameInput').value = savedName;
            
            this.getCurrentPosition().then(pos => {
                mapManager.updateUserMarker(pos, 20, 0);
                mapManager.map.setView(pos, config.map.defaultZoom);
                weatherManager.fetchWeather(pos.lat, pos.lng);
            }).finally(() => uiManager.setLoading(false));
            
            firebaseManager.rejoinLastRoom();
        },
        
        getCurrentPosition() {
            return new Promise((resolve) => {
                navigator.geolocation.getCurrentPosition(
                    pos => resolve(L.latLng(pos.coords.latitude, pos.coords.longitude)),
                    err => {
                        console.warn("GPS Fehler:", err);
                        uiManager.showToast("GPS nicht verfügbar. Nutze Fallback-Position.");
                        resolve(L.latLng(config.map.defaultCenter[0], config.map.defaultCenter[1]));
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
                );
            });
        },

        startWatchingPosition() {
            if (this.watchId) return;
            const options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 };
            this.watchId = navigator.geolocation.watchPosition(
                pos => {
                    const currentPos = L.latLng(pos.coords.latitude, pos.coords.longitude);
                    let bearing = this.lastPosition ? this.getBearing(this.lastPosition, currentPos) : 0;
                    mapManager.updateUserMarker(currentPos, pos.coords.accuracy, bearing);
                    if (appState.isFollowing) mapManager.map.panTo(currentPos);
                    
                    if(appState.isNavigating) {
                        routeManager.checkNextManeuver(currentPos);
                        routeManager.checkDeviation(currentPos);
                    }
                    if(appState.currentRoom.id) firebaseManager.updateUserPositionInRoom(currentPos);

                    weatherManager.fetchWeather(currentPos.lat, currentPos.lng);
                    this.checkProximityToWarnings(currentPos);

                    this.lastPosition = currentPos;
                },
                err => console.error("GPS Watch Fehler:", err),
                options
            );
        },

        stopWatchingPosition() {
            if(this.watchId) navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
        },
        
        getBearing(from, to) {
            const lat1 = from.lat * Math.PI / 180;
            const lat2 = to.lat * Math.PI / 180;
            const dLon = (to.lng - from.lng) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
        },

        checkProximityToWarnings(userPos) {
            for (const warning of appState.allWarnings) {
                if (!this.warnedAbout.has(warning.id)) {
                    const warningPos = L.latLng(warning.lat, warning.lng);
                    const distance = userPos.distanceTo(warningPos);
                    if (distance < 100) {
                        const message = `Achtung, in ${Math.round(distance/10)*10} Metern gemeldete Gefahr: ${warning.type}.`;
                        ttsManager.speak(message);
                        uiManager.showToast(message);
                        this.warnedAbout.add(warning.id);
                        // Optionally remove from warnedAbout after some time if needed
                    }
                }
            }
        },

        saveUsername() {
            const name = document.getElementById('usernameInput').value.trim();
            if(name) {
                localStorage.setItem('username', name);
                uiManager.showToast('Name gespeichert!');
            }
        },

        async sendSOS() {
            if (!confirm("Sicher, dass du einen SOS-Notruf per WhatsApp senden möchtest?")) return;
            const pos = await this.getCurrentPosition();
            const link = `https://maps.google.com/?q=${pos.lat},${pos.lng}`;
            const message = `🚨 NOTRUF 🚨 Ich brauche Hilfe! Mein Standort: ${link}`;
            window.open(`https://wa.me/?text=${encodeURIComponent(message)}`, "_blank");
        }
    };
    
    const geminiManager = {
        apiKey: "", 

        async callGemini(prompt, jsonSchema = null) {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${this.apiKey}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };

            if (jsonSchema) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: jsonSchema,
                };
            }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                const result = await response.json();
                const candidate = result.candidates?.[0];
                if (!candidate?.content?.parts?.[0]?.text) throw new Error("Invalid API response structure.");
                return candidate.content.parts[0].text;
            } catch (error) {
                console.error("Fehler bei der Gemini-API-Anfrage:", error);
                uiManager.showToast("Ein Fehler mit der KI-Funktion ist aufgetreten.");
                return null;
            }
        },

        async suggestTour() {
            const btn = document.getElementById('suggest-tour-btn');
            btn.disabled = true;
            btn.textContent = 'Denke...';

            try {
                const userPos = await userManager.getCurrentPosition();
                if (appState.allHuts.length === 0) {
                    uiManager.showToast("Hütten werden noch geladen. Bitte kurz warten.");
                    return;
                }
                const difficulty = document.getElementById('tour-difficulty').value;
                const hutsString = appState.allHuts.map(h => `id: ${h.id}, name: ${h.name}`).join('; ');

                const prompt = `Ich bin ein Radfahrer bei Position ${userPos.lat},${userPos.lng}. Schlage mir eine ${difficulty} Fahrradtour vor. Hier ist eine Liste verfügbarer Hütten: ${hutsString}. Schlage eine Route mit 3 bis 5 Stopps vor, liste die IDs der Hütten in der richtigen Reihenfolge auf und gib der Tour einen eingängigen Titel und eine kurze, motivierende Beschreibung (auf Deutsch). Gib die Antwort ausschließlich im folgenden JSON-Format zurück:`;
                
                const schema = {
                    type: "OBJECT",
                    properties: {
                        "title": { "type": "STRING" },
                        "description": { "type": "STRING" },
                        "stop_ids": { "type": "ARRAY", "items": { "type": "STRING" } }
                    },
                    required: ["title", "description", "stop_ids"]
                };

                const resultText = await this.callGemini(prompt, schema);
                if (!resultText) return;

                const resultJson = JSON.parse(resultText);
                uiManager.showToast(`Tour-Vorschlag: ${resultJson.title}`);
                
                appState.selectedHuts = resultJson.stop_ids
                    .map(stopId => appState.allHuts.find(h => h.id === stopId))
                    .filter(Boolean);
                
                uiManager.updateSelectedList();
                routeManager.recalculatePreviewRoute();
                if (appState.currentRoom.id) {
                    firebaseManager.updateRoomHuts();
                }

            } catch(e) {
                console.error("Fehler beim Verarbeiten des Tour-Vorschlags:", e);
                uiManager.showToast("KI-Vorschlag konnte nicht verarbeitet werden.");
            }
            finally {
                btn.disabled = false;
                btn.textContent = 'Vorschlagen';
            }
        },

        async summarizeTour() {
            if (appState.selectedHuts.length < 1) return;
             const btn = document.getElementById('summarize-tour-btn');
            btn.disabled = true;
            btn.innerHTML = '<div class="loader-spinner !w-5 !h-5 !border-2 mx-auto"></div>';


            try {
                const stops = appState.selectedHuts.map(h => h.name).join(', ');
                const distance = routeManager.routeData ? (routeManager.routeData.distance / 1000).toFixed(1) + " km" : "unbekannter Distanz";
                
                const prompt = `Schreibe eine lustige und abenteuerliche Zusammenfassung (ca. 2 Absätze) für eine Fahrradtour auf Deutsch. Die Tour hat folgende Stopps: ${stops}. Die Gesamtdistanz beträgt ca. ${distance}. Die Zusammenfassung soll Lust aufs Radfahren machen.`;

                const summary = await this.callGemini(prompt);
                if (summary) {
                    const formattedSummary = summary.replace(/\n/g, '<br>');
                    uiManager.openPopup("✨ Deine Tour-Zusammenfassung", `<p>${formattedSummary}</p>`);
                }
            } finally {
                btn.disabled = false;
                btn.textContent = '✨ Tour-Zusammenfassung';
            }
        }
    };

    const firebaseManager = {
        db: null,
        
        init() {
            try {
                firebase.initializeApp(config.firebase);
                this.db = firebase.firestore();
                this.loadHuts();
                this.listenToWarnings();
            } catch(e) {
                console.error("Firebase Init Fehler:", e);
                uiManager.showToast("Firebase konnte nicht geladen werden.");
            }
        },
        
        loadHuts() {
            this.db.collection("eierhuetten").where("status", "==", "angenommen").onSnapshot(snapshot => {
                appState.allHuts = [];
                mapManager.clusterGroup.clearLayers();

                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (!data.location) return;
                    
                    const hut = { id: doc.id, ...data, lat: data.location.latitude, lng: data.location.longitude };
                    appState.allHuts.push(hut);
                    
                    const marker = L.marker([hut.lat, hut.lng]);
                    marker.bindTooltip(hut.name, { permanent: true, direction: 'bottom', className: 'hutten-bubble', offset: [0, 10] });
                    marker.bindPopup("Lade...", {minWidth: 300});
                    
                    marker.on('click', () => {
                        const isSelected = appState.selectedHuts.some(h => h.id === hut.id);
                        const bilderUrls = (hut.fotos || []).filter(f => typeof f === 'string' || f.status === 'freigegeben').map(f => typeof f === 'string' ? f : f.url);
                        
                        const popupContent = `
                            <div class="popup-card p-0 overflow-hidden" style="width: 300px;">
                                ${bilderUrls.length > 0 ? `
                                <div class="swiper popup-swiper">
                                  <div class="swiper-wrapper">
                                    ${bilderUrls.map(url => `<div class="swiper-slide"><img src="${url}" alt="${hut.name}"></div>`).join('')}
                                  </div>
                                  <div class="swiper-pagination"></div><div class="swiper-button-prev !text-white"></div><div class="swiper-button-next !text-white"></div>
                                </div>
                                ` : `<img src="${config.noImagePlaceholders[0]}" class="popup-swiper-img">`}
                                
                                <div class="p-4 space-y-3">
                                    <div class="flex justify-between items-start">
                                        <h3 class="font-bold text-lg leading-tight pr-2">${hut.name}</h3>
                                        ${hut.premium ? `<span class="text-xs font-bold text-yellow-800 bg-yellow-200 dark:bg-yellow-800 dark:text-yellow-200 px-2 py-1 rounded-full flex-shrink-0">PREMIUM</span>` : ''}
                                    </div>

                                    ${hut.beschreibung ? `<p class="text-sm text-gray-600 dark:text-gray-300 border-t border-b border-[var(--border-color)] py-2">${hut.beschreibung}</p>` : ''}
                                    
                                     <div class="text-sm border-t border-[var(--border-color)] pt-2">
                                        <h4 class="font-semibold text-xs uppercase text-gray-500 mb-1">Öffnungszeiten</h4>
                                        <p>${hut.oeffnungszeiten || 'Keine Angabe'}</p>
                                    </div>


                                    <div class="grid grid-cols-2 gap-2 text-sm">
                                        <div class="flex items-center gap-2">
                                           <span>🐾</span>
                                           <span>Tiere: ${hut.tiere ? hut.tiere.join(', ') : 'Keine'}</span>
                                        </div>
                                        <div class="flex items-center gap-2">
                                           <span>⚡️</span>
                                           <span>Strom: ${hut.strom || 'k.A.'}</span>
                                        </div>
                                        <div class="flex items-center gap-2">
                                           <span>🪑</span>
                                           <span>Plätze: ${hut.sitzplaetze || 'k.A.'}</span>
                                        </div>
                                    </div>
                                    
                                    ${hut.premium ? `
                                        <div class="space-y-1 text-sm border-t border-[var(--border-color)] pt-2">
                                            <h4 class="font-semibold text-xs uppercase text-gray-500">Premium Info</h4>
                                            ${hut.telefon ? `<p>📞 <a href="tel:${hut.telefon}" class="text-blue-500 hover:underline">${hut.telefon}</a></p>`: ''}
                                            ${hut.website ? `<p>🌐 <a href="${hut.website}" target="_blank" rel="noopener" class="text-blue-500 hover:underline">Website</a></p>`: ''}
                                        </div>
                                    `: ''}

                                    <button id="btn-${hut.id}" class="w-full mt-2 p-2 rounded-lg font-semibold text-white ${isSelected ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'} transition-colors">
                                        ${isSelected ? 'Von Tour entfernen' : 'Zur Tour hinzufügen'}
                                    </button>
                                </div>
                            </div>
                        `;
                        marker.setPopupContent(popupContent).openPopup();
                        
                        setTimeout(() => {
                           const btn = document.getElementById(`btn-${hut.id}`);
                           if(btn) {
                               btn.onclick = () => {
                                    routeManager.toggleSelect(hut);
                                    marker.closePopup();
                                };
                           }
                            const swiperEl = marker.getPopup().getElement().querySelector('.popup-swiper');
                            if (swiperEl && !swiperEl.swiper) {
                                new Swiper(swiperEl, {
                                    loop: true,
                                    pagination: { el: '.swiper-pagination', clickable: true },
                                    navigation: {
                                        nextEl: '.swiper-button-next',
                                        prevEl: '.swiper-button-prev',
                                    },
                                });
                            }
                        }, 0);
                    });
                    mapManager.clusterGroup.addLayer(marker);
                });
            }, err => {
                console.error("Fehler beim Laden der Hütten:", err);
                uiManager.showToast("Hütten konnten nicht geladen werden.");
            });
        },
        
        rejoinLastRoom() {
            const lastRoomId = localStorage.getItem('lastRoomId');
            if(lastRoomId) {
                if(confirm(`Möchtest du dem Raum "${lastRoomId}" wieder beitreten?`)) {
                    this.joinRoom(lastRoomId);
                }
            }
        },
        
        joinRoom(id = null) {
            let roomId = id || document.getElementById('roomIdInput').value.trim();
            if(!roomId) roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
            
            appState.currentRoom.id = roomId;
            localStorage.setItem('lastRoomId', roomId);
            
            this.listenToRoom(roomId);
            this.listenToUsersInRoom(roomId);
            userManager.startWatchingPosition(); 
            
            uiManager.updateRoomUI(appState.currentRoom);
            uiManager.showToast(`Raum ${roomId} beigetreten.`);
        },
        
        leaveRoom() {
            if(appState.roomUnsubscribe) appState.roomUnsubscribe();
            if(appState.userPositionsUnsubscribe) appState.userPositionsUnsubscribe();
            
            localStorage.removeItem('lastRoomId');
            
            if(appState.currentRoom.id) {
                this.db.collection('room_positions').doc(appState.currentRoom.id).collection('users').doc(userManager.userId).delete();
            }

            appState.currentRoom.id = null;
            appState.currentRoom.guideId = null;
            
            Object.keys(mapManager.groupMarkers).forEach(id => mapManager.removeGroupMarker(id));

            uiManager.updateRoomUI(appState.currentRoom);
            uiManager.showToast("Raum verlassen.");
        },
        
        listenToRoom(roomId) {
            if(appState.roomUnsubscribe) appState.roomUnsubscribe();
            appState.roomUnsubscribe = this.db.collection("rooms").doc(roomId).onSnapshot(doc => {
                const roomData = doc.data() || {};
                appState.currentRoom = {id: roomId, ...roomData};
                
                const isSelfGuide = userManager.userId === roomData.guideId;

                // Sync tour for non-guides
                if (!isSelfGuide) {
                    const hutIds = roomData.hutIds || [];
                    const localIds = appState.selectedHuts.map(h => h.id).join(',');
                    if (hutIds.join(',') !== localIds) {
                        appState.selectedHuts = hutIds.map(id => appState.allHuts.find(h => h.id === id)).filter(Boolean);
                        uiManager.updateSelectedList();
                        routeManager.recalculatePreviewRoute();
                         uiManager.showToast("Tour im Raum wurde aktualisiert!");
                    }
                    // Sync navigation for non-guides
                     if(roomData.isNavigating && !appState.isNavigating && roomData.guidedRoute) {
                        routeManager.routeData = roomData.guidedRoute;
                        mapManager.drawRoute(roomData.guidedRoute.coords);
                        uiManager.setNavigationState(true);
                        userManager.startWatchingPosition(); // Start watching to follow guide
                    } else if (!roomData.isNavigating && appState.isNavigating && !isSelfGuide) {
                        routeManager.stopNavigation(); // Stop navigation if guide stops
                    }
                }
                uiManager.updateRoomUI(appState.currentRoom);
            });
        },
        
        listenToUsersInRoom(roomId) {
            if (appState.userPositionsUnsubscribe) appState.userPositionsUnsubscribe();
            appState.userPositionsUnsubscribe = this.db.collection('room_positions').doc(roomId).collection('users').onSnapshot(snapshot => {
                const activeUsers = [];
                const now = Date.now();
                const currentMemberIds = new Set();
                
                snapshot.forEach(doc => {
                    const user = doc.data();
                    const userId = doc.id;
                    currentMemberIds.add(userId);

                    if (userId !== userManager.userId && user.timestamp && (now - user.timestamp) < 60000) { // Check timestamp existence
                        mapManager.updateGroupMarker({ id: userId, ...user });
                        activeUsers.push(user);
                    } else if (userId !== userManager.userId) {
                        mapManager.removeGroupMarker(userId);
                    }
                });

                Object.keys(mapManager.groupMarkers).forEach(markerId => {
                    if (!currentMemberIds.has(markerId)) {
                        mapManager.removeGroupMarker(markerId);
                    }
                });

                uiManager.updateRoomUI(appState.currentRoom, activeUsers);
            });
        },
        
        updateUserPositionInRoom(pos) {
            if(!appState.currentRoom.id) return;
            const name = localStorage.getItem('username') || 'Anonym';
            const colors = ['#e11d48', '#2563eb', '#16a34a', '#f97316', '#9333ea'];
            const color = colors[Math.abs(userManager.userId.charCodeAt(0) % colors.length)];
            
            this.db.collection('room_positions').doc(appState.currentRoom.id).collection('users').doc(userManager.userId).set({
                lat: pos.lat,
                lng: pos.lng,
                name: name,
                color: color,
                timestamp: Date.now()
            }, { merge: true });
        },
        
        updateRoomHuts() {
            if(!appState.currentRoom.id) return;
            const hutIds = appState.selectedHuts.map(h => h.id);
            this.db.collection("rooms").doc(appState.currentRoom.id).set({ hutIds }, { merge: true });
        },

        setGuide() {
            if(!appState.currentRoom.id) return;
            let newGuideId = userManager.userId;
            let newGuideName = localStorage.getItem('username') || 'Anonym';

            if (appState.currentRoom.guideId === userManager.userId) {
                newGuideId = null;
                newGuideName = null;
            } else if (appState.currentRoom.guideId) {
                uiManager.showToast("Es gibt bereits einen Guide.");
                return; // Only allow setting if no guide or self
            }
            this.db.collection("rooms").doc(appState.currentRoom.id).set({ guideId: newGuideId, guideName: newGuideName }, { merge: true });
        },

        updateGuidedRoute(isNavigating, routeData) {
            if(!appState.currentRoom.id) return;
            this.db.collection("rooms").doc(appState.currentRoom.id).set({
                isNavigating: isNavigating,
                guidedRoute: routeData ? JSON.parse(JSON.stringify(routeData)) : null, // Ensure serializability
            }, { merge: true });
        },

        addWarning() {
            const type = document.getElementById('warning-type').value;
            const description = document.getElementById('warning-description').value;
            const latlng = uiManager.tempWarningLatLng;
            if(!latlng) return;

            this.db.collection('warnings').add({
                lat: latlng.lat,
                lng: latlng.lng,
                type: type,
                description: description,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                userId: userManager.userId,
            }).then(() => {
                uiManager.showToast("Gefahr gemeldet!");
                uiManager.hideAddWarningModal();
            });
        },

        listenToWarnings() {
            const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
            this.db.collection('warnings')
               .where('createdAt', '>', new Date(twentyFourHoursAgo)) // Query directly in Firestore
               .onSnapshot(snapshot => {
                    const currentWarningIds = new Set();
                    appState.allWarnings = [];

                    snapshot.forEach(doc => {
                        const warning = { id: doc.id, ...doc.data() };
                        appState.allWarnings.push(warning);
                        currentWarningIds.add(warning.id);
                        if (!mapManager.warningMarkers[warning.id]) {
                           mapManager.addWarningMarker(warning);
                        }
                    });

                    // Remove markers for expired or deleted warnings
                    Object.keys(mapManager.warningMarkers).forEach(markerId => {
                        if (!currentWarningIds.has(markerId)) {
                            mapManager.removeWarningMarker(markerId);
                        }
                    });
            });
        }
    };
    
    const dragAndDrop = {
        draggedIndex: null,
        start(event, index) {
            this.draggedIndex = index;
            event.dataTransfer.effectAllowed = 'move';
        },
        drop(event, targetIndex) {
            event.preventDefault();
            if (this.draggedIndex === null || this.draggedIndex === targetIndex) return;

            const draggedItem = appState.selectedHuts.splice(this.draggedIndex, 1)[0];
            appState.selectedHuts.splice(targetIndex, 0, draggedItem);

            this.draggedIndex = null;
            uiManager.updateSelectedList();
            routeManager.recalculatePreviewRoute();
            if (appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        }
    };

    const weatherManager = {
        lastFetchTime: 0,
        async fetchWeather(lat, lng) {
            const now = Date.now();
            if (now - this.lastFetchTime < 10 * 60 * 1000) return; // Update every 10 mins
            this.lastFetchTime = now;

            try {
                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true`);
                const data = await response.json();
                if(data && data.current_weather) {
                    this.updateWidget(data.current_weather);
                }
            } catch (error) {
                console.error("Fehler beim Laden des Wetters:", error);
            }
        },
        updateWidget(weather) {
            const widget = document.getElementById('weather-widget');
            const icon = this.getWeatherIcon(weather.weathercode);
            const temp = Math.round(weather.temperature);
            widget.innerHTML = `<span>${icon}</span><span>${temp}°C</span>`;
        },
        getWeatherIcon(code) {
            if (code === 0) return '☀️';
            if (code >= 1 && code <= 3) return '⛅️';
            if (code === 45 || code === 48) return '🌫️';
            if (code >= 51 && code <= 55) return '🌦️';
            if (code >= 61 && code <= 67) return '🌧️';
            if (code >= 71 && code <= 77) return '❄️';
            if (code >= 80 && code <= 82) return '⛈️';
            if (code >= 95 && code <= 99) return '🌩️';
            return '-';
        }
    };

    // ----------------------------------------------------------
    //  5. INITIALISIERUNG
    // ----------------------------------------------------------
    document.addEventListener('DOMContentLoaded', () => {
        uiManager.setLoading(true);
        uiManager.init();
        mapManager.init(config.map.defaultCenter, config.map.defaultZoom);
        firebaseManager.init();
        userManager.init();
    });

  </script>
</body>
</html>

