<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title data-i18n="app.title">RadlMap Navigation üö≤</title>

  <!-- Meta Tags f√ºr Social Media Vorschau -->
  <meta property="og:title" content="üè†üö≤ RadlMap Tourplaner" />
  <meta property="og:description" content="Plane deine n√§chste Radtour mit H√ºtten! Mit Live-GPS, Tourenspeicher, Gruppenfunktion & mehr." />
  <meta property="og:image" content="https://radlmap.net/img/preview.png" />
  <meta property="og:url" content="https://radlmap.net" />
  <meta name="twitter:card" content="summary_large_image" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üö≤</text></svg>">

  <!-- Externe Bibliotheken -->
  <link rel="manifest" href="manifest.json">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>
  <script src="https://unpkg.com/@mapbox/polyline"></script>
  <link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"/>
  <script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script>
  <script src="https://unpkg.com/leaflet-geometryutil"></script> <!-- Library for distance calculations -->

  <!-- NEU: Chart.js f√ºr H√∂henprofil -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <style>
    /* Inter Schriftart f√ºr ein modernes UI */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      -webkit-tap-highlight-color: transparent;
    }

    #map {
      height: 100%;
      width: 100%;
      background: #f0f0f0;
      z-index: 1;
    }

    /* Lade-Overlay */
    #loader {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(8px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease;
    }
    .loader-spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-left-color: #2563eb;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Dark Mode Variablen & √úberg√§nge */
    :root {
      --bg-color: #ffffff;
      --text-color: #1f2937;
      --ui-bg: rgba(255, 255, 255, 0.85);
      --border-color: #e5e7eb;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .dark {
      --bg-color: #111827;
      --text-color: #f9fafb;
      --ui-bg: rgba(31, 41, 55, 0.85);
      --border-color: #374151;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    body, .ui-element {
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .leaflet-popup-content-wrapper, .leaflet-popup-tip {
      background: var(--ui-bg) !important;
      color: var(--text-color) !important;
      backdrop-filter: blur(10px);
      border-radius: 12px; /* Rounded popups */
    }
     .leaflet-popup-content {
        margin: 0 !important; /* Remove default margin for card design */
        line-height: 1.5;
        width: 300px !important; /* Fixed width for popup */
    }


    /* Toast-Nachrichten */
    #toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #1f2937;
      color: white;
      padding: 10px 20px;
      border-radius: 9999px;
      font-size: 14px;
      z-index: 9000;
      box-shadow: var(--shadow);
      opacity: 0;
      transition: transform 0.4s ease, opacity 0.4s ease;
      pointer-events: none;
    }
    #toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* Haupt-Toolbar */
    #toolbar {
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      background: var(--ui-bg);
      border: 1px solid var(--border-color);
    }
    #toolbar button {
      transition: background-color 0.2s, transform 0.1s;
    }
    #toolbar button:active {
      transform: scale(0.95);
    }

    /* Seitenleisten-Panel (Dashboard) */
    #sidebar-panel {
        position: fixed;
        top: 0;
        right: 0;
        height: 100%;
        width: 320px;
        max-width: 90vw;
        background: var(--bg-color);
        z-index: 5000;
        transform: translateX(100%);
        transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        box-shadow: -10px 0 25px rgba(0,0,0,0.1);
        border-left: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
    }
    #sidebar-panel.open {
        transform: translateX(0);
    }
    #sidebar-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.4);
        z-index: 4999;
        opacity: 0;
        transition: opacity 0.4s ease;
        pointer-events: none;
    }
    #sidebar-panel.open + #sidebar-overlay {
        opacity: 1;
        pointer-events: auto;
    }

    /* Verbesserte Scrollbars */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
    .dark ::-webkit-scrollbar-thumb { background: #555; }

    /* Navigations-Hinweise */
    #navHint {
        position: absolute;
        top: 80px; /* Angepasste Position */
        left: 50%;
        backdrop-filter: blur(10px);
        box-shadow: var(--shadow);
        border: 1px solid var(--border-color);
        transition: transform 0.4s ease, opacity 0.4s ease;
        transform: translate(-50%, 50px);
        opacity: 0;
        font-size: 1.2rem;
        font-weight: 600;
        pointer-events: auto;
    }
     #navHint.visible {
        transform: translate(-50%, 0);
        opacity: 1;
    }

    /* User Marker SVG mit Animation */
    @keyframes pulse {
      0% { r: 0; opacity: 0.6; }
      100% { r: 40; opacity: 0; }
    }
    .pulse-circle {
      animation: pulse 2s infinite ease-out;
    }

    /* Popup Styling */
    .popup-card {
        font-size: 0.9rem; /* Slightly smaller text */
        overflow: hidden; /* Prevent content spill */
    }
    .popup-content-area { /* Scrollbarer Bereich */
        max-height: 250px; /* Maximale H√∂he f√ºr den Inhaltsbereich */
        overflow-y: auto;
        padding: 1rem; /* Padding f√ºr den Inhalt */
        scrollbar-width: thin; /* Firefox scrollbar */
        scrollbar-color: #888 transparent; /* Firefox scrollbar color */
    }
     .popup-content-area::-webkit-scrollbar { width: 5px; } /* Chrome/Safari scrollbar */
    .popup-content-area::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
     .dark .popup-content-area::-webkit-scrollbar-thumb { background: #555; }
    .dark .popup-content-area { scrollbar-color: #555 transparent; }


    .popup-swiper img {
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
        width: 100%;
        height: 150px;
        object-fit: cover;
    }
     .popup-button-container { /* Button Container */
        padding: 0.5rem 1rem 1rem 1rem; /* Padding um den Button */
        border-top: 1px solid var(--border-color); /* Trennlinie */
        background: var(--ui-bg); /* Hintergrund, damit Inhalt nicht durchscheint */
    }

    .group-marker {
        text-align: center;
        font-weight: bold;
        color: #fff;
    }

    .hutten-bubble {
        background: rgba(255, 255, 255, 0.8);
        border: none;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 10px;
        font-weight: 600;
        color: #333;
    }
    .dark .hutten-bubble {
        background: rgba(31, 41, 55, 0.8);
        color: #f9fafb;
    }
    .warning-icon {
        background: none;
        border: none;
        font-size: 20px; /* Make warning icon slightly larger */
    }
     .leaflet-div-icon {
        background: none;
        border: none;
    }

    /* SMARTER: Stil f√ºr Offline-Indikator */
    #offline-indicator {
        animation: pulse-offline 2s infinite;
    }
    @keyframes pulse-offline {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* NEU: CSS f√ºr √ñffnungszeiten-Liste */
    .oeffnungszeiten-list {
        list-style: none;
        padding-left: 0;
        margin: 0;
        font-size: 0.85rem;
    }
    .oeffnungszeiten-list li {
        padding: 2px 0;
        display: flex;
    }
    .oeffnungszeiten-list li .tag {
        font-weight: 600;
        min-width: 3rem; /* 48px */
        margin-right: 0.5rem;
        display: inline-block;
        flex-shrink: 0;
    }
    .oeffnungszeiten-list li .zeit {
        display: inline-block;
    }

  </style>
</head>
<body class="antialiased">
<div id="loginScreen" class="flex items-center justify-center min-h-screen bg-gradient-to-br from-green-50 to-green-100 hidden">
  <div class="bg-white rounded-2xl shadow-xl p-8 max-w-md w-full transform transition hover:scale-[1.01]">
    
    <div class="text-center mb-6">
        <h1 class="text-3xl font-extrabold text-green-700">Willkommen!</h1>
        <p class="text-gray-500 mt-2">Bitte melde dich an, um fortzufahren.</p>
    </div>

    <div id="authFormContainer">
        <form id="loginForm" class="space-y-4">
            <input id="loginEmail" type="email" placeholder="E-Mail" class="w-full border p-3 rounded-lg" required>
            <input id="loginPassword" type="password" placeholder="Passwort" class="w-full border p-3 rounded-lg" required>
            <button type="submit" class="w-full bg-green-600 text-white font-bold py-3 rounded-lg hover:bg-green-700 transition">Anmelden</button>
            <p class="text-xs text-center text-gray-500">
                <a href="#" onclick="showPasswordReset()" class="text-green-600 hover:underline">Passwort vergessen?</a>
            </p>
        </form>
        
        <form id="registerForm" class="hidden space-y-4">
            <input id="registerName" type="text" placeholder="Dein Name" class="w-full border p-3 rounded-lg" required>
            <input id="registerEmail" type="email" placeholder="E-Mail" class="w-full border p-3 rounded-lg" required>
            <input id="registerPassword" type="password" placeholder="Passwort" class="w-full border p-3 rounded-lg" required>
            <button type="submit" class="w-full bg-blue-600 text-white font-bold py-3 rounded-lg hover:bg-blue-700 transition">Registrieren</button>
        </form>

        <p class="text-center text-sm mt-4">
            <a href="#" id="authToggle" class="text-green-600 hover:underline">Noch kein Account? Jetzt registrieren</a>
        </p>
    </div>
    
    <div class="flex items-center my-6">
        <hr class="flex-grow border-t border-gray-300">
        <span class="px-3 text-gray-500 text-sm">oder</span>
        <hr class="flex-grow border-t border-gray-300">
    </div>

    <button onclick="doGoogleLogin()" 
      class="flex items-center gap-3 px-6 py-3 bg-white border border-gray-300 text-gray-700 rounded-xl shadow-sm transition w-full justify-center font-medium hover:bg-gray-50">
      <img src="https://www.svgrepo.com/show/475656/google-color.svg" 
           class="w-6 h-6" />
      <span>Mit Google anmelden</span>
    </button>
    
    <div id="authError" class="mt-4 text-center text-red-500 text-sm"></div>
  </div>
</div>


<div id="mainApp" class="h-full relative hidden">
  
  <!-- Ladebildschirm -->
  <div id="loader">
    <div class="loader-spinner"></div>
    <p class="mt-4 text-gray-600" data-i18n="loader.text">Karte wird geladen...</p>
  </div>

  <!-- Karten-Container -->
  <div id="map"></div>

  <!-- Toast Element -->
  <div id="toast"></div>

  <!-- UI Elemente √ºber der Karte -->
  <div class="absolute top-4 right-4 z-10 space-y-3">
   <!--- <button onclick="uiManager.toggleSidebar()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
    </button> --->
     <button id="theme-toggle-btn" onclick="uiManager.toggleTheme()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
        <!-- Icon wird per JS gesetzt -->
    </button>
  </div>

  <!-- Wetter Widget & NEU: KMH Anzeige -->
  <div class="absolute top-4 left-4 z-10 flex gap-2">
            <div id="weather-widget" onclick="weatherManager.showHourlyForecast()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)] flex items-center gap-2 text-lg font-semibold cursor-pointer">
        <span id="weather-icon" class="text-2xl">üå§Ô∏è</span> <span id="weather-temp">--¬∞C</span> <span id="offline-indicator" class="hidden text-xs text-red-500 font-bold" data-i18n="general.offline">OFFLINE</span>
      </div>
      <!-- NEU: KMH Anzeige -->
                  <div id="speed-widget" onclick="uiManager.showNavStatsPopup()" class="hidden bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full px-4 py-3 border border-[var(--border-color)] flex items-center gap-2 text-lg font-semibold cursor-pointer">
          <span>-- km/h</span>
      </div>

  
  </div>

  <!-- Schnellnavigation -->
  <div class="absolute left-4 top-1/2 -translate-y-1/2 z-10 flex flex-col gap-3">
     <!---  <a href="index.html" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon></svg>
      </a>--->
           <button onclick="userManager.recenterMap()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon></svg>
      </button>

      <button onclick="uiManager.toggleSidebar()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>
      </button>
  </div>

    <div class="absolute top-0 left-0 right-0 p-4 z-10 flex flex-col items-center gap-2 pointer-events-none">
    
    <div id="navHint" class="hidden items-center gap-3 bg-[var(--ui-bg)] text-[var(--text-color)] rounded-full px-4 py-2 max-w-sm mx-auto shadow-lg border border-[var(--border-color)] pointer-events-auto">
        </div>
</div>
<!-- Dashboard/Seitenleiste -->
  <aside id="sidebar-panel">
    <div class="flex items-center justify-between p-4 border-b border-[var(--border-color)]">
        <h2 class="text-xl font-bold" data-i18n="dashboard.title">Dashboard</h2>
        <button onclick="uiManager.toggleSidebar()" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
    </div>

    <!-- Tab Navigation -->
    <nav class="flex border-b border-[var(--border-color)] p-2">
      <button data-tab="tab-tour" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.tour">Tour</button>
      <button data-tab="tab-raum" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.room">Raum</button>
      <button data-tab="tab-nutzer" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.profile">Profil</button>
      <!-- NEU: Statistik Tab -->
      <button data-tab="tab-stats" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.stats">Statistik</button>
      <button data-tab="tab-einstellungen" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.setup">Setup</button>
    </nav>

    <div class="flex-1 overflow-y-auto p-4 space-y-6">
      <!-- Tour Tab -->
      <section id="tab-tour" class="tab-panel space-y-4">

        <h3 class="font-bold" data-i18n="tour.stopsTitle">üìã Ausgew√§hlte Stopps</h3>
        <p class="text-xs text-gray-500 -mt-3" data-i18n="tour.stopsDesc">Reihenfolge per Drag & Drop √§ndern.</p>
        <ul id="selectedList" class="space-y-2" ondragover="event.preventDefault()"></ul>
        <div id="tour-actions" class="hidden space-y-2">
            <p id="challenge-status" class="text-sm font-semibold text-center text-green-600"></p>
            <p id="tour-stats" class="text-sm text-gray-500 my-2 text-center"></p>

            <div id="elevation-chart-container" class="hidden w-full h-32 mt-2">
                <canvas id="elevation-chart"></canvas>
            </div>
          <button id="save-tour-btn" onclick="uiManager.showSaveTourPopup()" class="w-full bg-indigo-500 text-white p-2 rounded-lg text-sm font-medium hover:bg-indigo-600 transition">
          üíæ Aktuelle Tour speichern
          </button>
        </div>
      </section>

      <!-- Raum Tab -->
      <section id="tab-raum" class="tab-panel hidden space-y-4">
        <h3 class="font-bold" data-i18n="room.title">üë• Raum-Verwaltung</h3>
        <div id="room-active-view" class="hidden space-y-2">
            <p class="text-sm" data-i18n="room.inRoom">Du bist im Raum: <strong id="current-room-id" class="font-mono bg-gray-100 dark:bg-gray-700 px-1 rounded"></strong></p>
            <p id="guide-info" class="text-sm"></p>
            <!-- NEU: Einladungslink Button -->
            <button id="invite-btn" onclick="uiManager.copyInviteLink()" class="w-full bg-indigo-500 text-white p-2 rounded-lg text-sm font-medium flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>
                  <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>
                </svg>
                <span data-i18n="room.copyInviteLink">Einladungslink kopieren</span>
            </button>
            <button id="guide-btn" onclick="firebaseManager.setGuide()" class="w-full bg-blue-500 text-white p-2 rounded-lg text-sm font-medium" data-i18n="room.becomeGuide">Guide werden</button>
            <div id="guided-tour-info" class="hidden text-sm p-2 bg-yellow-100 dark:bg-yellow-900 rounded-lg text-center" data-i18n="room.guidedTourActive">Eine gef√ºhrte Tour ist aktiv.</div>

            <button onclick="firebaseManager.leaveRoom()" class="w-full bg-red-500 text-white p-2 rounded-lg text-sm font-medium" data-i18n="room.leaveBtn">Raum verlassen</button>
            <div class="mt-4">
                <h4 class="font-semibold text-sm mb-2" data-i18n="room.activeUsers">Aktive Nutzer im Raum:</h4>
                <ul id="room-user-list" class="space-y-1 text-sm text-gray-600 dark:text-gray-300"></ul>
            </div>
        </div>
        <div id="room-join-view" class="space-y-2">
             <!-- NEU: Hinweistext f√ºr Raumbeitritt -->
            <p class="text-xs text-gray-500" data-i18n="room.joinHint">Gib eine bestehende Raum-ID ein, um beizutreten, oder erstelle einen neuen Raum √ºber den Einladungslink.</p>
            <input id="roomIdInput" type="text" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent" data-i18n-placeholder="room.roomIdPlaceholderJoin" placeholder="Raum-ID eingeben">
            <button onclick="firebaseManager.joinRoom()" class="w-full bg-green-500 text-white p-2 rounded-lg text-sm font-medium" data-i18n="room.joinBtnSimple">Beitreten</button>
        </div>
      </section>

      <!-- Nutzer Tab -->
      <section id="tab-nutzer" class="tab-panel hidden space-y-4">
          <h3 class="font-bold" data-i18n="profile.title">üë§ Mein Profil</h3>
          <div>
    <label class="text-sm font-medium" data-i18n="profile.nameLabel">Dein Name</label>
    <div id="usernameDisplay" class="flex-1 p-3 border border-gray-200 dark:border-gray-700 rounded-lg bg-gray-50 dark:bg-gray-800 mt-1 font-semibold">
        Lade Name...
    </div>
    <p class="text-xs text-gray-500 mt-1">Dein Google Account-Name wird f√ºr R√§ume und Nachrichten verwendet.</p>
          </div>
           <button onclick="userManager.sendSOS()" class="w-full flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 text-white px-4 py-3 rounded-lg font-bold shadow-lg transition" data-i18n="profile.sosBtn">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>
            SOS Notruf
          </button>
      </section>

      <!-- NEU: Statistik Tab -->
      <section id="tab-stats" class="tab-panel hidden space-y-4">
    <h3 class="font-bold">üìä Meine gespeicherten Touren</h3>
    <p class="text-xs text-gray-500 -mt-3">Hier sind deine gespeicherten Touren.</p>
    <div id="stats-list" class="space-y-3">
        <p data-i18n="stats.loading">Lade Touren...</p>
    </div>
      </section>

      <!-- Einstellungen Tab -->
      <section id="tab-einstellungen" class="tab-panel hidden space-y-4">
        <h3 class="font-bold" data-i18n="setup.title">‚öôÔ∏è Einstellungen</h3>

        <div>
          <label for="user-pref-intensity" class="block text-sm font-medium mb-1" data-i18n="setup.intensityLabel">Bevorzugte Intensit√§t</label>
          <select id="user-pref-intensity" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
              <option value="eher flach" data-i18n="setup.intensity.flat">Eher flach</option>
              <option value="h√ºgelig" data-i18n="setup.intensity.hilly">H√ºgelig</option>
              <option value="anspruchsvolle Anstiege" data-i18n="setup.intensity.climbs">Anspruchsvolle Anstiege</option>
          </select>
        </div>
        <div>
          <label for="user-pref-type" class="block text-sm font-medium mb-1" data-i18n="setup.typeLabel">Bevorzugter Tour-Typ</label>
          <select id="user-pref-type" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
              <option value="naturfokussiert" data-i18n="setup.type.nature">Naturfokussiert</option>
              <option value="kulinarisch" data-i18n="setup.type.culinary">Kulinarisch</option>
              <option value="kulturelle Sehensw√ºrdigkeiten" data-i18n="setup.type.culture">Kulturelle Sehensw√ºrdigkeiten</option>
          </select>
        </div>

        <div>
          <label for="appLangSelect" class="block text-sm font-medium mb-1" data-i18n="setup.languageLabel">üó£Ô∏è App-Sprache</label>
          <select id="appLangSelect" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent"></select>
        </div>
        <div>
            <a href="#" onclick="uiManager.openPopup('Datenschutz', 'Hier stehen die Datenschutzbestimmungen...')" class="text-blue-500 hover:underline text-sm" data-i18n="setup.privacyLink">Datenschutz & Impressum</a>
        </div>
      </section>
    </div>
  </aside>
  <div id="sidebar-overlay" onclick="uiManager.toggleSidebar()"></div>


  <!-- Haupt-Toolbar unten -->
  <div id="toolbar" class="absolute bottom-5 left-1/2 -translate-x-1/2 z-10 flex items-center gap-2 p-2 rounded-full">
    <button id="startBtn" onclick="routeManager.startNavigation()" class="bg-green-500 text-white rounded-full px-6 py-3 font-bold text-lg" data-i18n="toolbar.start">Start</button>
    <button id="stopBtn" onclick="routeManager.stopNavigation()" class="bg-red-500 text-white rounded-full px-6 py-3 font-bold text-lg hidden" data-i18n="toolbar.stop">Stop</button>
    <button id="resetBtn" onclick="routeManager.resetRoute()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
    </button>
    <button id="voice-toggle" onclick="appState.toggleVoice()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3">
        <!-- Icon wird per JS gesetzt -->
    </button>
    <button id="follow-toggle" onclick="appState.toggleFollow()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3 hidden">
        <!-- Icon wird per JS gesetzt -->
    </button>
  </div>

  <!-- Popup f√ºr Datenschutz, KI-Ergebnisse etc. -->
  <div id="popupOverlay" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9990] flex items-center justify-center p-4" onclick="uiManager.closePopup()">
    <div id="popupContent" class="bg-[var(--bg-color)] rounded-2xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto p-6 relative" onclick="event.stopPropagation()">
        <!-- Inhalt wird dynamisch geladen -->
    </div>
  </div>

  <!-- Modal zum Melden einer Gefahr -->
    <div id="add-warning-modal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9990] flex items-center justify-center p-4">
        <div class="bg-[var(--bg-color)] rounded-2xl shadow-xl max-w-sm w-full p-6 space-y-4">
            <h3 class="font-bold text-lg" data-i18n="warning.title">Gefahr an dieser Stelle melden</h3>
            <div>
                <label for="warning-type" class="text-sm font-medium" data-i18n="warning.typeLabel">Art der Gefahr</label>
                <select id="warning-type" class="w-full mt-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
                    <option data-i18n="warning.type.pothole">Schlagloch</option>
                    <option data-i18n="warning.type.obstacle">Hindernis</option>
                    <option data-i18n="warning.type.crossing">Gef√§hrliche Kreuzung</option>
                    <option data-i18n="warning.type.other">Sonstiges</option>
                </select>
            </div>
            <div>
                <label for="warning-description" class="text-sm font-medium" data-i18n="warning.descLabel">Kurze Beschreibung (optional)</label>
                <input id="warning-description" type="text" class="w-full mt-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent" data-i18n-placeholder="warning.descPlaceholder" placeholder="z.B. Tiefe Spurrille">
            </div>
            <div class="flex gap-2 justify-end">
                <button onclick="uiManager.hideAddWarningModal()" class="px-4 py-2 rounded-lg" data-i18n="general.cancel">Abbrechen</button>
                <button onclick="firebaseManager.addWarning()" class="px-4 py-2 bg-blue-500 text-white rounded-lg" data-i18n="general.report">Melden</button>
            </div>
        </div>
    </div>
  </div>


    

  <!-- Scripte: Firebase & Logik -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
  <script>
    
/***********************
     * AUTHENTICATION
     ***********************/

    async function doGoogleLogin() {
        const provider = new firebase.auth.GoogleAuthProvider();
        try {
            await firebase.auth().signInWithPopup(provider);
            showToast("‚úÖ Erfolgreich mit Google angemeldet");
        } catch (e) {
            handleAuthError(e);
        }
    }

    async function handleRegistration(event) {
        event.preventDefault();
        const name = document.getElementById('registerName').value;
        const email = document.getElementById('registerEmail').value;
        const password = document.getElementById('registerPassword').value;
        try {
            const userCredential = await firebase.auth().createUserWithEmailAndPassword(email, password);
            await userCredential.user.updateProfile({ displayName: name });
            showToast("‚úÖ Registrierung erfolgreich!");
        } catch (e) {
            handleAuthError(e);
        }
    }

    async function handleLogin(event) {
        event.preventDefault();
        const email = document.getElementById('loginEmail').value;
        const password = document.getElementById('loginPassword').value;
        try {
            await firebase.auth().signInWithEmailAndPassword(email, password);
            showToast("‚úÖ Anmeldung erfolgreich!");
        } catch (e) {
            handleAuthError(e);
        }
    }

    function showPasswordReset() {
        const email = prompt("Bitte gib deine E-Mail-Adresse ein, um dein Passwort zur√ºckzusetzen:");
        if (email) {
            firebase.auth().sendPasswordResetEmail(email)
                .then(() => alert("E-Mail zum Zur√ºcksetzen des Passworts wurde gesendet."))
                .catch(handleAuthError);
        }
    }

    function handleAuthError(error) {
        const errorElement = document.getElementById('authError');
        let message = "Ein unbekannter Fehler ist aufgetreten.";
        switch (error.code) {
            case 'auth/email-already-in-use': message = "Diese E-Mail-Adresse wird bereits verwendet."; break;
            case 'auth/weak-password': message = "Das Passwort ist zu schwach (mind. 6 Zeichen)."; break;
            case 'auth/user-not-found': message = "Kein Account mit dieser E-Mail-Adresse gefunden."; break;
            case 'auth/wrong-password': message = "Falsches Passwort."; break;
            case 'auth/invalid-email': message = "Ung√ºltige E-Mail-Adresse."; break;
        }
        errorElement.textContent = message;
    }
    
    function setupAuthForms() {
        document.getElementById('loginForm')?.addEventListener('submit', handleLogin);
        document.getElementById('registerForm')?.addEventListener('submit', handleRegistration);
        
        const authToggle = document.getElementById('authToggle');
        authToggle?.addEventListener('click', (e) => {
            e.preventDefault();
            const loginForm = document.getElementById('loginForm');
            const registerForm = document.getElementById('registerForm');
            if (loginForm.classList.contains('hidden')) {
                loginForm.classList.remove('hidden');
                registerForm.classList.add('hidden');
                authToggle.textContent = 'Noch kein Account? Jetzt registrieren';
            } else {
                loginForm.classList.add('hidden');
                registerForm.classList.remove('hidden');
                authToggle.textContent = 'Bereits einen Account? Anmelden';
            }
        });
    }
    // Call setup function once the DOM is ready
    //document.addEventListener('DOMContentLoaded', setupAuthForms);


    function logout() {
        firebase.auth().signOut();
    }
    // ----------------------------------------------------------
    //  1. KONFIGURATION & ZUSTAND
    // ----------------------------------------------------------

    const config = {
      firebase: {
    apiKey: "AIzaSyAu39z49KEJy9zso-etFIScmaFnWw8vhro", // <-- aus Assistent
    authDomain: "eierhuettentour.firebaseapp.com",
    projectId: "eierhuettentour",
    storageBucket: "eierhuettentour.appspot.com",
    messagingSenderId: "348272135205",
    appId: "1:348272135205:web:f39a7d26d927fbf28dc3cc"
  },
      map: {
        defaultCenter: [47.3, 11.4],
        defaultZoom: 13,
        navigationZoom: 18,
      },
      routing: {
        osrmHost: 'https://router.project-osrm.org',
        profile: 'cycling-regular',
        deviationThresholdMeters: 10,
        recalcDebounceMs: 8000,
      },
      noImagePlaceholders: [
        "https://radlmap.net/img/noimg/1.jpg",
        "https://radlmap.net/img/noimg/2.jpg",
        "https://radlmap.net/img/noimg/3.jpg",
      ]
    };

    const appState = {
      isFollowing: true,
      isVoiceOn: true,
      isDarkTheme: false,
      isNavigating: false,
      isSidebarOpen: false,
      navStatsTimer: null,
      liveStats: {
          remainingDist: "-- km",
          eta: "--:--",
          traveledDist: "-- km"
      },
      currentLang: 'de', // Default language
      selectedHuts: [],
      allHuts: [],
      allWarnings: [],
      warnedAbout: new Set(),
      currentRoom: { id: null, guideId: null },
      roomUnsubscribe: null,
      userPositionsUnsubscribe: null,
      visitedStops: new Set(),
      navigationStartTime: null,
      lastBreakTime: null,

      toggleFollow() {
        this.isFollowing = !this.isFollowing;
        uiManager.updateFollowButton();
        uiManager.showToast(i18nManager.getString(this.isFollowing ? 'toast.followOn' : 'toast.followOff'));
        if(this.isFollowing && mapManager.userMarker) {
            mapManager.map.flyTo(mapManager.userMarker.getLatLng(), config.map.navigationZoom);
        }
      },
      toggleVoice() {
        this.isVoiceOn = !this.isVoiceOn;
        uiManager.updateVoiceButton();
        uiManager.showToast(i18nManager.getString(this.isVoiceOn ? 'toast.voiceOn' : 'toast.voiceOff'));
      },
    };
    // ----------------------------------------------------------
    //  2. i18n MANAGER
    // ----------------------------------------------------------
    const i18nManager = {
        translations: {
            de: { /* German translations - see previous version */
              "navstats.popupTitle": "Live-Statistiken",
              "navstats.remaining": "Verbleibend",
"navstats.eta": "Ankunft",
"navstats.traveled": "Gefahren",

              "toast.stopReached": "Stopp {stopName} erreicht!",
"toast.stopReached.speak": "Ziel {stopName} erreicht. N√§chster Stopp: {nextStopName}.",
              "popup.hut.premiumInfo": "Premium Info",
"popup.hut.website": "Webseite", // NEU
"popup.hut.phone": "Telefon",   // NEU
"popup.hut.email": "E-Mail",      // NEU
"popup.hut.instagram": "Instagram", // NEU
"popup.hut.facebook": "Facebook",   // NEU
"popup.hut.tiktok": "TikTok",     // NEU
"popup.hut.addBtn": "Zur Tour hinzuf√ºgen",
                "popup.weatherTitle": "Wettervorschau üå¶Ô∏è", // (Falls du den von vorhin nutzt)
                "chart.elevation": "H√∂he (m)", // (Falls du den von vorhin nutzt)
                "nav.in_meters": "In {meters} Metern {instruction}",
                "nav.now": "Jetzt {instruction}",
                "nav.arrive": "Sie haben Ihr Ziel erreicht",
                "nav.continue": "Weiter geradeaus",
                "nav.depart": "Starten Sie",
                "app.title": "RadlMap Navigation üö≤ (Smarter)",
                "loader.text": "Karte wird geladen...",
                "general.offline": "OFFLINE",
                "general.save": "Speichern",
                "general.cancel": "Abbrechen",
                "general.report": "Melden",
                "general.loading": "Lade...",
                "dashboard.title": "Dashboard",
                "tabs.tour": "Tour",
                "tabs.room": "Raum",
                "tabs.profile": "Profil",
                "tabs.stats": "Statistik",
                "tabs.setup": "Setup",
                "tour.aiTitle": "‚ú® KI Tour-Planer",
                "tour.aiDesc": "L√§sst deine Vorlieben & Wetter einflie√üen!",
                "tour.difficulty.easy": "Leicht",
                "tour.difficulty.medium": "Mittel",
                "tour.difficulty.hard": "Anspruchsvoll",
                "tour.aiSuggestBtn": "Vorschlagen",
                "tour.aiSuggestBtn.loading": "Denke...",
                "tour.stopsTitle": "üìã Ausgew√§hlte Stopps",
                "tour.stopsDesc": "Reihenfolge per Drag & Drop √§ndern.",
                "tour.stopsEmpty": "Noch keine Stopps ausgew√§hlt. Klicke auf der Karte auf eine H√ºtte oder lass dir eine Tour vorschlagen.",
                "tour.stats": "Tour: {dist} km, ca. {time} min",
                "tour.stats.addMore": "F√ºge einen weiteren Stopp f√ºr eine Route hinzu.",
                "tour.aiSummaryBtn": "‚ú® Tour-Zusammenfassung",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "üë• Raum-Verwaltung",
                "room.inRoom": "Du bist im Raum:",
                "room.guide.isGuide": "Du bist der Guide.",
                "room.guide.isOther": "Guide: {name}",
                "room.guide.noGuide": "Niemand f√ºhrt die Tour.",
                "room.becomeGuide": "Guide werden",
                "room.leaveGuide": "Guide-Rolle abgeben",
                "room.guidedTourActive": "Eine gef√ºhrte Tour ist aktiv.",
                "room.leaveBtn": "Raum verlassen",
                "room.activeUsers": "Aktive Nutzer im Raum:",
                "room.noActiveUsers": "Keine anderen Nutzer aktiv.",
                "room.roomIdPlaceholderJoin": "Raum-ID eingeben",
                "room.joinBtnSimple": "Beitreten",
                "room.joinHint": "Gib eine bestehende Raum-ID ein, um beizutreten, oder erstelle einen neuen Raum √ºber den Einladungslink.",
                "room.copyInviteLink": "Einladungslink kopieren",
                "profile.title": "üë§ Mein Profil",
                "profile.nameLabel": "Dein Name",
                "profile.namePlaceholder": "Dein Anzeigename",
                "profile.sosBtn": "SOS Notruf",
                "stats.title": "üìä Meine Statistiken",
                "stats.desc": "Hier sind deine gespeicherten Touren.",
                "stats.loading": "Lade Statistiken...",
                "stats.empty": "Du hast noch keine Touren abgeschlossen.",
                "stats.tourCard.stops": "Stopps",
                "setup.title": "‚öôÔ∏è Einstellungen",
                "setup.intensityLabel": "Bevorzugte Intensit√§t",
                "setup.intensity.flat": "Eher flach",
                "setup.intensity.hilly": "H√ºgelig",
                "setup.intensity.climbs": "Anspruchsvolle Anstiege",
                "setup.typeLabel": "Bevorzugter Tour-Typ",
                "setup.type.nature": "Naturfokussiert",
                "setup.type.culinary": "Kulinarisch",
                "setup.type.culture": "Kulturelle Sehensw√ºrdigkeiten",
                "setup.languageLabel": "üó£Ô∏è App-Sprache",
                "setup.privacyLink": "Datenschutz & Impressum",
                "toolbar.start": "Start",
                "toolbar.stop": "Stop",
                "warning.title": "Gefahr an dieser Stelle melden",
                "warning.typeLabel": "Art der Gefahr",
                "warning.type.pothole": "Schlagloch",
                "warning.type.obstacle": "Hindernis",
                "warning.type.crossing": "Gef√§hrliche Kreuzung",
                "warning.type.other": "Sonstiges",
                "warning.descLabel": "Kurze Beschreibung (optional)",
                "warning.descPlaceholder": "z.B. Tiefe Spurrille",
                "toast.followOn": "Follow-Modus aktiviert",
                "toast.followOff": "Follow-Modus pausiert",
                "toast.voiceOn": "Sprachansagen aktiviert",
                "toast.voiceOff": "Sprachansagen deaktiviert",
                "toast.apiKeyWarning": "KI-Funktion fehlgeschlagen: API-Schl√ºssel nicht konfiguriert.",
                "toast.geminiError": "Ein Fehler mit der KI-Funktion ist aufgetreten.",
                "toast.offlineAI": "Offline. KI-Funktionen nicht verf√ºgbar.",
                "toast.routeError": "Route konnte nicht berechnet werden.",
                "toast.allStopsReached": "üèÜ Alle Stopps erreicht!",
                "toast.allStopsReached.speak": "Herzlichen Gl√ºckwunsch, du hast alle Ziele erreicht!",
                "toast.routeDeviation": "Route verlassen, neue Route wird berechnet...",
                "toast.routeUpdating": "Route wird aktualisiert...",
                "toast.previewLoading": "Routenvorschau wird berechnet...",
                "toast.navStarting": "Navigation wird gestartet...",
                "toast.navStarted": "Navigation gestartet!",
                "toast.navStopped": "Navigation beendet.",
                "toast.noStops": "Bitte w√§hle zuerst mindestens einen Stopp.",
                "toast.guideOnly": "Nur der Guide kann dies tun.",
                "toast.guideExists": "Es gibt bereits einen Guide.",
                "toast.roomJoined": "Raum {id} beigetreten.",
                "toast.roomLeft": "Raum verlassen.",
                "toast.roomTourUpdated": "Tour im Raum wurde aktualisiert!",
                "toast.nameSaved": "Name gespeichert!",
                "toast.sosConfirm": "Sicher, dass du einen SOS-Notruf per WhatsApp senden m√∂chtest?",
                "toast.warningReported": "Gefahr gemeldet!",
                "toast.hutsLoadingError": "H√ºtten konnten nicht geladen werden. Versuche Offline-Daten...",
                "toast.offlineHutsLoaded": "Offline-H√ºtten geladen.",
                "toast.offlineHutsNotFound": "Keine Offline-H√ºtten gefunden.",
                "toast.offlineRouteLoaded": "Zuletzt geplante Route (offline) geladen.",
                "toast.offlineRouteError": "Fehler beim Laden der Offline-Route.",
                "toast.offlineElevationError": "Offline. H√∂henprofil kann nicht geladen werden.",
                "toast.elevationError": "H√∂henprofil konnte nicht geladen werden.",
                "toast.smartBreak": "Du f√§hrst schon seit einer Stunde. Zeit f√ºr eine kleine Pause?",
                "toast.hutsNotLoaded": "H√ºtten werden noch geladen. Bitte kurz warten.",
                "toast.inviteLinkCopied": "Einladungslink in die Zwischenablage kopiert!",
                "toast.roomEnterId": "Bitte gib eine Raum-ID ein, um beizutreten.",
                "toast.roomRejoin": "M√∂chtest du dem Raum \"{id}\" wieder beitreten?",
                "popup.aiSuggestionTitle": "KI-Vorschlag: {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>Die Stopps wurden deiner Tour hinzugef√ºgt.</p>",
                "popup.aiSummaryTitle": "‚ú® Deine Tour-Zusammenfassung",
                "popup.hut.loading": "Lade...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "√ñffnungszeiten",
                "popup.hut.openingHours.always": "Immer ge√∂ffnet ‚úÖ",
                "popup.hut.openingHours.unknown": "Keine Angabe",
                "popup.hut.animals": "Tiere",
                "popup.hut.animals.none": "Keine",
                "popup.hut.power": "Strom",
                "popup.hut.power.unknown": "k.A.",
                "popup.hut.seats": "Pl√§tze",
                "popup.hut.seats.unknown": "k.A.",
                "popup.hut.premiumInfo": "Premium Info",
                "popup.hut.addBtn": "Zur Tour hinzuf√ºgen",
                "popup.hut.removeBtn": "Von Tour entfernen"
            },
            en: { /* English translations - see previous version */
              "navstats.popupTitle": "Live Statistics",
              "navstats.remaining": "Remaining",
"navstats.eta": "Arrival",
"navstats.traveled": "Traveled",
              "toast.stopReached": "Stop {stopName} reached!",
"toast.stopReached.speak": "Destination {stopName} reached. Next stop: {nextStopName}.",
              "popup.hut.premiumInfo": "Premium Info",
"popup.hut.website": "Website", // NEU
"popup.hut.phone": "Phone",     // NEU
"popup.hut.email": "E-Mail",    // NEU
"popup.hut.instagram": "Instagram", // NEU
"popup.hut.facebook": "Facebook",   // NEU
"popup.hut.tiktok": "TikTok",     // NEU
"popup.hut.addBtn": "Add to Tour",
                "popup.weatherTitle": "Weather Forecast üå¶Ô∏è",
                "chart.elevation": "Elevation (m)",
                "nav.in_meters": "In {meters} meters, {instruction}",
                "nav.now": "Now, {instruction}",
                "nav.arrive": "You have reached your destination",
                "nav.continue": "Continue straight",
                "nav.depart": "Depart",
                "app.title": "RadlMap Navigation üö≤ (Smarter)",
                "loader.text": "Loading map...",
                "general.offline": "OFFLINE",
                "general.save": "Save",
                "general.cancel": "Cancel",
                "general.report": "Report",
                "general.loading": "Loading...",
                "dashboard.title": "Dashboard",
                "tabs.tour": "Tour",
                "tabs.room": "Room",
                "tabs.profile": "Profile",
                "tabs.stats": "Statistics",
                "tabs.setup": "Setup",
                "tour.aiTitle": "‚ú® AI Tour Planner",
                "tour.aiDesc": "Uses your preferences & the weather!",
                "tour.difficulty.easy": "Easy",
                "tour.difficulty.medium": "Medium",
                "tour.difficulty.hard": "Challenging",
                "tour.aiSuggestBtn": "Suggest",
                "tour.aiSuggestBtn.loading": "Thinking...",
                "tour.stopsTitle": "üìã Selected Stops",
                "tour.stopsDesc": "Change order via Drag & Drop.",
                "tour.stopsEmpty": "No stops selected yet. Click a hut on the map or let the AI suggest a tour.",
                "tour.stats": "Tour: {dist} km, approx. {time} min",
                "tour.stats.addMore": "Add another stop to plan a route.",
                "tour.aiSummaryBtn": "‚ú® Tour Summary",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "üë• Room Management",
                "room.inRoom": "You are in room:",
                "room.guide.isGuide": "You are the guide.",
                "room.guide.isOther": "Guide: {name}",
                "room.guide.noGuide": "Nobody is guiding this tour.",
                "room.becomeGuide": "Become Guide",
                "room.leaveGuide": "Resign as Guide",
                "room.guidedTourActive": "A guided tour is active.",
                "room.leaveBtn": "Leave Room",
                "room.activeUsers": "Active users in room:",
                "room.noActiveUsers": "No other users active.",
                "room.roomIdPlaceholderJoin": "Enter Room ID",
                "room.joinBtnSimple": "Join",
                "room.joinHint": "Enter an existing Room ID to join, or create a new room via the invite link.",
                "room.copyInviteLink": "Copy Invite Link",
                "profile.title": "üë§ My Profile",
                "profile.nameLabel": "Your Name",
                "profile.namePlaceholder": "Your display name",
                "profile.sosBtn": "SOS Emergency Call",
                "stats.title": "üìä My Statistics",
                "stats.desc": "Here are your saved tours.",
                "stats.loading": "Loading statistics...",
                "stats.empty": "You haven't completed any tours yet.",
                "stats.tourCard.stops": "Stops",
                "setup.title": "‚öôÔ∏è Settings",
                "setup.intensityLabel": "Preferred Intensity",
                "setup.intensity.flat": "Rather flat",
                "setup.intensity.hilly": "Hilly",
                "setup.intensity.climbs": "Challenging climbs",
                "setup.typeLabel": "Preferred Tour Type",
                "setup.type.nature": "Nature-focused",
                "setup.type.culinary": "Culinary",
                "setup.type.culture": "Cultural sights",
                "setup.languageLabel": "üó£Ô∏è App Language",
                "setup.privacyLink": "Privacy & Legal",
                "toolbar.start": "Start",
                "toolbar.stop": "Stop",
                "warning.title": "Report Hazard at this Location",
                "warning.typeLabel": "Type of Hazard",
                "warning.type.pothole": "Pothole",
                "warning.type.obstacle": "Obstacle",
                "warning.type.crossing": "Dangerous Crossing",
                "warning.type.other": "Other",
                "warning.descLabel": "Short Description (optional)",
                "warning.descPlaceholder": "e.g., Deep rut",
                "toast.followOn": "Follow-mode activated",
                "toast.followOff": "Follow-mode paused",
                "toast.voiceOn": "Voice guidance activated",
                "toast.voiceOff": "Voice guidance deactivated",
                "toast.apiKeyWarning": "AI function failed: API key not configured.",
                "toast.geminiError": "An error occurred with the AI function.",
                "toast.offlineAI": "Offline. AI functions not available.",
                "toast.routeError": "Could not calculate route.",
                "toast.allStopsReached": "üèÜ All stops reached!",
                "toast.allStopsReached.speak": "Congratulations, you have reached all destinations!",
                "toast.routeDeviation": "Off route, recalculating...",
                "toast.routeUpdating": "Updating route...",
                "toast.previewLoading": "Calculating route preview...",
                "toast.navStarting": "Starting navigation...",
                "toast.navStarted": "Navigation started!",
                "toast.navStopped": "Navigation stopped.",
                "toast.noStops": "Please select at least one stop first.",
                "toast.guideOnly": "Only the guide can do this.",
                "toast.guideExists": "There is already a guide.",
                "toast.roomJoined": "Joined room {id}.",
                "toast.roomLeft": "Left room.",
                "toast.roomTourUpdated": "Tour in room has been updated!",
                "toast.nameSaved": "Name saved!",
                "toast.sosConfirm": "Are you sure you want to send an SOS emergency call via WhatsApp?",
                "toast.warningReported": "Hazard reported!",
                "toast.hutsLoadingError": "Could not load huts.Trying offline data...",
                "toast.offlineHutsLoaded": "Offline huts loaded.",
                "toast.offlineHutsNotFound": "No offline huts found.",
                "toast.offlineRouteLoaded": "Last planned route (offline) loaded.",
                "toast.offlineRouteError": "Error loading offline route.",
                "toast.offlineElevationError": "Offline. Elevation profile cannot be loaded.",
                "toast.elevationError": "Could not load elevation profile.",
                "toast.smartBreak": "You've been riding for an hour. Time for a short break?",
                "toast.hutsNotLoaded": "Huts are still loading. Please wait a moment.",
                "toast.inviteLinkCopied": "Invite link copied to clipboard!",
                "toast.roomEnterId": "Please enter a Room ID to join.",
                "toast.roomRejoin": "Do you want to rejoin room \"{id}\"?",
                "popup.aiSuggestionTitle": "AI Suggestion: {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>The stops have been added to your tour.</p>",
                "popup.aiSummaryTitle": "‚ú® Your Tour Summary",
                "popup.hut.loading": "Loading...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "Opening Hours",
                "popup.hut.openingHours.always": "Always open ‚úÖ",
                "popup.hut.openingHours.unknown": "No information",
                "popup.hut.animals": "Animals",
                "popup.hut.animals.none": "None",
                "popup.hut.power": "Power",
                "popup.hut.power.unknown": "n/a",
                "popup.hut.seats": "Seats",
                "popup.hut.seats.unknown": "n/a",
                "popup.hut.premiumInfo": "Premium Info",
                "popup.hut.addBtn": "Add to Tour",
                "popup.hut.removeBtn": "Remove from Tour"
            },
            es: { /* Spanish translations - see previous version */
              "navstats.popupTitle": "Estad√≠sticas en Vivo",
              "navstats.remaining": "Restante",
"navstats.eta": "Llegada",
"navstats.traveled": "Recorrido",
              "toast.stopReached": "¬°Parada {stopName} alcanzada!",
"toast.stopReached.speak": "Destino {stopName} alcanzado. Pr√≥xima parada: {nextStopName}.",
              "popup.hut.premiumInfo": "Info Premium",
"popup.hut.website": "Sitio Web", // NEU
"popup.hut.phone": "Tel√©fono",    // NEU
"popup.hut.email": "E-Mail",    // NEU
"popup.hut.instagram": "Instagram", // NEU
"popup.hut.facebook": "Facebook",   // NEU
"popup.hut.tiktok": "TikTok",     // NEU
"popup.hut.addBtn": "A√±adir a Ruta",
                "popup.weatherTitle": "Pron√≥stico del Tiempo üå¶Ô∏è",
                "app.title": "RadlMap Navegaci√≥n üö≤ (Smarter)",
                "loader.text": "Cargando mapa...",
                "general.offline": "SIN CONEXI√ìN",
                "general.save": "Guardar",
                "general.cancel": "Cancelar",
                "general.report": "Informar",
                "general.loading": "Cargando...",
                "dashboard.title": "Panel",
                "tabs.tour": "Ruta",
                "tabs.room": "Sala",
                "tabs.profile": "Perfil",
                "tabs.stats": "Estad√≠sticas",
                "tabs.setup": "Ajustes",
                "tour.aiTitle": "‚ú® Planificador IA de Rutas",
                "tour.aiDesc": "¬°Usa tus preferencias y el tiempo!",
                "tour.difficulty.easy": "F√°cil",
                "tour.difficulty.medium": "Medio",
                "tour.difficulty.hard": "Dif√≠cil",
                "tour.aiSuggestBtn": "Sugerir",
                "tour.aiSuggestBtn.loading": "Pensando...",
                "tour.stopsTitle": "üìã Paradas Seleccionadas",
                "tour.stopsDesc": "Cambiar orden arrastrando.",
                "tour.stopsEmpty": "No hay paradas seleccionadas. Haz clic en una caba√±a o deja que la IA sugiera una ruta.",
                "tour.stats": "Ruta: {dist} km, aprox. {time} min",
                "tour.stats.addMore": "A√±ade otra parada para planificar una ruta.",
                "tour.aiSummaryBtn": "‚ú® Resumen de la Ruta",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "üë• Gesti√≥n de Sala",
                "room.inRoom": "Est√°s en la sala:",
                "room.guide.isGuide": "T√∫ eres el gu√≠a.",
                "room.guide.isOther": "Gu√≠a: {name}",
                "room.guide.noGuide": "Nadie est√° guiando esta ruta.",
                "room.becomeGuide": "Ser Gu√≠a",
                "room.leaveGuide": "Dejar de ser Gu√≠a",
                "room.guidedTourActive": "Una ruta guiada est√° activa.",
                "room.leaveBtn": "Salir de la Sala",
                "room.activeUsers": "Usuarios activos en la sala:",
                "room.noActiveUsers": "No hay otros usuarios activos.",
                "room.roomIdPlaceholderJoin": "Introduce ID de Sala",
                "room.joinBtnSimple": "Unirse",
                "room.joinHint": "Introduce un ID de Sala existente para unirte, o crea una nueva sala mediante el enlace de invitaci√≥n.",
                "room.copyInviteLink": "Copiar Enlace de Invitaci√≥n",
                "profile.title": "üë§ Mi Perfil",
                "profile.nameLabel": "Tu Nombre",
                "profile.namePlaceholder": "Tu nombre de usuario",
                "profile.sosBtn": "Llamada SOS",
                "stats.title": "üìä Mis Estad√≠sticas",
                "stats.desc": "Aqu√≠ est√°n tus rutas guardadas.",
                "stats.loading": "Cargando estad√≠sticas...",
                "stats.empty": "A√∫n no has completado ninguna ruta.",
                "stats.tourCard.stops": "Paradas",
                "setup.title": "‚öôÔ∏è Ajustes",
                "setup.intensityLabel": "Intensidad Preferida",
                "setup.intensity.flat": "Bastante plano",
                "setup.intensity.hilly": "Monta√±oso",
                "setup.intensity.climbs": "Subidas exigentes",
                "setup.typeLabel": "Tipo de Ruta Preferido",
                "setup.type.nature": "Enfocado en la naturaleza",
                "setup.type.culinary": "Culinario",
                "setup.type.culture": "Vistas culturales",
                "setup.languageLabel": "üó£Ô∏è Idioma de la App",
                "setup.privacyLink": "Privacidad y Legal",
                "toolbar.start": "Empezar",
                "toolbar.stop": "Parar",
                "warning.title": "Informar de un Peligro Aqu√≠",
                "warning.typeLabel": "Tipo de Peligro",
                "warning.type.pothole": "Bache",
                "warning.type.obstacle": "Obst√°culo",
                "warning.type.crossing": "Cruce Peligroso",
                "warning.type.other": "Otro",
                "warning.descLabel": "Descripci√≥n Breve (opcional)",
                "warning.descPlaceholder": "p.ej., Surco profundo",
                "toast.followOn": "Modo seguimiento activado",
                "toast.followOff": "Modo seguimiento pausado",
                "toast.voiceOn": "Gu√≠a por voz activada",
                "toast.voiceOff": "Gu√≠a por voz desactivada",
                "toast.apiKeyWarning": "Funci√≥n IA fall√≥: Clave API no configurada.",
                "toast.geminiError": "Ocurri√≥ un error con la funci√≥n IA.",
                "toast.offlineAI": "Sin conexi√≥n. Funciones IA no disponibles.",
                "toast.routeError": "No se pudo calcular la ruta.",
                "toast.allStopsReached": "üèÜ ¬°Todas las paradas alcanzadas!",
                "toast.allStopsReached.speak": "¬°Felicidades, has llegado a todos los destinos!",
                "toast.routeDeviation": "Fuera de ruta, recalculando...",
                "toast.routeUpdating": "Actualizando ruta...",
                "toast.previewLoading": "Calculando vista previa de la ruta...",
                "toast.navStarting": "Iniciando navegaci√≥n...",
                "toast.navStarted": "Navegaci√≥n iniciada",
                "toast.navStopped": "Navegaci√≥n detenida",
                "toast.noStops": "Por favor, selecciona al menos una parada.",
                "toast.guideOnly": "Solo el gu√≠a puede hacer esto.",
                "toast.guideExists": "Ya hay un gu√≠a.",
                "toast.roomJoined": "Te uniste a la sala {id}.",
                "toast.roomLeft": "Saliste de la sala.",
                "toast.roomTourUpdated": "¬°La ruta en la sala ha sido actualizada!",
                "toast.nameSaved": "¬°Nombre guardado!",
                "toast.sosConfirm": "¬øSeguro que quieres enviar una llamada SOS por WhatsApp?",
                "toast.warningReported": "¬°Peligro informado!",
                "toast.hutsLoadingError": "No se pudieron cargar las caba√±as. Intentando datos sin conexi√≥n...",
                "toast.offlineHutsLoaded": "Caba√±as sin conexi√≥n cargadas.",
                "toast.offlineHutsNotFound": "No se encontraron caba√±as sin conexi√≥n.",
                "toast.offlineRouteLoaded": "√öltima ruta planificada (sin conexi√≥n) cargada.",
                "toast.offlineRouteError": "Error al cargar ruta sin conexi√≥n.",
                "toast.offlineElevationError": "Sin conexi√≥n. No se puede cargar el perfil de elevaci√≥n.",
                "toast.elevationError": "No se pudo cargar el perfil de elevaci√≥n.",
                "toast.smartBreak": "Llevas una hora pedaleando. ¬øHora de un descanso?",
                "toast.hutsNotLoaded": "Las caba√±as a√∫n se est√°n cargando. Espera un momento.",
                "toast.inviteLinkCopied": "¬°Enlace de invitaci√≥n copiado al portapapeles!",
                "toast.roomEnterId": "Por favor, introduce un ID de sala para unirte.",
                "toast.roomRejoin": "¬øQuieres volver a unirte a la sala \"{id}\"?",
                "popup.aiSuggestionTitle": "Sugerencia IA: {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>Las paradas han sido a√±adidas a tu ruta.</p>",
                "popup.aiSummaryTitle": "‚ú® Tu Resumen de Ruta",
                "popup.hut.loading": "Cargando...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "Horario",
                "popup.hut.openingHours.always": "Siempre abierto ‚úÖ",
                "popup.hut.openingHours.unknown": "No disponible",
                "popup.hut.animals": "Animales",
                "popup.hut.animals.none": "No",
                "popup.hut.power": "Electricidad",
                "popup.hut.power.unknown": "n/a",
                "popup.hut.seats": "Asientos",
                "popup.hut.seats.unknown": "n/a",
                "popup.hut.premiumInfo": "Info Premium",
                "popup.hut.addBtn": "A√±adir a Ruta",
                "popup.hut.removeBtn": "Quitar de Ruta"
            },
            fr: { /* French translations - see previous version */
              "navstats.popupTitle": "Statistiques en Direct",
              "navstats.remaining": "Restant",
"navstats.eta": "Arriv√©e",
"navstats.traveled": "Parcouru",
              "toast.stopReached": "Arr√™t {stopName} atteint !",
"toast.stopReached.speak": "Destination {stopName} atteinte. Prochain arr√™t : {nextStopName}.",
              "popup.hut.premiumInfo": "Info Premium",
"popup.hut.website": "Site Web", // NEU
"popup.hut.phone": "T√©l√©phone",  // NEU
"popup.hut.email": "E-Mail",   // NEU
"popup.hut.instagram": "Instagram", // NEU
"popup.hut.facebook": "Facebook",   // NEU
"popup.hut.tiktok": "TikTok",     // NEU
"popup.hut.addBtn": "Ajouter au Tour",
                "popup.weatherTitle": "Pr√©visions M√©t√©o üå¶Ô∏è",
                "app.title": "RadlMap Navigation üö≤ (Smarter)",
                "loader.text": "Chargement de la carte...",
                "general.offline": "HORS LIGNE",
                "general.save": "Enregistrer",
                "general.cancel": "Annuler",
                "general.report": "Signaler",
                "general.loading": "Chargement...",
                "dashboard.title": "Tableau de bord",
                "tabs.tour": "Tour",
                "tabs.room": "Salle",
                "tabs.profile": "Profil",
                "tabs.stats": "Statistiques",
                "tabs.setup": "R√©glages",
                "tour.aiTitle": "‚ú® Planificateur de Tour IA",
                "tour.aiDesc": "Prend en compte vos pr√©f√©rences et la m√©t√©o !",
                "tour.difficulty.easy": "Facile",
                "tour.difficulty.medium": "Moyen",
                "tour.difficulty.hard": "Difficile",
                "tour.aiSuggestBtn": "Sugg√©rer",
                "tour.aiSuggestBtn.loading": "R√©flexion...",
                "tour.stopsTitle": "üìã Arr√™ts S√©lectionn√©s",
                "tour.stopsDesc": "Changer l'ordre par glisser-d√©poser.",
                "tour.stopsEmpty": "Aucun arr√™t s√©lectionn√©. Cliquez sur un refuge ou laissez l'IA sugg√©rer un tour.",
                "tour.stats": "Tour : {dist} km, env. {time} min",
                "tour.stats.addMore": "Ajoutez un autre arr√™t pour planifier un itin√©raire.",
                "tour.aiSummaryBtn": "‚ú® R√©sum√© du Tour",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "üë• Gestion de Salle",
                "room.inRoom": "Vous √™tes dans la salle :",
                "room.guide.isGuide": "Vous √™tes le guide.",
                "room.guide.isOther": "Guide : {name}",
                "room.guide.noGuide": "Personne ne guide ce tour.",
                "room.becomeGuide": "Devenir Guide",
                "room.leaveGuide": "Quitter le r√¥le de Guide",
                "room.guidedTourActive": "Un tour guid√© est actif.",
                "room.leaveBtn": "Quitter la Salle",
                "room.activeUsers": "Utilisateurs actifs :",
                "room.noActiveUsers": "Aucun autre utilisateur actif.",
                "room.roomIdPlaceholderJoin": "Entrer l'ID de la Salle",
                "room.joinBtnSimple": "Rejoindre",
                "room.joinHint": "Entrez un ID de salle existant pour rejoindre, ou cr√©ez une nouvelle salle via le lien d'invitation.",
                "room.copyInviteLink": "Copier le Lien d'Invitation",
                "profile.title": "üë§ Mon Profil",
                "profile.nameLabel": "Votre Nom",
                "profile.namePlaceholder": "Votre nom d'affichage",
                "profile.sosBtn": "Appel d'Urgence SOS",
                "stats.title": "üìä Mes Statistiques",
                "stats.desc": "Voici vos tours enregistr√©s.",
                "stats.loading": "Chargement des statistiques...",
                "stats.empty": "Vous n'avez pas encore termin√© de tours.",
                "stats.tourCard.stops": "Arr√™ts",
                "setup.title": "‚öôÔ∏è R√©glages",
                "setup.intensityLabel": "Intensit√© Pr√©f√©r√©e",
                "setup.intensity.flat": "Plut√¥t plat",
                "setup.intensity.hilly": "Vallonn√©",
                "setup.intensity.climbs": "Mont√©es exigeantes",
                "setup.typeLabel": "Type de Tour Pr√©f√©r√©",
                "setup.type.nature": "Ax√© sur la nature",
                "setup.type.culinary": "Culinaire",
                "setup.type.culture": "Sites culturels",
                "setup.languageLabel": "üó£Ô∏è Langue de l'App",
                "setup.privacyLink": "Confidentialit√© & Mentions",
                "toolbar.start": "D√©marrer",
                "toolbar.stop": "Arr√™ter",
                "warning.title": "Signaler un Danger Ici",
                "warning.typeLabel": "Type de Danger",
                "warning.type.pothole": "Nid-de-poule",
                "warning.type.obstacle": "Obstacle",
                "warning.type.crossing": "Travers√©e Dangereuse",
                "warning.type.other": "Autre",
                "warning.descLabel": "Description Courte (optionnel)",
                "warning.descPlaceholder": "ex: Orni√®re profonde",
                "toast.followOn": "Mode suivi activ√©",
                "toast.followOff": "Mode suivi en pause",
                "toast.voiceOn": "Guidage vocal activ√©",
                "toast.voiceOff": "Guidage vocal d√©sactiv√©",
                "toast.apiKeyWarning": "Fonction IA √©chou√©e : Cl√© API non configur√©e.",
                "toast.geminiError": "Une erreur est survenue avec la fonction IA.",
                "toast.offlineAI": "Hors ligne. Fonctions IA indisponibles.",
                "toast.routeError": "Impossible de calculer l'itin√©raire.",
                "toast.allStopsReached": "üèÜ Tous les arr√™ts atteints !",
                "toast.allStopsReached.speak": "F√©licitations, vous avez atteint toutes les destinations !",
                "toast.routeDeviation": "Sortie d'itin√©raire, recalcul...",
                "toast.routeUpdating": "Mise √† jour de l'itin√©raire...",
                "toast.previewLoading": "Calcul de l'aper√ßu...",
                "toast.navStarting": "D√©marrage de la navigation...",
                "toast.navStarted": "Navigation d√©marr√©e !",
                "toast.navStopped": "Navigation arr√™t√©e.",
                "toast.noStops": "Veuillez s√©lectionner au moins un arr√™t.",
                "toast.guideOnly": "Seul le guide peut faire cela.",
                "toast.guideExists": "Il y a d√©j√† un guide.",
                "toast.roomJoined": "Salle {id} rejointe.",
                "toast.roomLeft": "Salle quitt√©e.",
                "toast.roomTourUpdated": "Le tour dans la salle a √©t√© mis √† jour !",
                "toast.nameSaved": "Nom enregistr√© !",
                "toast.sosConfirm": "Voulez-vous vraiment envoyer un appel SOS via WhatsApp ?",
                "toast.warningReported": "Danger signal√© !",
                "toast.hutsLoadingError": "Impossible de charger les refuges. Essai donn√©es hors ligne...",
                "toast.offlineHutsLoaded": "Refuges hors ligne charg√©s.",
                "toast.offlineHutsNotFound": "Aucun refuge hors ligne trouv√©.",
                "toast.offlineRouteLoaded": "Dernier itin√©raire (hors ligne) charg√©.",
                "toast.offlineRouteError": "Erreur chargement itin√©raire hors ligne.",
                "toast.offlineElevationError": "Hors ligne. Profil d'√©l√©vation indisponible.",
                "toast.elevationError": "Impossible de charger le profil d'√©l√©vation.",
                "toast.smartBreak": "Vous roulez depuis une heure. C'est l'heure d'une pause ?",
                "toast.hutsNotLoaded": "Chargement des refuges en cours. Veuillez patienter.",
                "toast.inviteLinkCopied": "Lien d'invitation copi√© dans le presse-papiers !",
                "toast.roomEnterId": "Veuillez entrer un ID de salle pour rejoindre.",
                "toast.roomRejoin": "Voulez-vous rejoindre la salle \"{id}\" ?",
                "popup.aiSuggestionTitle": "Suggestion IA : {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>Les arr√™ts ont √©t√© ajout√©s √† votre tour.</p>",
                "popup.aiSummaryTitle": "‚ú® Votre R√©sum√© de Tour",
                "popup.hut.loading": "Chargement...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "Horaires",
                "popup.hut.openingHours.always": "Toujours ouvert ‚úÖ",
                "popup.hut.openingHours.unknown": "Non disponible",
                "popup.hut.animals": "Animaux",
                "popup.hut.animals.none": "Aucun",
                "popup.hut.power": "√âlectricit√©",
                "popup.hut.power.unknown": "n/a",
                "popup.hut.seats": "Places",
                "popup.hut.seats.unknown": "n/a",
                "popup.hut.premiumInfo": "Info Premium",
                "popup.hut.addBtn": "Ajouter au Tour",
                "popup.hut.removeBtn": "Retirer du Tour"
            },
            // NEU: Niederl√§ndische √úbersetzungen
            nl: {
              "navstats.popupTitle": "Live Statistieken",
              "navstats.remaining": "Resterend",
"navstats.eta": "Aankomst",
"navstats.traveled": "Afgelegd",
              "toast.stopReached": "Stop {stopName} bereikt!",
"toast.stopReached.speak": "Bestemming {stopName} bereikt. Volgende stop: {nextStopName}.",
              "popup.hut.premiumInfo": "Premium Info",
"popup.hut.website": "Website", // NEU
"popup.hut.phone": "Telefoon",  // NEU
"popup.hut.email": "E-Mail",    // NEU
"popup.hut.instagram": "Instagram", // NEU
"popup.hut.facebook": "Facebook",   // NEU
"popup.hut.tiktok": "TikTok",     // NEU
"popup.hut.addBtn": "Toevoegen aan Tour",
                "popup.weatherTitle": "Weersverwachting üå¶Ô∏è",
                "app.title": "RadlMap Navigatie üö≤ (Slimmer)",
                "loader.text": "Kaart laden...",
                "general.offline": "OFFLINE",
                "general.save": "Opslaan",
                "general.cancel": "Annuleren",
                "general.report": "Melden",
                "general.loading": "Laden...",
                "dashboard.title": "Dashboard",
                "tabs.tour": "Tour",
                "tabs.room": "Ruimte",
                "tabs.profile": "Profiel",
                "tabs.stats": "Statistieken",
                "tabs.setup": "Instellingen",
                "tour.aiTitle": "‚ú® AI Tourplanner",
                "tour.aiDesc": "Houdt rekening met uw voorkeuren & het weer!",
                "tour.difficulty.easy": "Makkelijk",
                "tour.difficulty.medium": "Gemiddeld",
                "tour.difficulty.hard": "Uitdagend",
                "tour.aiSuggestBtn": "Voorstellen",
                "tour.aiSuggestBtn.loading": "Denken...",
                "tour.stopsTitle": "üìã Geselecteerde Stops",
                "tour.stopsDesc": "Verander de volgorde via Drag & Drop.",
                "tour.stopsEmpty": "Nog geen stops geselecteerd. Klik op een hut op de kaart of laat de AI een tour voorstellen.",
                "tour.stats": "Tour: {dist} km, ca. {time} min",
                "tour.stats.addMore": "Voeg nog een stop toe om een route te plannen.",
                "tour.aiSummaryBtn": "‚ú® Toursamenvatting",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "üë• Ruimtebeheer",
                "room.inRoom": "U bent in ruimte:",
                "room.guide.isGuide": "U bent de gids.",
                "room.guide.isOther": "Gids: {name}",
                "room.guide.noGuide": "Niemand leidt deze tour.",
                "room.becomeGuide": "Gids worden",
                "room.leaveGuide": "Gidsrol opgeven",
                "room.guidedTourActive": "Een begeleide tour is actief.",
                "room.leaveBtn": "Ruimte verlaten",
                "room.activeUsers": "Actieve gebruikers in de ruimte:",
                "room.noActiveUsers": "Geen andere gebruikers actief.",
                "room.roomIdPlaceholderJoin": "Voer ruimte-ID in",
                "room.joinBtnSimple": "Deelnemen",
                "room.joinHint": "Voer een bestaande ruimte-ID in om deel te nemen, of maak een nieuwe ruimte via de uitnodigingslink.",
                "room.copyInviteLink": "Uitnodigingslink kopi√´ren",
                "profile.title": "üë§ Mijn Profiel",
                "profile.nameLabel": "Uw Naam",
                "profile.namePlaceholder": "Uw weergavenaam",
                "profile.sosBtn": "SOS Noodoproep",
                "stats.title": "üìä Mijn Statistieken",
                "stats.desc": "Hier zijn uw opgeslagen tours.",
                "stats.loading": "Statistieken laden...",
                "stats.empty": "U heeft nog geen tours voltooid.",
                "stats.tourCard.stops": "Stops",
                "setup.title": "‚öôÔ∏è Instellingen",
                "setup.intensityLabel": "Voorkeursintensiteit",
                "setup.intensity.flat": "Vrij vlak",
                "setup.intensity.hilly": "Heuvelachtig",
                "setup.intensity.climbs": "Uitdagende beklimmingen",
                "setup.typeLabel": "Voorkeurstype Tour",
                "setup.type.nature": "Natuurgericht",
                "setup.type.culinary": "Culinair",
                "setup.type.culture": "Culturele bezienswaardigheden",
                "setup.languageLabel": "üó£Ô∏è App-taal",
                "setup.privacyLink": "Privacy & Juridisch",
                "toolbar.start": "Start",
                "toolbar.stop": "Stop",
                "warning.title": "Gevaar melden op deze locatie",
                "warning.typeLabel": "Type Gevaar",
                "warning.type.pothole": "Gat in de weg",
                "warning.type.obstacle": "Obstakel",
                "warning.type.crossing": "Gevaarlijke oversteek",
                "warning.type.other": "Anders",
                "warning.descLabel": "Korte Beschrijving (optioneel)",
                "warning.descPlaceholder": "bijv. Diepe sleuf",
                "toast.followOn": "Volgmodus geactiveerd",
                "toast.followOff": "Volgmodus gepauzeerd",
                "toast.voiceOn": "Stembegeleiding geactiveerd",
                "toast.voiceOff": "Stembegeleiding gedeactiveerd",
                "toast.apiKeyWarning": "AI-functie mislukt: API-sleutel niet geconfigureerd.",
                "toast.geminiError": "Er is een fout opgetreden bij de AI-functie.",
                "toast.offlineAI": "Offline. AI-functies niet beschikbaar.",
                "toast.routeError": "Kon route niet berekenen.",
                "toast.allStopsReached": "üèÜ Alle stops bereikt!",
                "toast.allStopsReached.speak": "Gefeliciteerd, u heeft alle bestemmingen bereikt!",
                "toast.routeDeviation": "Van route af, herberekenen...",
                "toast.routeUpdating": "Route bijwerken...",
                "toast.previewLoading": "Routevoorbeeld berekenen...",
                "toast.navStarting": "Navigatie starten...",
                "toast.navStarted": "Navigatie gestart!",
                "toast.navStopped": "Navigatie gestopt.",
                "toast.noStops": "Selecteer eerst minimaal √©√©n stop.",
                "toast.guideOnly": "Alleen de gids kan dit doen.",
                "toast.guideExists": "Er is al een gids.",
                "toast.roomJoined": "Deelgenomen aan ruimte {id}.",
                "toast.roomLeft": "Ruimte verlaten.",
                "toast.roomTourUpdated": "Tour in ruimte is bijgewerkt!",
                "toast.nameSaved": "Naam opgeslagen!",
                "toast.sosConfirm": "Weet u zeker dat u een SOS-noodoproep via WhatsApp wilt sturen?",
                "toast.warningReported": "Gevaar gemeld!",
                "toast.hutsLoadingError": "Kon hutten niet laden. Offline gegevens proberen...",
                "toast.offlineHutsLoaded": "Offline hutten geladen.",
                "toast.offlineHutsNotFound": "Geen offline hutten gevonden.",
                "toast.offlineRouteLoaded": "Laatst geplande route (offline) geladen.",
                "toast.offlineRouteError": "Fout bij laden offline route.",
                "toast.offlineElevationError": "Offline. Hoogteprofiel kan niet worden geladen.",
                "toast.elevationError": "Kon hoogteprofiel niet laden.",
                "toast.smartBreak": "U fietst al een uur. Tijd voor een korte pauze?",
                "toast.hutsNotLoaded": "Hutten worden nog geladen. Even geduld a.u.b.",
                "toast.inviteLinkCopied": "Uitnodigingslink naar klembord gekopieerd!",
                "toast.roomEnterId": "Voer a.u.b. een ruimte-ID in om deel te nemen.",
                "toast.roomRejoin": "Wilt u opnieuw deelnemen aan ruimte \"{id}\"?",
                "popup.aiSuggestionTitle": "AI Suggestie: {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>De stops zijn aan uw tour toegevoegd.</p>",
                "popup.aiSummaryTitle": "‚ú® Uw Toursamenvatting",
                "popup.hut.loading": "Laden...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "Openingstijden",
                "popup.hut.openingHours.always": "Altijd open ‚úÖ",
                "popup.hut.openingHours.unknown": "Geen informatie",
                "popup.hut.animals": "Dieren",
                "popup.hut.animals.none": "Geen",
                "popup.hut.power": "Stroom",
                "popup.hut.power.unknown": "n.v.t.",
                "popup.hut.seats": "Zitplaatsen",
                "popup.hut.seats.unknown": "n.v.t.",
                "popup.hut.premiumInfo": "Premium Info",
                "popup.hut.addBtn": "Toevoegen aan Tour",
                "popup.hut.removeBtn": "Verwijderen uit Tour"
            }
        },

        currentLang: 'de',

        init() {
            const select = document.getElementById('appLangSelect');
            if (!select) return;

            // Sprachen f√ºllen
            const languages = {
                'de': 'Deutsch',
                'en': 'English',
                'es': 'Espa√±ol',
                'fr': 'Fran√ßais',
                'nl': 'Nederlands', // NEU
            };
            select.innerHTML = '';
            for (const [code, name] of Object.entries(languages)) {
                const option = document.createElement('option');
                option.value = code;
                option.textContent = name;
                select.appendChild(option);
            }

            const savedLang = localStorage.getItem('appLang') || 'de';
            select.value = savedLang;
            this.setLanguage(savedLang);

            select.addEventListener('change', (e) => {
                this.setLanguage(e.target.value);
            });
        },

                setLanguage(lang) {
            if (!this.translations[lang]) lang = 'de'; // Fallback
            this.currentLang = lang;
            appState.currentLang = lang;
            localStorage.setItem('appLang', lang);
            document.documentElement.lang = lang;

            // Update alle data-i18n Elemente
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.dataset.i18n;
                const translation = this.getString(key);
                if (translation && translation !== key) {
                     if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT') {
                         // Placeholder special handling needed?
                    } else if (el.hasAttribute('data-i18n-placeholder')) {
                         el.placeholder = translation; // Apply to placeholder if specified
                    }
                    else {
                        el.textContent = translation;
                    }
                }
            });

             // Update alle data-i18n-placeholder Elemente
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.dataset.i18nPlaceholder;
                const translation = this.getString(key);
                 if (translation && translation !== key) {
                     el.placeholder = translation;
                 }
            });

            // Aktualisiere dynamische Texte
            // uiManager.updateSelectedList(); // <-- AUSKOMMENTIERT
            // uiManager.updateRoomUI(appState.currentRoom, []); // <-- AUSKOMMENTIERT
            // Optional: Wetter/Geschwindigkeit etc. neu rendern, falls diese Strings enthalten
        },

        getString(key, replacements = {}) {
            let str = this.translations[this.currentLang]?.[key] || this.translations['de']?.[key]; // Fallback auf Deutsch
            if (!str) {
                console.warn(`i18n key not found: ${key} for lang ${this.currentLang}`);
                return key; // Key als Fallback
            }

            for (const [placeholder, value] of Object.entries(replacements)) {
                str = str.replace(`{${placeholder}}`, value);
            }
            return str;
        }
    };


    // ----------------------------------------------------------
    //  3. UI MANAGER
    // ----------------------------------------------------------
    const uiManager = {
        elevationChartInstance: null,

        // Hie√ü vorher init()
        initCore() {
            this.initTheme();
            // i18n MUSS hier sein f√ºr den Ladebildschirm-Text
            i18nManager.init(); 

            window.addEventListener('offline', () => {
                document.getElementById('offline-indicator').classList.remove('hidden');
                uiManager.showToast(i18nManager.getString("toast.offlineAI"));
            });
            window.addEventListener('online', () => {
                document.getElementById('offline-indicator').classList.add('hidden');
            });
            if (!navigator.onLine) {
                 document.getElementById('offline-indicator').classList.remove('hidden');
            }
        },

        // NEU: Diese Funktion initialisiert die UI der Haupt-App,
        // NACHDEM der Login erfolgreich war.
        initMainAppUI() {
            this.initTabs();
            this.updateVoiceButton();
            this.updateFollowButton();
            ttsManager.init(); // H√§ngt von appLangSelect ab
        },

        toggleSidebar() {
            appState.isSidebarOpen = !appState.isSidebarOpen;
            document.getElementById('sidebar-panel').classList.toggle('open', appState.isSidebarOpen);
            if(mapManager.map) {
                setTimeout(() => mapManager.map.invalidateSize(), 400);
            }
        },


        

        initTheme() {
            const savedTheme = localStorage.getItem('theme');
            appState.isDarkTheme = savedTheme === 'dark';
            document.body.classList.toggle('dark', appState.isDarkTheme);
            this.updateThemeButton();
        },

        toggleTheme() {
            appState.isDarkTheme = !appState.isDarkTheme;
            localStorage.setItem('theme', appState.isDarkTheme ? 'dark' : 'light');
            document.body.classList.toggle('dark', appState.isDarkTheme);
            this.updateThemeButton();
            if(mapManager.tileLayer) {
                mapManager.map.removeLayer(mapManager.tileLayer);
                mapManager.addTileLayer();
            }
            if(this.elevationChartInstance) {
                this.elevationChartInstance.destroy();
                this.elevationChartInstance = null;
                routeManager.recalculatePreviewRoute();
            }
        },

        updateThemeButton() {
            const icon = appState.isDarkTheme ? '‚òÄÔ∏è' : 'üåô';
            document.getElementById('theme-toggle-btn').textContent = icon;
        },

        updateVoiceButton() {
            const icon = appState.isVoiceOn
                ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`
                : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v-2a7 7 0 0 0-11.21-.83"></path></svg>`;
            document.getElementById('voice-toggle').innerHTML = icon;
        },

        updateFollowButton() {
            const icon = appState.isFollowing
                ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Z M12 2.25a.75.75 0 0 1 .75.75v.31A9.743 9.743 0 0 1 21.435 12a.75.75 0 0 1-1.493.102 8.243 8.243 0 0 0-7.942-7.942A.75.75 0 0 1 12 2.25Z"/></svg>`
                : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>`;
            document.getElementById('follow-toggle').innerHTML = icon;
        },

        setLoading(isLoading, text = i18nManager.getString('general.loading')) {
            const loader = document.getElementById('loader');
            if (isLoading) {
                loader.querySelector('p').textContent = text;
                loader.style.display = 'flex';
                loader.style.opacity = '1';
            } else {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }
        },

        showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        },

        updateSelectedList() {
            const listEl = document.getElementById('selectedList');
            if (appState.selectedHuts.length === 0) {
                listEl.innerHTML = `<li class="text-sm text-gray-500">${i18nManager.getString('tour.stopsEmpty')}</li>`;
                document.getElementById('tour-actions').classList.add('hidden');
                return;
            }

            listEl.innerHTML = appState.selectedHuts.map((hut, index) => `
                <li draggable="true" ondragstart="dragAndDrop.start(event, ${index})" ondrop="dragAndDrop.drop(event, ${index})" ondragover="event.preventDefault()" class="flex items-center justify-between p-2 rounded-lg bg-gray-100 dark:bg-gray-700 cursor-grab" data-index="${index}">
                    <span class="font-medium text-sm">#${index + 1}: ${hut.name}</span>
                    <button onclick="routeManager.removeSelected(${index})" class="p-1 text-red-500 hover:text-red-700">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </li>
            `).join('');

            this.updateChallengeStatus();
            document.getElementById('tour-actions').classList.toggle('hidden', appState.selectedHuts.length < 1);
        },

        updateChallengeStatus() {
            const statusEl = document.getElementById('challenge-status');
            if (appState.selectedHuts.length > 0) {
                 // Using a generic structure that works across languages
                 statusEl.textContent = `üèÜ ${i18nManager.getString('stats.tourCard.stops')}: ${appState.visitedStops.size} / ${appState.selectedHuts.length}`;
            } else {
                statusEl.textContent = '';
            }
        },

        updateSpeedWidget(speed) {
            const widget = document.getElementById('speed-widget');
            if (speed !== null && speed > 0.5) {
                widget.querySelector('span').textContent = `${speed.toFixed(0)} km/h`;
            } else {
                 widget.querySelector('span').textContent = `0 km/h`;
            }
        },

        setNavigationState(isNavigating) {
            const isGuide = appState.currentRoom.guideId === userManager.userId;
            const guidedTourActive = !!appState.currentRoom.guideId && !isGuide;

            appState.isNavigating = isNavigating;
            document.getElementById('startBtn').classList.toggle('hidden', isNavigating || guidedTourActive);
            document.getElementById('stopBtn').classList.toggle('hidden', !isNavigating || guidedTourActive);
            document.getElementById('resetBtn').disabled = guidedTourActive;
            document.getElementById('follow-toggle').classList.toggle('hidden', !isNavigating);
           // document.getElementById('navStats').classList.toggle('hidden', !isNavigating);
            document.getElementById('speed-widget').classList.toggle('hidden', !isNavigating);

            if(!isNavigating) {
                 document.getElementById('navHint').classList.add('hidden');
                 this.updateSpeedWidget(null);
            }
        },

                initTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabPanels = document.querySelectorAll('.tab-panel');

            // --- KORREKTUR: Pr√ºfen, ob Elemente vorhanden sind ---
            if (tabButtons.length > 0 && tabPanels.length > 0) {
                tabButtons[0].classList.add('bg-gray-200', 'dark:bg-gray-700');
                tabPanels[0].classList.remove('hidden');
            } else {
                console.error("Tab-Buttons oder Tab-Panels nicht gefunden. Tabs k√∂nnen nicht initialisiert werden.");
                return; // Funktion sicher beenden, ohne Absturz
            }
            // --- ENDE KORREKTUR ---

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('bg-gray-200', 'dark:bg-gray-700'));
                    button.classList.add('bg-gray-200', 'dark:bg-gray-700');
                    tabPanels.forEach(panel => panel.classList.add('hidden'));

                    const tabId = button.dataset.tab;
                    const tabPanel = document.getElementById(tabId); // Sicherer abrufen
                    
                    // --- KORREKTUR: Pr√ºfen ob Panel existiert ---
                    if (tabPanel) {
                        tabPanel.classList.remove('hidden');
                    } else {
                        console.error(`Tab-Panel mit ID '${tabId}' nicht gefunden.`);
                    }
                    // --- ENDE KORREKTUR ---

                    if (tabId === 'tab-stats') {
                      firebaseManager.loadUserTours(); // Neue Funktion aufrufen
                    }
                });
            });
        },

        showNavHint(icon, text) {
            const hintEl = document.getElementById('navHint');
            hintEl.innerHTML = `${icon} <span class="text-sm font-semibold">${text}</span>`;
            hintEl.classList.remove('hidden');
            hintEl.classList.add('visible');

            if (this.navHintTimer) clearTimeout(this.navHintTimer);
            this.navHintTimer = setTimeout(() => {
                hintEl.classList.remove('visible');
            }, 8000);
        },

       getTurnIcon(type) {
            if (type.includes('left')) {
                if (type.includes('sharp')) return '‚ÜôÔ∏è';
                if (type.includes('slight')) return '‚ÜñÔ∏è';
                return '‚¨ÖÔ∏è';
            }
            if (type.includes('right')) {
                 if (type.includes('sharp')) return '‚ÜòÔ∏è';
                 if (type.includes('slight')) return '‚ÜóÔ∏è';
                return '‚û°Ô∏è';
            }
            if (type.includes('roundabout')) return 'üîÑ';
            if (type.includes('arrive')) return 'üèÅ';
            if (type.includes('depart')) return 'üèÅ';
            return '‚¨ÜÔ∏è';
        },

        updateRoomUI(roomData, users = []) {
            const inRoom = !!roomData.id;
            document.getElementById('room-active-view').classList.toggle('hidden', !inRoom);
            document.getElementById('room-join-view').classList.toggle('hidden', inRoom);

            if(inRoom) {
                document.getElementById('current-room-id').textContent = roomData.id;
                const guideInfo = document.getElementById('guide-info');
                const guideBtn = document.getElementById('guide-btn');
                const isSelfGuide = roomData.guideId === userManager.userId;

                if (roomData.guideId) {
                    guideInfo.textContent = isSelfGuide
                        ? i18nManager.getString('room.guide.isGuide')
                        : i18nManager.getString('room.guide.isOther', { name: roomData.guideName || '...' });
                    guideBtn.textContent = isSelfGuide
                        ? i18nManager.getString('room.leaveGuide')
                        : i18nManager.getString('room.becomeGuide');
                    guideBtn.disabled = !isSelfGuide && !!roomData.guideId;
                } else {
                    guideInfo.textContent = i18nManager.getString('room.guide.noGuide');
                    guideBtn.textContent = i18nManager.getString('room.becomeGuide');
                    guideBtn.disabled = false;
                }

                const guidedTourInfo = document.getElementById('guided-tour-info');
                guidedTourInfo.classList.toggle('hidden', !roomData.isNavigating || isSelfGuide);


                const userListEl = document.getElementById('room-user-list');
                if(users.length > 0) {
                    userListEl.innerHTML = users.map(user => `<li>- ${user.name || 'Anonym'}</li>`).join('');
                } else {
                    userListEl.innerHTML = `<li>${i18nManager.getString('room.noActiveUsers')}</li>`;
                }
            }
        },

        openPopup(title, htmlContent) {
            const overlay = document.getElementById("popupOverlay");
            const content = document.getElementById("popupContent");
            overlay.classList.remove("hidden");
            content.innerHTML = `
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">${title}</h2>
                    <button onclick="uiManager.closePopup()" class="p-2 -mr-2 text-2xl">&times;</button>
                </div>
                <div>${htmlContent}</div>`;
        },

        closePopup() {
            document.getElementById("popupOverlay").classList.add("hidden");
        },

        showAddWarningModal(latlng) {
            this.tempWarningLatLng = latlng;
            document.getElementById('add-warning-modal').classList.remove('hidden');
        },
        hideAddWarningModal() {
            document.getElementById('add-warning-modal').classList.add('hidden');
            document.getElementById('warning-description').value = ''; // Clear description
        },
              
        /**
         * Aktualisiert die Live-Statistik-Leiste w√§hrend der Navigation.
         * Diese Funktion wird von einem 1-Sekunden-Timer aufgerufen.
         */
        updateNavStats() {
            // Pr√ºfen, ob wir noch navigieren und alle Daten da sind
            if (!appState.isNavigating || !routeManager.routeData || !appState.navigationStartTime) {
                if(appState.navStatsTimer) clearInterval(appState.navStatsTimer); // Timer stoppen
                // Stats zur√ºcksetzen, wenn Navigation stoppt
                appState.liveStats = { remainingDist: "-- km", eta: "--:--", traveledDist: "-- km" };
                return;
            }

            const totalDist_m = routeManager.routeData.distance;
            const totalDur_sec = routeManager.routeData.duration;
            const startTime = appState.navigationStartTime;
            const now = Date.now();

            // 1. Zeit-Berechnungen
            const timeElapsed_sec = (now - startTime) / 1000;
            const timeRemaining_sec = Math.max(0, totalDur_sec - timeElapsed_sec);
            
            // 2. Ankunftszeit (ETA)
            const etaTimestamp = now + (timeRemaining_sec * 1000);
            const etaDate = new Date(etaTimestamp);
            const etaHours = etaDate.getHours().toString().padStart(2, '0');
            const etaMinutes = etaDate.getMinutes().toString().padStart(2, '0');
            
            // 3. Strecken-Berechnungen
            const percentComplete = Math.min(1, timeElapsed_sec / totalDur_sec);
            const traveledDist_m = totalDist_m * percentComplete;
            const remainingDist_m = Math.max(0, totalDist_m - traveledDist_m);

            // NEU: In appState speichern statt direkt ins DOM
            appState.liveStats = {
                remainingDist: `${(remainingDist_m / 1000).toFixed(1)} km`,
                eta: `${etaHours}:${etaMinutes}`,
                traveledDist: `${(traveledDist_m / 1000).toFixed(1)} km`
            };
        },
showNavStatsPopup() {
            // Nur anzeigen, wenn wir navigieren
            if (!appState.isNavigating) return;

            // Hole die √ºbersetzten Titel
            const titleRemaining = i18nManager.getString('navstats.remaining');
            const titleEta = i18nManager.getString('navstats.eta');
            const titleTraveled = i18nManager.getString('navstats.traveled');
            const titlePopup = i18nManager.getString('navstats.popupTitle');

            // Hole die Live-Werte aus dem appState
            const stats = appState.liveStats;

            const htmlContent = `
                <div class="flex justify-around gap-4 text-center">
                    <div>
                        <div class="text-sm text-gray-500">${titleRemaining}</div>
                        <div class="font-bold text-2xl">${stats.remainingDist}</div>
                    </div>
                    <div>
                        <div class="text-sm text-gray-500">${titleEta}</div>
                        <div class="font-bold text-2xl">${stats.eta}</div>
                    </div>
                    <div>
                        <div class="text-sm text-gray-500">${titleTraveled}</div>
                        <div class="font-bold text-2xl">${stats.traveledDist}</div>
                    </div>
                </div>
            `;
            
            this.openPopup(titlePopup, htmlContent);
        },
        displayElevationChart(elevationData) {
            const container = document.getElementById('elevation-chart-container');
            const ctx = document.getElementById('elevation-chart').getContext('2d');

            if (this.elevationChartInstance) {
                this.elevationChartInstance.destroy();
                this.elevationChartInstance = null;
            }

            if (!elevationData || !elevationData.elevation) {
                container.classList.add('hidden');
                return;
            }

            container.classList.remove('hidden');

            const labels = elevationData.elevation.map((_, index) => index);
            const data = elevationData.elevation;

            const gridColor = appState.isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const fontColor = appState.isDarkTheme ? '#f9fafb' : '#1f2937';

            this.elevationChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'H√∂he (m)',
                        data: data,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: { color: fontColor },
                            grid: { color: gridColor },
                            title: {
                                display: true,
                                text: 'H√∂he (m)', // Could be translated if needed
                                color: fontColor,
                                font: { size: 10 }
                            }
                        },
                        x: {
                            ticks: { display: false },
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            intersect: false,
                            mode: 'index',
                            callbacks: {
                                label: (context) => `${context.parsed.y} m H√∂he` // Could be translated
                            }
                        }
                    }
                }
            });
        },

        /**
         * NEU: Kopiert den Einladungslink f√ºr den aktuellen Raum.
         */
        /**
         * NEU: Kopiert den Einladungslink f√ºr den aktuellen Raum.
         * ERWEITERT: Erstellt einen neuen Raum, falls man in keinem ist.
         */
        copyInviteLink() {
            // --- NEUER BLOCK: Raum erstellen, falls nicht vorhanden ---
            if (!appState.currentRoom.id) {
                // Generiere eine neue, einfache Raum-ID
                const newRoomId = `raum_${Math.random().toString(36).substring(2, 7)}`;
                
                // Tritt dem Raum bei (dies erstellt ihn jetzt auch, dank unserer √Ñnderung oben)
                firebaseManager.joinRoom(newRoomId);
                
                // Kurze Verz√∂gerung, damit der Link kopiert werden kann,
                // nachdem der state (appState.currentRoom.id) gesetzt wurde.
                setTimeout(() => {
                    this.copyRoomLinkToClipboard(newRoomId);
                }, 300); // 300ms Puffer
                return;
            }
            // --- ENDE NEUER BLOCK ---

            // Code f√ºr bestehenden Raum (wird jetzt von der Hilfsfunktion erledigt)
            this.copyRoomLinkToClipboard(appState.currentRoom.id);
        },

        /**
         * NEU: Fallback-Methode zum Kopieren in die Zwischenablage.
         */
        fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;

            // Make textarea non-editable and invisible
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            textArea.style.padding = 0;
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            textArea.style.background = 'transparent';

            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    uiManager.showToast(i18nManager.getString('toast.inviteLinkCopied'));
                } else {
                    console.error('Fallback execCommand copy failed');
                    uiManager.showToast('Could not copy link'); // Simple fallback message
                }
            } catch (err) {
                console.error('Fallback copy error:', err);
                uiManager.showToast('Could not copy link');
            }

            document.body.removeChild(textArea);
        },
      

        // NEU: Hilfsfunktion zum Kopieren, um Duplizierung zu vermeiden
        copyRoomLinkToClipboard(roomId) {
            const inviteLink = `${window.location.origin}${window.location.pathname}?room=${roomId}`;

            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(inviteLink).then(() => {
                    uiManager.showToast(i18nManager.getString('toast.inviteLinkCopied'));
                }).catch(err => {
                    console.error('Async clipboard copy failed:', err);
                    // Fallback to execCommand
                    this.fallbackCopyTextToClipboard(inviteLink);
                });
            } else {
                // Fallback for older browsers or insecure contexts
                this.fallbackCopyTextToClipboard(inviteLink);
            }
        },
      showSaveTourPopup() {
    const tourName = prompt("Wie m√∂chtest du diese Tour nennen?", "Meine Tour");
    if (tourName && tourName.trim() !== "") {
        firebaseManager.saveUserTour(tourName.trim());
    }
}
    };

    // ----------------------------------------------------------
    //  4. KARTEN MANAGER
    // ----------------------------------------------------------
    const mapManager = { /* Map manager code - see previous version */
        map: null,
        userMarker: null,
        tileLayer: null,
        clusterGroup: null,
        routeLine: null,
        previewLine: null,
        pastRouteLine: null,
        groupMarkers: {},
        warningMarkers: {},

        init(center, zoom) {
            this.map = L.map('map', { center, zoom, zoomControl: false });
            L.control.zoom({ position: 'bottomright' }).addTo(this.map);
            this.addTileLayer();

            this.clusterGroup = L.markerClusterGroup();
            this.map.addLayer(this.clusterGroup);

            this.map.on('dragstart', () => { if(appState.isFollowing) appState.toggleFollow() });
            this.map.on('contextmenu', (e) => uiManager.showAddWarningModal(e.latlng));

            this.map.on('popupopen', (e) => {
              const swiperEl = e.popup.getElement().querySelector('.popup-swiper');
              if (swiperEl && !swiperEl.swiper) {
                new Swiper(swiperEl, {
                  loop: true,
                  pagination: { el: '.swiper-pagination', clickable: true },
                  navigation: {
                    nextEl: '.swiper-button-next',
                    prevEl: '.swiper-button-prev',
                  },
                });
              }
            });
        },

        addTileLayer() {
            const url = appState.isDarkTheme
                ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
                : 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
            const attr = '&copy; OpenStreetMap &copy; CARTO';

            this.tileLayer = L.tileLayer(url, { attribution: attr, maxZoom: 19 });
            this.tileLayer.addTo(this.map);
        },

        updateUserMarker(latlng, accuracy, bearing) {
            const iconHtml = `
                <svg width="48" height="48" viewBox="0 0 48 48" style="transform: rotate(${bearing}deg); transition: transform 0.5s ease-out;">
                    <circle cx="24" cy="24" r="20" fill="#4285F4" fill-opacity="0.2" class="pulse-circle"/>
                    <path d="M24 4 L34 28 H14 Z" fill="#4285F4" stroke="white" stroke-width="2" style="filter: drop-shadow(0px 2px 4px rgba(0,0,0,0.4));"/>
                </svg>
            `;
            const userIcon = L.divIcon({
                html: iconHtml,
                className: '',
                iconSize: [48, 48],
                iconAnchor: [24, 24]
            });

            if (!this.userMarker) {
                this.userMarker = L.marker(latlng, { icon: userIcon }).addTo(this.map);
            } else {
                this.userMarker.setLatLng(latlng).setIcon(userIcon);
            }
        },

        updateGroupMarker(user) {
            const icon = L.divIcon({
                className: 'group-marker',
                html: `<div style="background-color: ${user.color};" class="p-1 rounded-full shadow-lg">üö¥</div><div class="text-xs -mt-1" style="color: ${user.color};">${user.name.substring(0,5)}</div>`
            });

            if (this.groupMarkers[user.id]) {
                this.groupMarkers[user.id].setLatLng([user.lat, user.lng]);
            } else {
                this.groupMarkers[user.id] = L.marker([user.lat, user.lng], { icon }).addTo(this.map);
            }
        },

        addWarningMarker(warning) {
            const icon = L.divIcon({
                className: 'warning-icon',
                html: '‚ö†Ô∏è',
                iconSize: [24, 24]
            });
            const marker = L.marker([warning.lat, warning.lng], { icon: icon })
                .bindPopup(`<b>${warning.type}</b><br>${warning.description || ''}`)
                .addTo(this.map);
            this.warningMarkers[warning.id] = marker;
        },

        removeWarningMarker(warningId) {
             if (this.warningMarkers[warningId]) {
                this.map.removeLayer(this.warningMarkers[warningId]);
                delete this.warningMarkers[warningId];
            }
        },

        removeGroupMarker(userId) {
            if (this.groupMarkers[userId]) {
                this.map.removeLayer(this.groupMarkers[userId]);
                delete this.groupMarkers[userId];
            }
        },

        drawRoute(coordinates, isPreview = false) {
            const options = isPreview
                ? { color: "#9ca3af", weight: 5, dashArray: "10, 10" }
                : { color: "#3b82f6", weight: 6, opacity: 0.8 };

            if(isPreview) {
                if(this.previewLine) this.map.removeLayer(this.previewLine);
                this.previewLine = L.polyline(coordinates, options).addTo(this.map);
            } else {
                if(this.routeLine) this.map.removeLayer(this.routeLine);
                this.routeLine = L.polyline(coordinates, options).addTo(this.map);
                if(this.pastRouteLine) this.map.removeLayer(this.pastRouteLine);
                this.pastRouteLine = L.polyline([], { color: 'gray', weight: 4, opacity: 0.7 }).addTo(this.map);
            }
        },

        addPointToPastRoute(latlng) {
            if (this.pastRouteLine) {
                this.pastRouteLine.addLatLng(latlng);
            }
        },

        clearRoute() {
            if(this.routeLine) this.map.removeLayer(this.routeLine);
            if(this.previewLine) this.map.removeLayer(this.previewLine);
            if(this.pastRouteLine) this.map.removeLayer(this.pastRouteLine);
            this.routeLine = null;
            this.previewLine = null;
            this.pastRouteLine = null;
        }
    };

    // ----------------------------------------------------------
    //  5. WEITERE MANAGER
    // ----------------------------------------------------------

    const ttsManager = { /* TTS manager code - see previous version, uses appState.currentLang */
        init() {
            const select = document.getElementById("appLangSelect");
            if (!select || !window.speechSynthesis) return;

            select.onchange = () => {
                i18nManager.setLanguage(select.value);
            };

            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = () => {};
            }
            speechSynthesis.getVoices();
        },

        async speak(text) {
            if (!appState.isVoiceOn || !text) return;
            speechSynthesis.cancel();
            
            const targetLang = appState.currentLang || 'de';
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = targetLang;

            const voices = speechSynthesis.getVoices();
            let voice = voices.find(v => v.lang.startsWith(targetLang));
            if (voice) {
                utterance.voice = voice;
            } else {
                 console.warn(`No voice found for language ${targetLang}`);
            }

            speechSynthesis.speak(utterance);
        }
    };

    const routeManager = { /* Route manager code - see previous version, uses i18nManager for toasts */
        routeData: null,
        recalcTimer: null,
        announcedSteps: {},
        lastRecalcTime: 0,

        async fetchRoute(startCoords, waypoints) {
            const coordinatesString = [
                `${startCoords.lng},${startCoords.lat}`,
                ...waypoints.map(h => `${h.lng},${h.lat}`)
            ].join(';');

            const url = `${config.routing.osrmHost}/route/v1/bicycle/${coordinatesString}?overview=full&geometries=geojson&steps=true`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`OSRM API Fehler: ${response.statusText}`);
                const data = await response.json();
                if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) throw new Error('OSRM konnte keine Route finden.');

                const route = data.routes[0];
                this.routeData = {
                    coords: route.geometry.coordinates.map(p => [p[1], p[0]]),
                    distance: route.distance,
                    duration: route.duration,
                    steps: route.legs.flatMap(leg => leg.steps)
                };
                return this.routeData;
            } catch (error) {
                console.error("Fehler bei der Routenberechnung:", error);
                uiManager.showToast(i18nManager.getString('toast.routeError'));
                return null;
            }
        },

        checkNextManeuver(userPos) {
            if (!this.routeData || !this.routeData.steps) return;

            for (let i = 0; i < this.routeData.steps.length; i++) {
                const step = this.routeData.steps[i];
                let instructionText = step.maneuver.instruction;

                // Basis-Anweisung generieren, falls sie fehlt
                if (!instructionText || instructionText.trim() === '') {
                    const type = step.maneuver.type;
                    const modifier = step.maneuver.modifier || '';
                    const road = step.name ? ` auf ${step.name}` : ''; // Bleibt sprachunabh√§ngig

                    // Nutze i18n-Keys (oder einfachen Text f√ºr Stra√üennamen)
                    if (type === 'continue' || type === 'new name') instructionText = `${i18nManager.getString('nav.continue')}${road}`;
                    else if (type === 'arrive') instructionText = `${i18nManager.getString('nav.arrive')}${road}`;
                    else if (type === 'depart') instructionText = `${i18nManager.getString('nav.depart')}${road}`;
                    else instructionText = `${modifier.replace(/_/g, ' ')}${road}`; // z.B. "links abbiegen auf Hauptstra√üe"
                    
                    // Gro√üschreibung ist nicht mehr n√∂tig, da es von i18n kommt
                }

                const stepLocation = L.latLng(step.maneuver.location[1], step.maneuver.location[0]);
                const distance = userPos.distanceTo(stepLocation);

                if (!this.announcedSteps[i]) this.announcedSteps[i] = { pre: false, imminent: false };

                // "In ... Metern" - Ansage
                if (distance < 150 && distance > 40 && !this.announcedSteps[i].pre) {
                    this.announcedSteps[i].pre = true;
                    const roundedDist = Math.round(distance / 10) * 10;
                    
                    // NEU: Verwende i18n-String
                    const hintText = i18nManager.getString('nav.in_meters', { meters: roundedDist, instruction: instructionText });
                    const icon = uiManager.getTurnIcon(step.maneuver.type);

                    uiManager.showNavHint(icon, hintText); // UI-Hinweis
                    ttsManager.speak(hintText); // Sprachausgabe
                    break;
                }

                // "Jetzt" - Ansage
                if (distance < 25 && !this.announcedSteps[i].imminent) {
                    this.announcedSteps[i].imminent = true;
                    
                    // NEU: Verwende i18n-String
                    const hintText = i18nManager.getString('nav.now', { instruction: instructionText });
                    const icon = uiManager.getTurnIcon(step.maneuver.type);
                    
                    uiManager.showNavHint(icon, hintText);
                    ttsManager.speak(hintText);

                                        // --- VERBESSERTE ZIEL-ERREICHT-LOGIK ---
                    // Finde das n√§chste Ziel, das wir gerade erreichen UND das noch nicht besucht wurde
                    const nextHut = appState.selectedHuts.find(hut => 
                        !appState.visitedStops.has(hut.id) && // Finde nur noch nicht besuchte
                        L.latLng(hut.lat, hut.lng).distanceTo(stepLocation) < 50
                    );

                    if (nextHut) { // Wir haben ein Ziel auf diesem "arrive" Step erreicht
                       appState.visitedStops.add(nextHut.id);
                       uiManager.updateChallengeStatus();
                       
                       // FALL 1: Das war das LETZTE Ziel
                       if(appState.visitedStops.size === appState.selectedHuts.length) {
                           uiManager.showToast(i18nManager.getString('toast.allStopsReached'));
                           ttsManager.speak(i18nManager.getString('toast.allStopsReached.speak'));
                           firebaseManager.saveTourLog(this.routeData, appState.selectedHuts, appState.visitedStops);
                           
                           // WICHTIG: Navigation jetzt beenden
                           this.stopNavigation();
                       
                       } else {
                           // FALL 2: Das war ein ZWISCHENZIEL
                           const nextStopIndex = appState.visitedStops.size; // Index des N√ÑCHSTEN Ziels
                           const nextStopName = appState.selectedHuts[nextStopIndex].name;
                           
                           // Nutze die neuen √úbersetzungen
                           const toastMsg = i18nManager.getString('toast.stopReached', { stopName: nextHut.name });
                           const speakMsg = i18nManager.getString('toast.stopReached.speak', { stopName: nextHut.name, nextStopName: nextStopName });
                           
                           uiManager.showToast(toastMsg);
                           ttsManager.speak(speakMsg);
                           // Die Navigation l√§uft automatisch weiter zum n√§chsten Ziel
                       }
                    }
                    break; // break f√ºr die "Jetzt" (distance < 25) Ansage

                }
            }
        },

        checkDeviation(userPos) {
            if (!appState.isNavigating || !mapManager.routeLine) return;

            const now = Date.now();
            if (now - this.lastRecalcTime < config.routing.recalcDebounceMs) return;

            const routeLatLngs = mapManager.routeLine.getLatLngs();
            if (!routeLatLngs || routeLatLngs.length < 2) return;

            const closestPoint = L.GeometryUtil.closest(mapManager.map, routeLatLngs, userPos);
             if (!closestPoint || !closestPoint.latlng) {
                 console.warn("Could not find closest point on route.");
                 return;
             }

            const distance = userPos.distanceTo(closestPoint.latlng);

            if (distance > config.routing.deviationThresholdMeters) {
                this.lastRecalcTime = now;
                uiManager.showToast(i18nManager.getString('toast.routeDeviation'));
                this.startNavigation(); // Recalculate from current position
            }
        },

        toggleSelect(hut) {
            const index = appState.selectedHuts.findIndex(h => h.id === hut.id);
            if (index > -1) {
                appState.selectedHuts.splice(index, 1);
            } else {
                appState.selectedHuts.push(hut);
            }
            uiManager.updateSelectedList();

            if (appState.isNavigating) {
                uiManager.showToast(i18nManager.getString('toast.routeUpdating'));
                this.startNavigation(); // Live-Update der Navigation
            } else {
                this.recalculatePreviewRoute(); // Nur Vorschau aktualisieren
            }

            if(appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        },

        removeSelected(index) {
            appState.selectedHuts.splice(index, 1);
            uiManager.updateSelectedList();

            if (appState.isNavigating) {
                 uiManager.showToast(i18nManager.getString('toast.routeUpdating'));
                this.startNavigation();
            } else {
                this.recalculatePreviewRoute();
            }

            if(appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        },

        async recalculatePreviewRoute() {
            if (appState.selectedHuts.length < 1) {
                mapManager.clearRoute();
                document.getElementById('tour-stats').textContent = '';
                uiManager.displayElevationChart(null);
                return;
            }
            if (appState.selectedHuts.length < 2) {
                if(mapManager.previewLine) mapManager.map.removeLayer(mapManager.previewLine);
                document.getElementById('tour-stats').textContent = i18nManager.getString('tour.stats.addMore');
                uiManager.displayElevationChart(null);
                return;
            }

            uiManager.setLoading(true, i18nManager.getString('toast.previewLoading'));
            const startPos = await userManager.getCurrentPosition();
            const route = await this.fetchRoute(startPos, appState.selectedHuts);
            if(route) localStorage.setItem('lastRouteData', JSON.stringify(route));

            if(route) {
                mapManager.drawRoute(route.coords, true);

                if (!appState.isNavigating) {
                     // Only fit bounds if not currently navigating to avoid jarring zoom out
                    mapManager.map.fitBounds(mapManager.previewLine.getBounds(), {padding: [50,50]});
                }

                const distanceKm = (route.distance / 1000).toFixed(1);
                const durationMin = Math.round(route.duration / 60);
                document.getElementById('tour-stats').textContent = i18nManager.getString('tour.stats', { dist: distanceKm, time: durationMin });

                const elevationData = await weatherManager.fetchElevation(route.coords);
                uiManager.displayElevationChart(elevationData);
            }
            uiManager.setLoading(false);
        },

        async startNavigation() {
            if (appState.currentRoom.id && appState.currentRoom.guideId && appState.currentRoom.guideId !== userManager.userId) {
                uiManager.showToast(i18nManager.getString('toast.guideOnly'));
                return;
            }

            if(appState.selectedHuts.length < 1) {
                uiManager.showToast(i18nManager.getString('toast.noStops'));
                return;
            }
            uiManager.setLoading(true, i18nManager.getString('toast.navStarting'));
            const startPos = await userManager.getCurrentPosition();
            const route = await this.fetchRoute(startPos, appState.selectedHuts);
            uiManager.setLoading(false);

            if(route) {
                localStorage.setItem('lastRouteData', JSON.stringify(route));
                this.announcedSteps = {};
                appState.visitedStops.clear();
                appState.navigationStartTime = Date.now();
                appState.lastBreakTime = Date.now();
                uiManager.updateChallengeStatus();
                mapManager.drawRoute(route.coords);

                mapManager.map.flyTo(startPos, config.map.navigationZoom, {
                    duration: 2.5,
                    easeLinearity: 0.5
                });

                uiManager.setNavigationState(true);
              //  userManager.startWatchingPosition();
                uiManager.showToast(i18nManager.getString('toast.navStarted'));

                const elevationData = await weatherManager.fetchElevation(route.coords);
                uiManager.displayElevationChart(elevationData);

                if (appState.currentRoom.id && appState.currentRoom.guideId === userManager.userId) {
                    const serializableRoute = { coords: route.coords, distance: route.distance, duration: route.duration, steps: route.steps };
                    firebaseManager.updateGuidedRoute(true, serializableRoute);
                }
            }
        },

        stopNavigation() {
            if (appState.currentRoom.id && appState.currentRoom.guideId && appState.currentRoom.guideId !== userManager.userId) {
                uiManager.showToast(i18nManager.getString('toast.guideOnly'));
                return;
            }

            if(this.routeData && appState.visitedStops.size > 0) {
                 firebaseManager.saveTourLog(this.routeData, appState.selectedHuts, appState.visitedStops);
            }

          // NEU: Stoppe den Statistik-Timer
            if (appState.navStatsTimer) clearInterval(appState.navStatsTimer);
            appState.navStatsTimer = null;
          //  userManager.stopWatchingPosition();
            mapManager.clearRoute();
            this.routeData = null;
            this.announcedSteps = {};
            appState.navigationStartTime = null;
            appState.lastBreakTime = null;
            uiManager.setNavigationState(false);
            uiManager.showToast(i18nManager.getString('toast.navStopped'));
            uiManager.displayElevationChart(null);

            if (appState.currentRoom.id && appState.currentRoom.guideId === userManager.userId) {
                firebaseManager.updateGuidedRoute(false, null);
            }
        },

        resetRoute() {
            this.stopNavigation(); // Will also save log if applicable
            appState.selectedHuts = [];
            appState.visitedStops.clear();
            uiManager.updateSelectedList();
             localStorage.removeItem('lastRouteData');
            if(appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        }
    };

    const userManager = { /* User manager code - see previous version, uses i18nManager for toasts */
        watchId: null,
        lastPosition: null,
        lastBearing: 0,
        userId: null,
      displayName: 'Anonymer Nutzer', // NEU: Standardwert hinzuf√ºgen
        warnedAbout: new Set(),

        init(uid, displayName) { // Empf√§ngt jetzt uid UND displayName
    // NEU: Google-Namen in das neue Feld schreiben
    const nameDisplay = document.getElementById('usernameDisplay');
    if(nameDisplay) {
        nameDisplay.textContent = displayName || 'Anonymer Nutzer'; // Fallback
    }

    // NEU: Den Namen im State speichern, damit andere Funktionen ihn nutzen k√∂nnen
    this.displayName = displayName || 'Anonymer Nutzer';
    this.userId = uid; // WICHTIG: userId hier setzen

    this.getCurrentPosition(true).then(pos => {
                mapManager.updateUserMarker(pos, 20, 0);
                mapManager.map.setView(pos, config.map.defaultZoom);
                weatherManager.fetchWeather(pos.lat, pos.lng);
            }).finally(() => uiManager.setLoading(false));

            firebaseManager.rejoinLastRoom();
          this.startWatchingPosition();
        },

        getCurrentPosition(highAccuracy = false) {
             return new Promise((resolve) => {
                navigator.geolocation.getCurrentPosition(
                    pos => resolve(L.latLng(pos.coords.latitude, pos.coords.longitude)),
                    async err => {
                        console.warn("GPS Fehler:", err);
                        if(highAccuracy) {
                            uiManager.showToast("Hohe GPS-Genauigkeit fehlgeschlagen, versuche Standard...");
                            resolve(await this.getCurrentPosition(false));
                        } else {
                            uiManager.showToast("GPS nicht verf√ºgbar. Nutze Fallback-Position.");
                            resolve(L.latLng(config.map.defaultCenter[0], config.map.defaultCenter[1]));
                        }
                    },
                    { enableHighAccuracy: highAccuracy, timeout: highAccuracy ? 10000 : 5000, maximumAge: 60000 }
                );
            });
        },

        setupBatteryListener() {
            if ('getBattery' in navigator) {
                navigator.getBattery().then(battery => {
                    const checkBattery = () => {
                        if (battery.level <= 0.20 && !battery.charging) {
                            uiManager.showToast("‚ö†Ô∏è Akku unter 20%! GPS verbraucht viel Strom.");
                            ttsManager.speak("Achtung, dein Akkustand ist niedrig.");
                        }
                    };
                    battery.addEventListener('levelchange', checkBattery);
                    checkBattery();
                });
            }
        },
        startWatchingPosition() {
            if (this.watchId) return;
            const options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 };
                        this.watchId = navigator.geolocation.watchPosition(
                pos => {
                    const currentPos = L.latLng(pos.coords.latitude, pos.coords.longitude);
                    let speedKmh = null;
                    
                    // 1. Geschwindigkeit ermitteln
                    if (pos.coords.speed !== null && pos.coords.speed >= 0) {
                        speedKmh = pos.coords.speed * 3.6;
                    }
                    uiManager.updateSpeedWidget(speedKmh);

                    // 2. Peilung nur berechnen, wenn wir uns bewegen (z.B. > 1.5 km/h)
                    //    Die Peilung ist bei Stillstand oder langsamer Fahrt extrem ungenau.
                    if (this.lastPosition && speedKmh !== null && speedKmh > 1.5) {
                        // Neue Peilung berechnen
                        const calculatedBearing = this.getBearing(this.lastPosition, currentPos);
                        
                        // 3. Peilung gl√§tten (Exponential Moving Average)
                        //    Dies verhindert das "Springen" und mischt den alten Wert (80%)
                        //    mit dem neuen Wert (20%).
                        const smoothingFactor = 0.2; // Kleinerer Wert = st√§rkere Gl√§ttung
                        this.lastBearing = (calculatedBearing * smoothingFactor) + (this.lastBearing * (1 - smoothingFactor));

                    } else if (!this.lastPosition) {
                        // Beim allerersten Mal auf 0 setzen
                        this.lastBearing = 0;
                    }
                    // Wenn der Nutzer steht (speedKmh <= 1.5), behalten wir einfach 'this.lastBearing' bei.

                    // 4. Marker mit der gegl√§tteten Peilung aktualisieren
                    mapManager.updateUserMarker(currentPos, pos.coords.accuracy, this.lastBearing);

                    // --- Restlicher Code (bleibt gleich) ---
                    if (appState.isFollowing) mapManager.map.panTo(currentPos);

                    if(appState.isNavigating) {
                        routeManager.checkNextManeuver(currentPos);
                        routeManager.checkDeviation(currentPos);
                        mapManager.addPointToPastRoute(currentPos);
                        this.checkSmartAlerts();
                    }
                    if(appState.currentRoom.id) firebaseManager.updateUserPositionInRoom(currentPos);

                    weatherManager.fetchWeather(currentPos.lat, currentPos.lng);
                    this.checkProximityToWarnings(currentPos);

                    this.lastPosition = currentPos;
                },
                err => console.error("GPS Watch Fehler:", err),
                options
            );
        },

        stopWatchingPosition() {
            if(this.watchId) navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
            uiManager.updateSpeedWidget(null);
        },

        getBearing(from, to) {
            const lat1 = from.lat * Math.PI / 180;
            const lat2 = to.lat * Math.PI / 180;
            const dLon = (to.lng - from.lng) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
        },

        checkProximityToWarnings(userPos) {
            for (const warning of appState.allWarnings) {
                if (!this.warnedAbout.has(warning.id)) {
                    const warningPos = L.latLng(warning.lat, warning.lng);
                    const distance = userPos.distanceTo(warningPos);
                    if (distance < 100) {
                         // Base German text
                        const messageBase = `Achtung, in ${Math.round(distance/10)*10} Metern gemeldete Gefahr: ${warning.type}.`;
                        ttsManager.speak(messageBase); // Let TTS handle translation
                         // Show toast in current app language
                         /*ttsManager.translateText(messageBase, appState.currentLang).then(translatedMsg => {
                              uiManager.showToast(translatedMsg || messageBase);
                         });*/
                        uiManager.showToast(messageBase);
                        this.warnedAbout.add(warning.id);
                    }
                }
            }
        },

        checkSmartAlerts() {
            if (!appState.isNavigating || !appState.navigationStartTime) return;

            const now = Date.now();
            const timeSinceLastBreak = now - (appState.lastBreakTime || appState.navigationStartTime);

            if (timeSinceLastBreak > 3600000) { // 1 hour
                const message = i18nManager.getString('toast.smartBreak');
                ttsManager.speak(message); // Let TTS handle translation if necessary
                uiManager.showToast(message);
                appState.lastBreakTime = now;
            }
        },

        saveUsername() {
            const name = document.getElementById('usernameInput').value.trim();
            if(name) {
                localStorage.setItem('username', name);
                uiManager.showToast(i18nManager.getString('toast.nameSaved'));
            }
        },

        async sendSOS() {
            if (!confirm(i18nManager.getString('toast.sosConfirm'))) return;
            const pos = await this.getCurrentPosition();
            const link = `https://maps.google.com/?q=${pos.lat},${pos.lng}`;
             // Message remains universal/simple
            const message = `üö® NOTRUF üö® Ich brauche Hilfe! Mein Standort: ${link}`;
            window.open(`https://wa.me/?text=${encodeURIComponent(message)}`, "_blank");
        },
      async recenterMap() {
            try {
                const pos = await this.getCurrentPosition(true); // Hohe Genauigkeit
                if (mapManager.map && pos) {
                    mapManager.map.flyTo(pos, config.map.navigationZoom, {
                         duration: 1.5 // Sanfter Flug
                    });
                    // Optional: Follow-Modus wieder aktivieren, falls er aus war
                    if (!appState.isFollowing) {
                        appState.toggleFollow();
                    }
                }
            } catch (err) {
                console.error("Fehler beim Zentrieren der Karte:", err);
                uiManager.showToast("Position konnte nicht abgerufen werden.");
            }
        }
    
    };

    /*const geminiManager = { 
        async callGemini(prompt, jsonSchema = null) {
            if (!navigator.onLine) {
                 uiManager.showToast(i18nManager.getString('toast.offlineAI'));
                 return null;
            }
            // API Key is now directly used
            if (!GEMINI_API_KEY || GEMINI_API_KEY === "DEIN_API_KEY_HIER") {
                console.error("Gemini API Key fehlt oder ist Platzhalter.");
                uiManager.showToast(i18nManager.getString('toast.apiKeyWarning'));
                return null;
            }

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };

            if (jsonSchema) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: jsonSchema,
                };
            }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                const result = await response.json();
                const candidate = result.candidates?.[0];
                if (!candidate?.content?.parts?.[0]?.text) throw new Error("Invalid API response structure.");
                return candidate.content.parts[0].text;
            } catch (error) {
                console.error("Fehler bei der Gemini-API-Anfrage:", error);
                uiManager.showToast(i18nManager.getString('toast.geminiError'));
                return null;
            }
        },

        async translateText(text, targetLang) {
            if (!text || !targetLang || !navigator.onLine) {
                return text;
            }
            // Avoid translating if source and target are the same
             if (targetLang === i18nManager.currentLang && targetLang === 'de') return text; // Assuming base text is German


            const langName = new Intl.DisplayNames([targetLang], { type: 'language' }).of(targetLang);
            const sourceLangName = new Intl.DisplayNames(['de'], { type: 'language'}).of('de'); // Assume source is German for now

            // Improved prompt specifying source language assumption
            const prompt = `Translate the following ${sourceLangName} text for a navigation app into ${langName} (language code ${targetLang}). Keep proper names (streets, places) if possible. Reply only with the pure translation, without introduction. Text: "${text}"`;

            try {
                const translation = await this.callGemini(prompt);
                // Basic check if translation looks valid (not empty, not just repeating prompt)
                if (translation && translation.trim() && !translation.includes("Translate the following")) {
                    return translation.trim();
                }
                return text; // Fallback if translation fails or looks invalid
            } catch (error) {
                console.error("√úbersetzungsfehler:", error);
                return text; // Fallback
            }
        },

        async suggestTour(weatherData = null) {
             if (!navigator.onLine) {
                 uiManager.showToast(i18nManager.getString('toast.offlineAI'));
                 return;
            }
            const btn = document.getElementById('suggest-tour-btn');
            btn.disabled = true;
            btn.textContent = i18nManager.getString('tour.aiSuggestBtn.loading');

            try {
                const userPos = await userManager.getCurrentPosition();
                if (appState.allHuts.length === 0) {
                    uiManager.showToast(i18nManager.getString('toast.hutsNotLoaded'));
                    btn.disabled = false; // Re-enable button
                    btn.textContent = i18nManager.getString('tour.aiSuggestBtn');
                    return;
                }
                const difficulty = document.getElementById('tour-difficulty').options[document.getElementById('tour-difficulty').selectedIndex].text; // Get selected text
                const intensity = document.getElementById('user-pref-intensity').options[document.getElementById('user-pref-intensity').selectedIndex].text;
                const tourType = document.getElementById('user-pref-type').options[document.getElementById('user-pref-type').selectedIndex].text;
                const weatherText = weatherData
                    ? `The current weather is: ${weatherData.temperature}¬∞C.` // Use English for the prompt context
                    : "The weather is unknown.";

                const hutsString = appState.allHuts.map(h => `id: ${h.id}, name: ${h.name}`).join('; ');

                const targetLang = appState.currentLang;
                const langName = new Intl.DisplayNames([targetLang], { type: 'language' }).of(targetLang);

                // Prompt asking for description in target language
                const prompt = `
                  I am a cyclist at position ${userPos.lat},${userPos.lng}.
                  Suggest a ${difficulty} difficulty bike tour.
                  My preferences are: Intensity: "${intensity}", Tour Type: "${tourType}".
                  ${weatherText}
                  Please consider these preferences when selecting stops.
                  Here is a list of available huts: ${hutsString}.
                  Suggest a route with 3 to 5 stops, list the IDs of the huts in the correct order.
                  Give the tour a catchy title and a short, motivating description in ${langName} (language code "${targetLang}").
                  Respond exclusively in the following JSON format:`;

                const schema = {
                    type: "OBJECT",
                    properties: {
                        "title": { "type": "STRING" },
                        "description": { "type": "STRING" },
                        "stop_ids": { "type": "ARRAY", "items": { "type": "STRING" } }
                    },
                    required: ["title", "description", "stop_ids"]
                };

                const resultText = await this.callGemini(prompt, schema);
                if (!resultText) {
                    btn.disabled = false;
                    btn.textContent = i18nManager.getString('tour.aiSuggestBtn');
                    return;
                }

                const resultJson = JSON.parse(resultText);
                uiManager.openPopup(
                    // Title might be in target lang, use as is
                    `${i18nManager.getString('popup.aiSuggestionTitle', { title: '' })}${resultJson.title}`,
                     // Description is already in target lang
                    i18nManager.getString('popup.aiSuggestionBody', { desc: resultJson.description })
                );

                appState.selectedHuts = resultJson.stop_ids
                    .map(stopId => appState.allHuts.find(h => h.id === stopId))
                    .filter(Boolean);

                uiManager.updateSelectedList();
                routeManager.recalculatePreviewRoute();
                if (appState.currentRoom.id) {
                    firebaseManager.updateRoomHuts();
                }

            } catch(e) {
                console.error("Fehler beim Verarbeiten des Tour-Vorschlags:", e);
                uiManager.showToast(i18nManager.getString('toast.geminiError'));
            }
            finally {
                btn.disabled = false;
                btn.textContent = i18nManager.getString('tour.aiSuggestBtn');
            }
        },

        async summarizeTour() {
             if (!navigator.onLine) {
                 uiManager.showToast(i18nManager.getString('toast.offlineAI'));
                 return;
            }
            if (appState.selectedHuts.length < 1) return;
             const btn = document.getElementById('summarize-tour-btn');
            btn.disabled = true;
            btn.innerHTML = `<div class="loader-spinner !w-5 !h-5 !border-2 mx-auto"></div>`;


            try {
                const stops = appState.selectedHuts.map(h => h.name).join(', ');
                const distance = routeManager.routeData ? (routeManager.routeData.distance / 1000).toFixed(1) + " km" : "unknown distance"; // Use English for prompt context

                const targetLang = appState.currentLang;
                 const langName = new Intl.DisplayNames([targetLang], { type: 'language' }).of(targetLang);

                const prompt = `Write a fun and adventurous summary (approx. 2 paragraphs) for a bike tour in ${langName} (language code "${targetLang}"). The tour has the following stops: ${stops}. The total distance is approx. ${distance}. The summary should inspire people to go cycling.`;

                const summary = await this.callGemini(prompt);
                if (summary) {
                    const formattedSummary = summary.replace(/\n/g, '<br>');
                    uiManager.openPopup(i18nManager.getString('popup.aiSummaryTitle'), `<p>${formattedSummary}</p>`);
                }
            } finally {
                btn.disabled = false;
                 // Re-apply translated text to the button
                btn.textContent = i18nManager.getString('tour.aiSummaryBtn');
            }
        }
    };*/
const geminiManager = {
    async callGemini() { return null; }, // Deaktiviert die API komplett
    
    async translateText(text) { 
        return text; // Gibt einfach den Originaltext zur√ºck (keine Kosten)
    },

    async suggestTour() {
        uiManager.showToast("KI-Planer ist derzeit deaktiviert.");
        const btn = document.getElementById('suggest-tour-btn');
        btn.textContent = "Vorschlagen";
        btn.disabled = false;
    },

    async summarizeTour() {
        uiManager.showToast("Zusammenfassung derzeit nicht verf√ºgbar.");
    }
};
    const firebaseManager = { /* Firebase manager code - uses i18nManager, handles invite link */
        db: null,

        init() {
            try {
               // firebase.initializeApp(config.firebase);
                this.db = firebase.firestore();
                this.loadHuts();
                this.listenToWarnings();
            } catch(e) {
                console.error("Firebase Init Fehler:", e);
                uiManager.showToast(i18nManager.getString('toast.hutsLoadingError'));
                this.loadOfflineHuts();
            }
        },

        loadOfflineHuts() {
            const offlineHuts = localStorage.getItem('allHutsData');
            if (offlineHuts) {
                try {
                    appState.allHuts = JSON.parse(offlineHuts);
                    this.displayHuts(appState.allHuts);
                    uiManager.showToast(i18nManager.getString('toast.offlineHutsLoaded'));
                } catch (e) {
                    console.error("Fehler beim Laden der Offline-H√ºtten:", e);
                }
            } else {
                 uiManager.showToast(i18nManager.getString('toast.offlineHutsNotFound'));
            }
            const lastRoute = localStorage.getItem('lastRouteData');
             if(lastRoute && appState.selectedHuts.length > 1){
                 try {
                     routeManager.routeData = JSON.parse(lastRoute);
                     mapManager.drawRoute(routeManager.routeData.coords, true);
                     uiManager.showToast(i18nManager.getString('toast.offlineRouteLoaded'));
                 } catch(e){
                     console.error(i18nManager.getString('toast.offlineRouteError'), e);
                 }
             }
        },

        displayHuts(huts) {
            mapManager.clusterGroup.clearLayers();
             huts.forEach(hut => {
                  const marker = L.marker([hut.lat, hut.lng]);
                  marker.bindTooltip(hut.name, { permanent: true, direction: 'bottom', className: 'hutten-bubble', offset: [0, 10] });
                  marker.bindPopup(i18nManager.getString('popup.hut.loading'), {minWidth: 300});

                  marker.on('click', () => {
                        const isSelected = appState.selectedHuts.some(h => h.id === hut.id);
                        const bilderUrls = (hut.fotos || []).filter(f => typeof f === 'string' || f.status === 'freigegeben').map(f => typeof f === 'string' ? f : f.url);

                        let oeffnungszeitenHTML = `<p>${i18nManager.getString('popup.hut.openingHours.unknown')}</p>`;
                        if (hut.immerGeoeffnet === true) {
                            oeffnungszeitenHTML = `<p>${i18nManager.getString('popup.hut.openingHours.always')}</p>`;
                        } else if (Array.isArray(hut.oeffnungszeiten) && hut.oeffnungszeiten.length > 0) {
                            if (typeof hut.oeffnungszeiten[0] === 'object' && hut.oeffnungszeiten[0] !== null && 'tag' in hut.oeffnungszeiten[0]) {
                                oeffnungszeitenHTML = "<ul class='oeffnungszeiten-list'>" +
                                    hut.oeffnungszeiten
                                    .map(e => `<li><span class="tag">${e.tag}:</span> <span class="zeit">${e.von || '‚Äì'} - ${e.bis || '‚Äì'}</span></li>`)
                                    .join("") +
                                "</ul>";
                            } else {
                                oeffnungszeitenHTML = "<ul class='oeffnungszeiten-list'>" + hut.oeffnungszeiten.map(e => `<li>${e}</li>`).join("") + "</ul>";
                            }
                        } else if (typeof hut.oeffnungszeiten === "object" && hut.oeffnungszeiten !== null && !Array.isArray(hut.oeffnungszeiten)) {
                            const tage = Object.entries(hut.oeffnungszeiten);
                            if (tage.length > 0) {
                                oeffnungszeitenHTML = "<ul class='oeffnungszeiten-list'>" +
                                    tage.map(([tag, val]) =>
                                    `<li><span class="tag">${tag}:</span> <span class="zeit">${(val.start || "‚Äì")} - ${(val.ende || "‚Äì")}</span></li>`
                                    ).join("") +
                                    "</ul>";
                            }
                        } else if (typeof hut.oeffnungszeiten === "string" && hut.oeffnungszeiten.trim()) {
                            oeffnungszeitenHTML = `<p>${hut.oeffnungszeiten.replace(/\n/g, '<br>')}</p>`;
                        }
                    const randomPlaceholderIndex = Math.floor(Math.random() * config.noImagePlaceholders.length);

                        // Ersetze den alten 'popupContent'-Block (ca. Zeile 1494) durch diesen:

                        const popupContent = `
                          <div class="popup-card overflow-hidden">
                              ${bilderUrls.length > 0 ? `
                              <div class="swiper popup-swiper">
                                <div class="swiper-wrapper">
                                  ${bilderUrls.map(url => `
                                      <div class="swiper-slide">
                                          <img src="${url}" alt="${hut.name}" loading="lazy">
                                      </div>`).join('')}
                                </div>
                                <div class="swiper-pagination"></div>
                                <div class="swiper-button-prev !text-white"></div>
                                <div class="swiper-button-next !text-white"></div>
                              </div>
                              ` : `<img src="${config.noImagePlaceholders[randomPlaceholderIndex]}" class="popup-swiper-img" loading="lazy">`}
                      
                              <div class="popup-content-area space-y-3">
                                  <div class="flex justify-between items-start">
                                      <h3 class="font-bold text-lg leading-tight pr-2">${hut.name}</h3>
                                      ${hut.premium ? `<span class="text-xs font-bold text-yellow-800 bg-yellow-200 dark:bg-yellow-800 dark:text-yellow-200 px-2 py-1 rounded-full flex-shrink-0">${i18nManager.getString('popup.hut.premium')}</span>` : ''}
                                  </div>
                      
                                  ${(hut.beschreibung || hut.Beschreibung) ? `<div class="text-sm text-gray-600 dark:text-gray-300 border-t border-b border-[var(--border-color)] py-2">${hut.beschreibung || hut.Beschreibung}</div>` : ''}
                      
                                  <div class="text-sm border-t border-[var(--border-color)] pt-2">
                                      <h4 class="font-semibold text-xs uppercase text-gray-500 mb-1">${i18nManager.getString('popup.hut.openingHours')}</h4>
                                      <div>${oeffnungszeitenHTML}</div>
                                  </div>
                      
                                  <div class="grid grid-cols-2 gap-2 text-sm">
                                      <div class="flex items-center gap-2">
                                          <span>üêæ</span>
                                          <span>${i18nManager.getString('popup.hut.animals')}: ${hut.tiere ? hut.tiere.join(', ') : i18nManager.getString('popup.hut.animals.none')}</span>
                                      </div>
                                      <div class="flex items-center gap-2">
                                          <span>‚ö°Ô∏è</span>
                                          <span>${i18nManager.getString('popup.hut.power')}: ${hut.strom || i18nManager.getString('popup.hut.power.unknown')}</span>
                                      </div>
                                      <div class="flex items-center gap-2">
                                          <span>ü™ë</span>
                                          <span>${i18nManager.getString('popup.hut.seats')}: ${hut.sitzplaetze || i18nManager.getString('popup.hut.seats.unknown')}</span>
                                      </div>
                                  </div>
                      
                                  ${hut.premium ? `
                                      <div class="space-y-2 text-sm border-t border-[var(--border-color)] pt-2">
                                          <h4 class="font-semibold text-xs uppercase text-gray-500">${i18nManager.getString('popup.hut.premiumInfo')}</h4>
                                          ${hut.telefon ? `<p>üìû <a href="tel:${hut.telefon}" class="text-blue-500 hover:underline">${i18nManager.getString('popup.hut.phone')}: ${hut.telefon}</a></p>`: ''}
                                          ${hut.contactEmail ? `<p>‚úâÔ∏è <a href="mailto:${hut.contactEmail}" class="text-blue-500 hover:underline">${i18nManager.getString('popup.hut.email')}: ${hut.contactEmail}</a></p>`: ''}
                                          ${hut.website ? `<p>üåê <a href="${hut.website}" target="_blank" rel="noopener" class="text-blue-500 hover:underline">${i18nManager.getString('popup.hut.website')}</a></p>`: ''}
                      
                                          <div class="flex gap-3 pt-1">
                                              ${hut.instagram ? `<a href="${hut.instagram}" target="_blank" rel="noopener" class="opacity-80 hover:opacity-100"><svg ...> Instagram SVG </svg></a>`: ''}
                                              ${hut.facebook ? `<a href="${hut.facebook}" target="_blank" rel="noopener" class="opacity-80 hover:opacity-100"><svg ...> Facebook SVG </svg></a>`: ''}
                                          </div>
                                      </div>
                                  `: ''}
                              </div>
                      
                              <div class="popup-button-container flex flex-col gap-2">
                                  <button id="btn-${hut.id}" class="w-full p-2 rounded-lg font-semibold text-white ${isSelected ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'} transition-colors">
                                      ${isSelected ? i18nManager.getString('popup.hut.removeBtn') : i18nManager.getString('popup.hut.addBtn')}
                                  </button>
                              </div>
                          </div>
                      `;

                        marker.setPopupContent(popupContent).openPopup();

                        setTimeout(() => {
                           const btn = document.getElementById(`btn-${hut.id}`);
                           if(btn) {
                               btn.onclick = () => {
                                    routeManager.toggleSelect(hut);
                                    marker.closePopup();
                                };
                           }
                            const swiperEl = marker.getPopup()?.getElement()?.querySelector('.popup-swiper');
                            if (swiperEl && !swiperEl.swiper) {
                                new Swiper(swiperEl, {
                                    loop: true,
                                    pagination: { el: '.swiper-pagination', clickable: true },
                                    navigation: {
                                        nextEl: '.swiper-button-next',
                                        prevEl: '.swiper-button-prev',
                                    },
                                });
                            }
                        }, 0);
                    });
                  mapManager.clusterGroup.addLayer(marker);
             });
        },

        loadHuts() {
            this.db.collection("eierhuetten").where("status", "==", "angenommen").onSnapshot(snapshot => {
                const huts = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.location) {
                       huts.push({ id: doc.id, ...data, lat: data.location.latitude, lng: data.location.longitude });
                    }
                });
                appState.allHuts = huts;
                this.displayHuts(huts);
                 localStorage.setItem('allHutsData', JSON.stringify(huts));
            }, err => {
                console.error("Fehler beim Laden der H√ºtten:", err);
                uiManager.showToast(i18nManager.getString('toast.hutsLoadingError'));
                this.loadOfflineHuts();
            });
        },

        rejoinLastRoom() {
            const lastRoomId = localStorage.getItem('lastRoomId');
            if(lastRoomId) {
                // Use confirm with translated text
                if(confirm(i18nManager.getString('toast.roomRejoin', { id: lastRoomId }))) {
                    this.joinRoom(lastRoomId);
                } else {
                    localStorage.removeItem('lastRoomId'); // Remove if user declines
                }
            }
        },

        async joinRoom(id = null) { // <-- NEU: async
            let roomId = id; // Start with ID from param (e.g., URL or rejoin)
            if (!roomId) {
                 // Only get from input if no ID was passed
                 roomId = document.getElementById('roomIdInput').value.trim();
            }

            // *** FIX: Check if roomId is empty ***
            if (!roomId) {
                uiManager.showToast(i18nManager.getString('toast.roomEnterId'));
                return; // Stop if no ID is provided
            }
            
            try {
                // NEU: Wir WARTEN (await), bis der Raum sicher erstellt/best√§tigt ist
                await this.db.collection("rooms").doc(roomId).set({
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }, { merge: true });
            } catch (err) {
                console.error("Fehler beim Erstellen/Sicherstellen des Raums:", err);
                uiManager.showToast("Fehler beim Beitreten des Raums.");
                return;
            }
            
            // Jetzt, da der Raum 100% existiert, k√∂nnen wir weitermachen
            appState.currentRoom.id = roomId;
            localStorage.setItem('lastRoomId', roomId);

            this.listenToRoom(roomId); // Dieser Listener wird jetzt doc.exists = true finden
            this.listenToUsersInRoom(roomId);

            // Wir rufen dies sofort auf, um die ID im UI anzuzeigen.
            // Die Listener werden den Rest (Guide-Status, User-Liste) nachladen.
            uiManager.updateRoomUI(appState.currentRoom, []); 

            uiManager.showToast(i18nManager.getString('toast.roomJoined', { id: roomId }));

             // NEU: Clear input field after successful join
            document.getElementById('roomIdInput').value = '';
        },

        leaveRoom() {
            if(appState.roomUnsubscribe) appState.roomUnsubscribe();
            if(appState.userPositionsUnsubscribe) appState.userPositionsUnsubscribe();

            localStorage.removeItem('lastRoomId');

            if(appState.currentRoom.id) {
                // Remove user from room positions
                this.db.collection('room_positions').doc(appState.currentRoom.id).collection('users').doc(userManager.userId).delete();
            }

            appState.currentRoom.id = null;
            appState.currentRoom.guideId = null;

            // Remove all group markers
            Object.keys(mapManager.groupMarkers).forEach(id => mapManager.removeGroupMarker(id));

            uiManager.updateRoomUI(appState.currentRoom);
            uiManager.showToast(i18nManager.getString('toast.roomLeft'));
        },

        listenToRoom(roomId) {
            if(appState.roomUnsubscribe) appState.roomUnsubscribe();
            appState.roomUnsubscribe = this.db.collection("rooms").doc(roomId).onSnapshot(doc => {
                const roomData = doc.data() || {};
                // If room doesn't exist (anymore), leave it client-side
                 if (!doc.exists) {
                    console.warn(`Room ${roomId} does not exist or was deleted.`);
                    this.leaveRoom(); // Automatically leave if room vanishes
                    return;
                }
                appState.currentRoom = {id: roomId, ...roomData};

                const isSelfGuide = userManager.userId === roomData.guideId;

                // Sync tour for non-guides
                if (!isSelfGuide) {
                    const hutIds = roomData.hutIds || [];
                    const localIds = appState.selectedHuts.map(h => h.id).join(',');
                    // Only update if different to avoid unnecessary recalculations
                    if (hutIds.join(',') !== localIds) {
                        appState.selectedHuts = hutIds.map(id => appState.allHuts.find(h => h.id === id)).filter(Boolean);
                        uiManager.updateSelectedList();
                        routeManager.recalculatePreviewRoute(); // Update preview for non-guides
                         uiManager.showToast(i18nManager.getString('toast.roomTourUpdated'));
                    }
                    // Sync navigation state for non-guides
                     if(roomData.isNavigating && !appState.isNavigating && roomData.guidedRoute) {
                        routeManager.routeData = roomData.guidedRoute;
                        mapManager.drawRoute(roomData.guidedRoute.coords);
                        uiManager.setNavigationState(true);
                        userManager.startWatchingPosition(); // Ensure follower starts watching
                    } else if (!roomData.isNavigating && appState.isNavigating && !isSelfGuide) {
                        // Stop navigation if guide stops AND you are not the guide
                        routeManager.stopNavigation();
                    }
                }
                uiManager.updateRoomUI(appState.currentRoom); // Update UI based on fetched room data
            }, error => {
                 console.error(`Error listening to room ${roomId}:`, error);
                 // Optionally handle specific errors, e.g., permissions
                 uiManager.showToast("Fehler beim Abrufen der Raumdaten.");
                 this.leaveRoom(); // Leave room on error
            });
        },

        listenToUsersInRoom(roomId) {
            if (appState.userPositionsUnsubscribe) appState.userPositionsUnsubscribe();
            appState.userPositionsUnsubscribe = this.db.collection('room_positions').doc(roomId).collection('users').onSnapshot(snapshot => {
                const activeUsers = [];
                const now = Date.now();
                const currentMemberIds = new Set();

                snapshot.forEach(doc => {
                    const user = doc.data();
                    const userId = doc.id;
                    currentMemberIds.add(userId);

                    // Check if user is self OR timestamp exists and is recent (within 60s)
                    if (userId !== userManager.userId && user.timestamp && (now - user.timestamp) < 60000) {
                        mapManager.updateGroupMarker({ id: userId, ...user });
                        activeUsers.push(user);
                    } else if (userId !== userManager.userId) {
                        // Remove marker if user is not self and timestamp is old or missing
                        mapManager.removeGroupMarker(userId);
                    }
                });

                // Clean up markers for users who left the room (are no longer in the snapshot)
                Object.keys(mapManager.groupMarkers).forEach(markerId => {
                    if (!currentMemberIds.has(markerId)) {
                        mapManager.removeGroupMarker(markerId);
                    }
                });

                // Update the UI list of active users
                uiManager.updateRoomUI(appState.currentRoom, activeUsers);
            }, error => {
                console.error(`Error listening to users in room ${roomId}:`, error);
                // Handle error, maybe show a toast
            });
        },

        updateUserPositionInRoom(pos) {
            if(!appState.currentRoom.id) return;
            const name = this.displayName; // Verwendet jetzt den gespeicherten Google-Namen
          const colors = ['#e11d48', '#2563eb', '#16a34a', '#f97316', '#9333ea'];
            // Simple hash function to get a consistent color index
            let hash = 0;
            for (let i = 0; i < userManager.userId.length; i++) {
                hash = userManager.userId.charCodeAt(i) + ((hash << 5) - hash);
            }
            const colorIndex = Math.abs(hash % colors.length);
            const color = colors[colorIndex];

            this.db.collection('room_positions').doc(appState.currentRoom.id).collection('users').doc(userManager.userId).set({
                lat: pos.lat,
                lng: pos.lng,
                name: name,
                color: color,
                timestamp: Date.now() // Use server timestamp if needed, but client timestamp is okay for presence
            }, { merge: true }); // Use merge to avoid overwriting other fields if any
        },

        updateRoomHuts() {
            if(!appState.currentRoom.id) return;
            const hutIds = appState.selectedHuts.map(h => h.id);
            this.db.collection("rooms").doc(appState.currentRoom.id).set({ hutIds }, { merge: true });
        },

        setGuide() {
            if(!appState.currentRoom.id) return;
            let newGuideId = userManager.userId;
            let newGuideName = userManager.displayName; // Verwendet jetzt den gespeicherten Google-Namen
          
            if (appState.currentRoom.guideId === userManager.userId) { // If self is guide, relinquish role
                newGuideId = null;
                newGuideName = null;
                 firebaseManager.updateGuidedRoute(false, null); // Stop guided navigation if resigning
            } else if (appState.currentRoom.guideId) { // If someone else is guide
                uiManager.showToast(i18nManager.getString('toast.guideExists'));
                return; // Only allow setting if no guide or self
            }
            // If no guide, become the guide
            this.db.collection("rooms").doc(appState.currentRoom.id).set({ guideId: newGuideId, guideName: newGuideName }, { merge: true });
        },

        updateGuidedRoute(isNavigating, routeData) {
            if(!appState.currentRoom.id) return;
            this.db.collection("rooms").doc(appState.currentRoom.id).set({
                isNavigating: isNavigating,
                 // Ensure routeData is serializable, null if not navigating
                guidedRoute: isNavigating && routeData ? JSON.parse(JSON.stringify(routeData)) : null,
            }, { merge: true });
        },
        deleteWarning(warningId) {
            if(confirm("Ist diese Gefahr wirklich nicht mehr aktuell?")) {
                this.db.collection('warnings').doc(warningId).delete()
                    .then(() => uiManager.showToast("Meldung entfernt."));
            }
        },
        addWarning() {
            const type = document.getElementById('warning-type').value;
            const description = document.getElementById('warning-description').value;
            const latlng = uiManager.tempWarningLatLng;
            if(!latlng) return;

            this.db.collection('warnings').add({
                lat: latlng.lat,
                lng: latlng.lng,
                type: type,
                description: description,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                userId: userManager.userId, // Optionally store who reported it
            }).then(() => {
                uiManager.showToast(i18nManager.getString('toast.warningReported'));
                uiManager.hideAddWarningModal();
            }).catch(error => {
                 console.error("Error adding warning:", error);
                 uiManager.showToast("Fehler beim Melden der Gefahr."); // Add generic error toast
            });
        },

       listenToWarnings() {
            // Get timestamp for 24 hours ago
            const twentyFourHoursAgoTimestamp = firebase.firestore.Timestamp.fromMillis(Date.now() - (24 * 60 * 60 * 1000));

            this.db.collection('warnings')
               .where('createdAt', '>', twentyFourHoursAgoTimestamp) // Query directly in Firestore for recent warnings
               .onSnapshot(snapshot => {
                    const currentWarningIds = new Set();
                    appState.allWarnings = []; // Clear current warnings

                    snapshot.forEach(doc => {
                        const warning = { id: doc.id, ...doc.data() };
                        // Ensure createdAt is a Date object
                        if (warning.createdAt && warning.createdAt.toDate) {
                           warning.createdAt = warning.createdAt.toDate();
                        } else {
                            // Handle cases where createdAt might not be a Firestore timestamp (e.g., fallback)
                            warning.createdAt = new Date();
                        }

                        // Additional check just in case Firestore query isn't perfect
                        // Although 'where' clause should handle this
                        // if (warning.createdAt.getTime() > twentyFourHoursAgoTimestamp.toMillis()) {
                            appState.allWarnings.push(warning);
                            currentWarningIds.add(warning.id);
                            // Add marker if it doesn't exist
                            if (!mapManager.warningMarkers[warning.id]) {
                               mapManager.addWarningMarker(warning);
                            }
                        // }
                    });

                    // Remove markers for warnings that are no longer in the snapshot (expired or deleted)
                    Object.keys(mapManager.warningMarkers).forEach(markerId => {
                        if (!currentWarningIds.has(markerId)) {
                            mapManager.removeWarningMarker(markerId);
                        }
                    });
                    // Clean up the warnedAbout set for warnings that no longer exist
                    userManager.warnedAbout.forEach(warnedId => {
                        if (!currentWarningIds.has(warnedId)) {
                            userManager.warnedAbout.delete(warnedId);
                        }
                    });
            }, error => {
                 console.error("Error listening to warnings:", error);
                 // Handle error, maybe show a toast
            });
        },
      // NEU: Speichert die aktuelle Tour f√ºr den eingeloggten Nutzer
    saveUserTour(tourName) {
        if (!userManager.userId) {
            uiManager.showToast("Fehler: Nicht eingeloggt.");
            return;
        }
        if (appState.selectedHuts.length === 0) {
            uiManager.showToast("Bitte w√§hle zuerst Stopps f√ºr die Tour.");
            return;
        }

        const hutIds = appState.selectedHuts.map(hut => hut.id);

        const tourData = {
            userId: userManager.userId,
            name: tourName,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            hutIds: hutIds, // Array von Hut-IDs
            hutNames: appState.selectedHuts.map(hut => hut.name) // Zur Vorschau
        };

        this.db.collection('user_tours').add(tourData)
            .then(() => {
                uiManager.showToast("Tour '" + tourName + "' gespeichert!");
            })
            .catch(err => {
                console.error("Fehler beim Speichern der Tour:", err);
                uiManager.showToast("Fehler beim Speichern.");
            });
    },

    // NEU: L√§dt die Touren des Nutzers und zeigt sie im Statistik-Tab an
    async loadUserTours() {
        const statsListEl = document.getElementById('stats-list');
        if (!statsListEl || !userManager.userId) {
            if (statsListEl) statsListEl.innerHTML = `<p>Bitte einloggen, um Touren zu sehen.</p>`;
            return;
        }

        statsListEl.innerHTML = `<p>${i18nManager.getString('stats.loading')}</p>`;

        try {
            const snapshot = await this.db.collection('user_tours')
                .where('userId', '==', userManager.userId)
                .orderBy('createdAt', 'desc')
                .get();

            if (snapshot.empty) {
                statsListEl.innerHTML = `<p>Du hast noch keine Touren gespeichert.</p>`;
                return;
            }

            statsListEl.innerHTML = snapshot.docs.map(doc => {
                const tour = doc.data();
                const tourId = doc.id;
                const date = tour.createdAt.toDate().toLocaleDateString(appState.currentLang, { day: '2-digit', month: '2-digit' });

                return `
                    <div class="p-3 rounded-lg bg-gray-100 dark:bg-gray-700 space-y-2">
                        <div class="flex justify-between items-center">
                            <span class="font-semibold">${tour.name} <span class="text-xs text-gray-500">(${date})</span></span>
                            <button onclick="firebaseManager.deleteUserTour('${tourId}')" class="p-1 text-red-500 hover:text-red-700">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mt-1">${tour.hutNames.join(' ‚Üí ')}</p>
                        <button onclick="firebaseManager.loadTourByIds(['${tour.hutIds.join("','")}'])" class="w-full bg-green-500 text-white p-2 rounded-lg text-sm font-medium hover:bg-green-600 transition">
                            Tour laden
                        </button>
                    </div>
                `;
            }).join('');

        } catch (error) {
            console.error("Fehler beim Laden der Touren:", error);
            statsListEl.innerHTML = `<p>Fehler beim Laden der Touren.</p>`;
        }
    },

    // NEU: L√§dt eine gespeicherte Tour in den aktuellen Status
    loadTourByIds(hutIds) {
        // Finde die vollen Hut-Objekte aus dem globalen appState.allHuts
        const loadedHuts = hutIds.map(id => 
            appState.allHuts.find(hut => hut.id === id)
        ).filter(Boolean); // .filter(Boolean) entfernt alle "undefined", falls eine H√ºtte gel√∂scht wurde

        if (loadedHuts.length !== hutIds.length) {
            uiManager.showToast("Einige Stopps dieser Tour existieren nicht mehr.");
        }

        if (loadedHuts.length > 0) {
            appState.selectedHuts = loadedHuts;
            uiManager.updateSelectedList();
            routeManager.recalculatePreviewRoute();
            uiManager.showToast("Tour geladen!");

            // Zum Tour-Tab wechseln und Sidebar schlie√üen (optional, aber n√ºtzlich)
            document.querySelector('.tab-btn[data-tab="tab-tour"]').click();
            if (appState.isSidebarOpen) {
                uiManager.toggleSidebar();
            }
        } else {
            uiManager.showToast("Konnte Tour nicht laden.");
        }
    },

    // NEU: L√∂scht eine gespeicherte Tour
    deleteUserTour(tourId) {
        if (!tourId || !confirm("M√∂chtest du diese gespeicherte Tour wirklich l√∂schen?")) {
            return;
        }

        this.db.collection('user_tours').doc(tourId).delete()
            .then(() => {
                uiManager.showToast("Tour gel√∂scht.");
                this.loadUserTours(); // Liste neu laden
            })
            .catch(err => {
                console.error("Fehler beim L√∂schen der Tour:", err);
                uiManager.showToast("Fehler beim L√∂schen.");
            });
    },

       saveTourLog(routeData, selectedHuts, visitedStops) {
            if (!routeData || !userManager.userId) {
                console.warn("Cannot save tour log: Missing route data or user ID.");
                return;
            }

            const logData = {
                userId: userManager.userId,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                distance: routeData.distance || 0, // Ensure distance is a number
                duration: routeData.duration || 0, // Ensure duration is a number
                stops: selectedHuts.map(hut => hut.name),
                stopsVisited: visitedStops.size,
                // Optionally add start/end coordinates, average speed etc. later
            };

            // Reference to the user's specific 'tours' subcollection
            const statsCollection = this.db.collection('user_stats').doc(userManager.userId).collection('tours');

            statsCollection.add(logData)
                .then(docRef => console.log("Tour-Log gespeichert mit ID:", docRef.id))
                .catch(err => console.error("Fehler beim Speichern des Tour-Logs:", err));
        },

        async loadTourLogs() {
            const statsListEl = document.getElementById('stats-list');
            if (!statsListEl || !userManager.userId) return;

            statsListEl.innerHTML = `<p>${i18nManager.getString('stats.loading')}</p>`;

            try {
                const statsCollection = this.db.collection('user_stats').doc(userManager.userId).collection('tours');
                // Fetch and order client-side to avoid needing Firestore index initially
                const snapshot = await statsCollection.get();

                if (snapshot.empty) {
                    statsListEl.innerHTML = `<p>${i18nManager.getString('stats.empty')}</p>`;
                    return;
                }

                const logs = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.createdAt && data.createdAt.toDate) {
                        data.createdAt = data.createdAt.toDate();
                    } else {
                        data.createdAt = new Date(); // Fallback if timestamp is missing/invalid
                    }
                    logs.push(data);
                });

                // Sort logs by date, newest first
                logs.sort((a, b) => b.createdAt - a.createdAt);

                // Limit to latest 20 logs for performance
                 const recentLogs = logs.slice(0, 20);

                statsListEl.innerHTML = recentLogs.map(log => {
                    const date = log.createdAt.toLocaleDateString(appState.currentLang, { day: '2-digit', month: '2-digit', year: 'numeric' });
                    const distanceKm = (log.distance / 1000).toFixed(1);
                    const durationMin = Math.round(log.duration / 60);

                    return `
                        <div class="p-3 rounded-lg bg-gray-100 dark:bg-gray-700">
                            <p class="font-semibold">${date}</p>
                            <p class="text-sm text-gray-600 dark:text-gray-300">
                                ${distanceKm} km | ${durationMin} min | ${log.stopsVisited} / ${log.stops.length} ${i18nManager.getString('stats.tourCard.stops')}
                            </p>
                            <p class="text-xs text-gray-500 mt-1">${log.stops.join(', ')}</p>
                        </div>
                    `;
                }).join('');

            } catch (error) {
                console.error("Fehler beim Laden der Statistiken:", error);
                statsListEl.innerHTML = `<p>Fehler beim Laden der Statistiken.</p>`; // Keep error message generic
            }
        }
    };

    const dragAndDrop = { /* Drag and Drop code - see previous version, uses i18nManager */
        draggedIndex: null,
        start(event, index) {
            this.draggedIndex = index;
            event.dataTransfer.effectAllowed = 'move';
        },
        drop(event, targetIndex) {
            event.preventDefault();
            if (this.draggedIndex === null || this.draggedIndex === targetIndex) return;

            const draggedItem = appState.selectedHuts.splice(this.draggedIndex, 1)[0];
            appState.selectedHuts.splice(targetIndex, 0, draggedItem);

            this.draggedIndex = null;
            uiManager.updateSelectedList();

            if (appState.isNavigating) {
                uiManager.showToast(i18nManager.getString('toast.routeUpdating'));
                routeManager.startNavigation();
            } else {
                routeManager.recalculatePreviewRoute();
            }

            if (appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        }
     };

    const weatherManager = { /* Weather manager code - see previous version, uses i18nManager */
        lastFetchTime: 0,
        currentWeather: null,

        async fetchWeather(lat, lng) {
            const now = Date.now();
            if (now - this.lastFetchTime < 10 * 60 * 1000) return;
            this.lastFetchTime = now;

            if (!navigator.onLine) return;

            try {
                // NEU: URL erweitert um &hourly=...&forecast_days=1
                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true&hourly=temperature_2m,weathercode,windspeed_10m&forecast_days=1`);
                const data = await response.json();
                
                // NEU: Speichere die gesamten Daten (inkl. hourly)
                if(data) {
                    this.currentWeather = data; 
                    if (data.current_weather) {
                        this.updateWidget(data.current_weather);
                    }
                }
            } catch (error) {
                console.error("Fehler beim Laden des Wetters:", error);
            }
        },
              updateWidget(weather) {
            // this.currentWeather = weather; // <-- ENTFERNT! Das ist der Bugfix f√ºr die Stundenvorschau.
            
            const icon = this.getWeatherIcon(weather.weathercode);
            const temp = Math.round(weather.temperature);

            // NEU: Steuert die korrekten IDs an, die wir in Schritt 1.1 erstellt haben
            document.getElementById('weather-icon').textContent = icon;
            document.getElementById('weather-temp').textContent = `${temp}¬∞C`;
        },

  

        
        getWeatherIcon(code) {
            if (code === 0) return '‚òÄÔ∏è'; // Clear sky
            if (code >= 1 && code <= 3) return '‚õÖÔ∏è'; // Mainly clear, partly cloudy, overcast
            if (code === 45 || code === 48) return 'üå´Ô∏è'; // Fog
            if (code >= 51 && code <= 57) return 'üå¶Ô∏è'; // Drizzle
            if (code >= 61 && code <= 67) return 'üåßÔ∏è'; // Rain
            if (code >= 71 && code <= 77) return '‚ùÑÔ∏è'; // Snow fall
            if (code >= 80 && code <= 82) return '‚õàÔ∏è'; // Rain showers
            if (code >= 85 && code <= 86) return 'üå®Ô∏è'; // Snow showers Slight and heavy
            if (code >= 95 && code <= 99) return 'üå©Ô∏è'; // Thunderstorm
            return '-'; // Default
        },
        async fetchElevation(coordinates) {
            // ... (deine bestehende fetchElevation Funktion) ...
        },

        // NEU: Diese Funktion hinzuf√ºgen
        showHourlyForecast() {
            if (!this.currentWeather || !this.currentWeather.hourly || !this.currentWeather.current_weather) {
                uiManager.showToast(i18nManager.getString('general.loading')); // Zeige "Lade..."
                return;
            }

            try {
                const hourlyData = this.currentWeather.hourly;
                const currentTime = this.currentWeather.current_weather.time;
                
                // Finde den Index der aktuellen Stunde in den st√ºndlichen Daten
                const currentIndex = hourlyData.time.findIndex(t => t.startsWith(currentTime.substring(0, 13)));

                if (currentIndex === -1) {
                    console.error("Konnte aktuelle Stunde in Wetterdaten nicht finden.", currentTime, hourlyData.time);
                    uiManager.showToast("Fehler bei Wettervorschau.");
                    return;
                }

                const forecastHours = [];
                // Sammle die n√§chsten 4 Stunden
                for (let i = 1; i <= 4; i++) {
                    const index = currentIndex + i;
                    if (index >= hourlyData.time.length) break; // Nicht √ºber das Array-Ende hinausgehen
                    forecastHours.push({
                        time: hourlyData.time[index],
                        temp: Math.round(hourlyData.temperature_2m[index]),
                        code: hourlyData.weathercode[index],
                        wind: Math.round(hourlyData.windspeed_10m[index]) // Windgeschwindigkeit
                    });
                }

                if (forecastHours.length === 0) {
                     uiManager.showToast("Keine Vorschau verf√ºgbar.");
                     return;
                }

                // Generiere HTML f√ºr das Popup
                let htmlContent = '<div class="space-y-3">';
                forecastHours.forEach(hour => {
                    // Zeit basierend auf der App-Sprache formatieren
                    const hourString = new Date(hour.time).toLocaleTimeString(appState.currentLang, { hour: '2-digit', minute: '2-digit' });
                    const icon = this.getWeatherIcon(hour.code);
                    
                    htmlContent += `
                        <div class="flex items-center justify-between p-2 rounded-lg bg-gray-100 dark:bg-gray-700 gap-2">
                            <span class="font-bold text-lg w-16 flex-shrink-0">${hourString}</span>
                            <span class="text-2xl flex-shrink-0">${icon}</span>
                            <span class="text-lg font-semibold w-16 text-center flex-shrink-0">${hour.temp}¬∞C</span>
                            <span class="text-sm text-gray-600 dark:text-gray-300 w-24 text-right flex-shrink-0">üí® ${hour.wind} km/h</span>
                        </div>`;
                });
                htmlContent += '</div>';
                
                                // √ñffne das Popup (das sich durch Klick daneben schlie√üt)
                // NEU: Verwende i18n f√ºr den Titel
                uiManager.openPopup(i18nManager.getString("popup.weatherTitle"), htmlContent);

            } catch (error) {
                console.error("Fehler beim Erstellen der Wettervorschau:", error);
                uiManager.showToast("Fehler bei Wettervorschau.");
            }
        }
    }; // (Stelle sicher, dass dies die schlie√üende Klammer des weatherManager-Objekts ist)
// ==========================================================
//  6. INITIALISIERUNG (KORRIGIERTE VERSION)
// ==========================================================
document.addEventListener('DOMContentLoaded', () => {

    // C. UI & √úbersetzungen ZUERST initialisieren (nur Kernfunktionen)
    uiManager.initCore();

    // A. Firebase zentral initialisieren
    let firebaseInitialized = false;
    try {
        // Im ersten 'try' NUR die App initialisieren
        firebase.initializeApp(config.firebase);
        firebaseInitialized = true; // Hat geklappt
    } catch (e) {
        console.error("Firebase Init Fehler:", e);
        const errorElement = document.getElementById('authError');
        if (errorElement) errorElement.textContent = "Firebase Init Fehler: " + e.message;

        // Login-Screen anzeigen und Lade-Spinner stoppen
        document.getElementById("loginScreen").classList.remove("hidden");
        uiManager.setLoading(false);
        // WICHTIG: Hier abbrechen. Ohne Firebase funktioniert nichts.
        // Die Login-Formulare werden NICHT aktiviert.
        return; 
    }

    // D. & E. ALLES ANDERE nur ausf√ºhren, wenn Firebase erfolgreich initialisiert wurde
    if (firebaseInitialized) {
        
        // JETZT die Dienste initialisieren
        firebaseManager.db = firebase.firestore();

        // B. Login-Formulare aktivieren
        setupAuthForms(); // <--- JETZT HIER INNEN
        userManager.setupBatteryListener();

        // D. Ladebildschirm anzeigen
        uiManager.setLoading(true, i18nManager.getString('loader.text'));

        // E. Auth-Status-Listener (Der "Gatekeeper")
        // (Initialisiert den Auth-Dienst beim ersten Aufruf)
        firebase.auth().onAuthStateChanged(user => {
            if (user) {
                // ---- BENUTZER IST EINGELOGGT ----
                console.log("User logged in:", user.email);

                // 1. UI umschalten
                document.getElementById("loginScreen").classList.add("hidden");
                document.getElementById("mainApp").classList.remove("hidden");

                // 2. Einen Logout-Button zum Profil-Tab hinzuf√ºgen
                const profileTab = document.getElementById('tab-nutzer');
                if (profileTab && !document.getElementById('logoutBtn')) { // Pr√ºfen, ob schon vorhanden
                    const logoutBtn = document.createElement('button');
                    logoutBtn.id = 'logoutBtn';
                    logoutBtn.innerHTML = 'Logout';
                    logoutBtn.className = 'w-full bg-gray-500 hover:bg-gray-600 text-white p-2 rounded-lg text-sm font-medium mt-4';
                    logoutBtn.onclick = () => firebase.auth().signOut();
                    profileTab.appendChild(logoutBtn);
                }

                // 3. Die RadlMap-App initialisieren
                mapManager.init(config.map.defaultCenter, config.map.defaultZoom);

                firebaseManager.init();

                // NEU: UI-Elemente der Haupt-App JETZT ERST initialisieren
                uiManager.initMainAppUI();

                // KORRIGIERTER AUFRUF: mit uid und displayName
                userManager.init(user.uid, user.displayName);

                // FINALER CODE (mit Routen-Trigger)
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'visible') {
                        console.log("Tab wieder sichtbar. Aktualisiere Standort & Routenf√ºhrung...");
                        
                        userManager.getCurrentPosition(true).then(pos => {
                            // 1. Marker sofort mit der LETZTEN bekannten Peilung aktualisieren
                            if (mapManager.userMarker) {
                                mapManager.updateUserMarker(pos, 20, userManager.lastBearing || 0);
                            }

                            // 2. Wichtige globale Position aktualisieren
                            // Dies ist wichtig f√ºr die n√§chste Peilungsberechnung im watchPosition
                            userManager.lastPosition = pos; 

                            // 3. Wenn wir navigieren (oder folgen), sanft hinfliegen
                            if (appState.isNavigating || appState.isFollowing) {
                                if (mapManager.map) {
                                    mapManager.map.flyTo(pos, config.map.navigationZoom, {
                                        duration: 1.5 
                                    });
                                }
                            }

                            // 4. ROUTENF√úHRUNG SOFORT TRIGGERN (Das ist der neue Teil)
                            if (appState.isNavigating) {
                                console.log("Trigger Routen-Check (Man√∂ver & Abweichung)");
                                
                                // Manuell die Routenlogik mit der neuen Position ansto√üen,
                                // um nicht auf den n√§chsten "watchPosition"-Tick warten zu m√ºssen.
                                routeManager.checkNextManeuver(pos);
                                routeManager.checkDeviation(pos);
                            }

                            // 5. Restliche Updates
                            weatherManager.fetchWeather(pos.lat, pos.lng);
                            if (appState.currentRoom.id) {
                                firebaseManager.updateUserPositionInRoom(pos);
                            }
                        }).catch(err => {
                            console.warn("Position beim Reaktivieren des Tabs nicht verf√ºgbar:", err);
                        });
                    }
                });

                
                const urlParams = new URLSearchParams(window.location.search);
                const roomIdFromUrl = urlParams.get('room');
                if (roomIdFromUrl) {
                    setTimeout(() => {
                         firebaseManager.joinRoom(roomIdFromUrl);
                         window.history.replaceState({}, document.title, window.location.pathname);
                    }, 1500);
                }
                 else {
                    firebaseManager.rejoinLastRoom();
                }

            } else {
                // ---- BENUTZER IST AUSGELOGGT ----
                console.log("User logged out.");

                // 1. UI umschalten
                document.getElementById("loginScreen").classList.remove("hidden");
                document.getElementById("mainApp").classList.add("hidden");

                // 2. Lade-Overlay der Karte ausblenden
                uiManager.setLoading(false);
            }
        });
    } // Ende von if (firebaseInitialized)
});




    // --- In-App Konsole (Version 2: F√§ngt alle Fehler) ---
(function() {
  // üëâ hier kannst du die Konsole global aktivieren/deaktivieren
  const ENABLE_APP_CONSOLE = true;  // auf false setzen = deaktiviert

  if (!ENABLE_APP_CONSOLE) return; // komplett abschalten

  const consoleDiv = document.createElement("div");
  consoleDiv.id = "appConsole";
  consoleDiv.style.cssText = `
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    max-height: 200px;
    overflow-y: auto;          /* Scrollbalken aktiv */
    background: rgba(0,0,0,0.85);
    color: #0f0;
    font-family: monospace;
    font-size: 12px;
    padding: 5px;
    z-index: 9999;
    display: none;             /* startet versteckt */
    box-sizing: border-box;
    user-select: text;      /* Markieren/Kopieren erlaubt */
    cursor: text;           /* Cursor als Textanzeige */
  `;
  document.body.appendChild(consoleDiv);

  // Toggle-Button
  const toggleBtn = document.createElement("button");
  toggleBtn.textContent = "üìù Logs";
  toggleBtn.style.cssText = `
    position: fixed;
    bottom: 210px;
    right: 10px;
    padding: 5px 10px;
    background: #222;
    color: white;
    border: 1px solid #555;
    border-radius: 6px;
    font-size: 14px;
    z-index: 10000;
    cursor: pointer;
  `;
  document.body.appendChild(toggleBtn);

  let consoleVisible = false;
  toggleBtn.onclick = () => {
    consoleVisible = !consoleVisible;
    consoleDiv.style.display = consoleVisible ? "block" : "none";
    toggleBtn.textContent = consoleVisible ? "üìï Logs schlie√üen" : "üìù Logs";
  };

  /**
   * Formatiert Argumente f√ºr die Konsolenausgabe.
   * Error-Objekte werden mit ihrem Stack Trace angezeigt.
   */
  function formatArgs(args) {
    return args.map(a => {
      if (a instanceof Error) {
        // Wenn es ein Error-Objekt ist, zeige den Stack!
        return a.stack || a.message;
      }
      if (typeof a === "object" && a !== null) {
        try {
          return JSON.stringify(a, null, 2); // Objekte sch√∂n formatieren
        } catch (e) {
          return "[Unserializable Object]";
        }
      }
      return String(a); // Normale Strings, Zahlen etc.
    }).join(" ");
  }

  function printToConsole(type, args) {
    const msg = document.createElement("div");
    msg.style.whiteSpace = "pre-wrap"; // Wichtig f√ºr Zeilenumbr√ºche (z.B. im Stack Trace)
    msg.style.wordBreak = "break-all"; // Bricht lange Zeilen um
    msg.style.padding = "2px 0";
    msg.style.borderBottom = "1px solid #333";
    msg.style.color =
      type === "error" ? "#ff8a8a" : // Helleres Rot
      type === "warn"  ? "#f6e05e" : // Gelb
      "#50fa7b"; // Helleres Gr√ºn

    // Verwende die neue formatArgs-Funktion
    msg.textContent = `[${type.toUpperCase()}] ` + formatArgs(args);
    consoleDiv.appendChild(msg);

    // automatisch nach unten scrollen
    consoleDiv.scrollTop = consoleDiv.scrollHeight;
  }

  // Original-Methoden sichern
  const origLog = console.log;
  const origWarn = console.warn;
  const origError = console.error;

  console.log = function(...args) {
    origLog.apply(console, args); // An echte Konsole weiterleiten
    printToConsole("log", args);
  };
  console.warn = function(...args) {
    origWarn.apply(console, args); // An echte Konsole weiterleiten
    printToConsole("warn", args);
  };
  console.error = function(...args) {
    origError.apply(console, args); // An echte Konsole weiterleiten
    printToConsole("error", args);
  };

  console.log("üü¢ In-App Konsole gestartet (f√§ngt jetzt alle Fehler).");

  // üëâ F√§ngt normale JavaScript-Fehler ab (AKTIVIERT)
  window.addEventListener("error", function (event) {
    // Formatiere die Fehlermeldung mit Dateiname und Zeilennummer
    const filename = event.filename.substring(event.filename.lastIndexOf('/') + 1);
    const errorMsg = `Uncaught Error: ${event.message}\n@ ${filename}:${event.lineno}:${event.colno}`;
    
    // Sende den formatierten String an unser `console.error`
    console.error(errorMsg); 
  });

  // üëâ F√§ngt Promise-Fehler (async/await) ab (AKTIVIERT)
  window.addEventListener("unhandledrejection", function (event) {
    let reason = event.reason;
    if (reason instanceof Error) {
      // Wenn der Grund ein Error ist, nutze den Stack Trace
      reason = reason.stack || reason.message;
    } else {
      reason = JSON.stringify(reason);
    }
    
    console.error(`Unhandled Promise Rejection:\n${reason}`);
  });
})();
  </script>
</body>
              </html>
