<!DOCTYPE html>
<!-- Sprachattribut wird dynamisch gesetzt -->
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <!-- Titel wird dynamisch gesetzt -->
  <title data-i18n="app.title">RadlMap Navigation 🚲 (Smarter)</title>

  <!-- Meta Tags für Social Media Vorschau -->
  <meta property="og:title" content="🏠🚲 RadlMap Tourplaner" />
  <meta property="og:description" content="Plane deine nächste Radtour mit Hütten! Mit Live-GPS, Tourenspeicher, Gruppenfunktion & mehr." />
  <meta property="og:image" content="https://radlmap.net/img/preview.png" />
  <meta property="og:url" content="https://radlmap.net" />
  <meta name="twitter:card" content="summary_large_image" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🚲</text></svg>">

  <!-- Externe Bibliotheken -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>
  <script src="https://unpkg.com/@mapbox/polyline"></script>
  <link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"/>
  <script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script>
  <script src="https://unpkg.com/leaflet-geometryutil"></script> <!-- Library for distance calculations -->

  <!-- Chart.js für Höhenprofil -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


  <style>
    /* Inter Schriftart */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      -webkit-tap-highlight-color: transparent;
    }

    #map {
      height: 100%;
      width: 100%;
      background: #f0f0f0;
      z-index: 1;
    }

    /* Lade-Overlay */
    #loader {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(8px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease;
    }
    .loader-spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-left-color: #2563eb;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Dark Mode Variablen & Übergänge */
    :root {
      --bg-color: #ffffff;
      --text-color: #1f2937;
      --ui-bg: rgba(255, 255, 255, 0.85);
      --border-color: #e5e7eb;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .dark {
      --bg-color: #111827;
      --text-color: #f9fafb;
      --ui-bg: rgba(31, 41, 55, 0.85);
      --border-color: #374151;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    body, .ui-element {
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .leaflet-popup-content-wrapper, .leaflet-popup-tip {
      background: var(--ui-bg) !important;
      color: var(--text-color) !important;
      backdrop-filter: blur(10px);
      border-radius: 12px;
    }
     .leaflet-popup-content {
        margin: 0 !important;
        line-height: 1.5;
        width: 300px !important;
    }


    /* Toast-Nachrichten */
    #toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #1f2937;
      color: white;
      padding: 10px 20px;
      border-radius: 9999px;
      font-size: 14px;
      z-index: 9000;
      box-shadow: var(--shadow);
      opacity: 0;
      transition: transform 0.4s ease, opacity 0.4s ease;
      pointer-events: none;
    }
    #toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* Haupt-Toolbar */
    #toolbar {
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      background: var(--ui-bg);
      border: 1px solid var(--border-color);
    }
    #toolbar button {
      transition: background-color 0.2s, transform 0.1s;
    }
    #toolbar button:active {
      transform: scale(0.95);
    }

    /* Seitenleisten-Panel */
    #sidebar-panel {
        position: fixed;
        top: 0;
        right: 0;
        height: 100%;
        width: 320px;
        max-width: 90vw;
        background: var(--bg-color);
        z-index: 5000;
        transform: translateX(100%);
        transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        box-shadow: -10px 0 25px rgba(0,0,0,0.1);
        border-left: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
    }
    #sidebar-panel.open {
        transform: translateX(0);
    }
    #sidebar-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.4);
        z-index: 4999;
        opacity: 0;
        transition: opacity 0.4s ease;
        pointer-events: none;
    }
    #sidebar-panel.open + #sidebar-overlay {
        opacity: 1;
        pointer-events: auto;
    }

    /* Verbesserte Scrollbars */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
    .dark ::-webkit-scrollbar-thumb { background: #555; }

    /* Navigations-Hinweise */
    #navHint {
        position: absolute;
        top: 80px;
        left: 50%;
        backdrop-filter: blur(10px);
        box-shadow: var(--shadow);
        border: 1px solid var(--border-color);
        transition: transform 0.4s ease, opacity 0.4s ease;
        transform: translate(-50%, 50px);
        opacity: 0;
        font-size: 1.2rem;
        font-weight: 600;
        pointer-events: auto;
    }
     #navHint.visible {
        transform: translate(-50%, 0);
        opacity: 1;
    }

    /* User Marker Animation */
    @keyframes pulse {
      0% { r: 0; opacity: 0.6; }
      100% { r: 40; opacity: 0; }
    }
    .pulse-circle {
      animation: pulse 2s infinite ease-out;
    }

    /* Popup Styling */
    .popup-card {
        font-size: 0.9rem;
        overflow: hidden;
    }
    .popup-content-area {
        max-height: 250px;
        overflow-y: auto;
        padding: 1rem;
        scrollbar-width: thin;
        scrollbar-color: #888 transparent;
    }
     .popup-content-area::-webkit-scrollbar { width: 5px; }
    .popup-content-area::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
     .dark .popup-content-area::-webkit-scrollbar-thumb { background: #555; }
    .dark .popup-content-area { scrollbar-color: #555 transparent; }


    .popup-swiper img {
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
        width: 100%;
        height: 150px;
        object-fit: cover;
    }
     .popup-button-container {
        padding: 0.5rem 1rem 1rem 1rem;
        border-top: 1px solid var(--border-color);
        background: var(--ui-bg);
    }

    .group-marker {
        text-align: center;
        font-weight: bold;
        color: #fff;
    }

    .hutten-bubble {
        background: rgba(255, 255, 255, 0.8);
        border: none;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 10px;
        font-weight: 600;
        color: #333;
    }
    .dark .hutten-bubble {
        background: rgba(31, 41, 55, 0.8);
        color: #f9fafb;
    }
    .warning-icon {
        background: none;
        border: none;
        font-size: 20px;
    }
     .leaflet-div-icon {
        background: none;
        border: none;
    }

    /* Offline-Indikator */
    #offline-indicator {
        animation: pulse-offline 2s infinite;
    }
    @keyframes pulse-offline {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Öffnungszeiten-Liste */
    .oeffnungszeiten-list {
        list-style: none;
        padding-left: 0;
        margin: 0;
        font-size: 0.85rem;
    }
    .oeffnungszeiten-list li {
        padding: 2px 0;
        display: flex;
    }
    .oeffnungszeiten-list li .tag {
        font-weight: 600;
        min-width: 3rem;
        margin-right: 0.5rem;
        display: inline-block;
        flex-shrink: 0;
    }
    .oeffnungszeiten-list li .zeit {
        display: inline-block;
    }

    /* Smart SOS Modal */
    #sos-modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(5px);
        z-index: 9980;
        display: flex; /* Changed from default */
        align-items: center;
        justify-content: center;
        padding: 1rem;
        opacity: 1; /* Ensure visible */
         transition: opacity 0.3s ease-in-out; /* Add transition */
    }
    /* Add hidden state style */
     #sos-modal-overlay.hidden {
         opacity: 0;
         pointer-events: none; /* Prevent interaction when hidden */
     }

     #sos-modal-content {
        background-color: var(--bg-color);
        color: var(--text-color);
        border-radius: 1rem; /* 16px */
        padding: 1.5rem; /* 24px */
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        max-width: 400px;
        width: 100%;
        transform: scale(1); /* Start scale */
         transition: transform 0.3s ease-in-out; /* Add transition */
    }
     /* Add hidden state style */
     #sos-modal-overlay.hidden #sos-modal-content {
         transform: scale(0.95); /* Slightly shrink when hiding */
     }


  </style>
</head>
<body class="antialiased">

  <!-- Ladebildschirm -->
  <div id="loader">
    <div class="loader-spinner"></div>
    <p class="mt-4 text-gray-600" data-i18n="loader.text">Karte wird geladen...</p>
  </div>

  <!-- Karten-Container -->
  <div id="map"></div>

  <!-- Toast Element -->
  <div id="toast"></div>

  <!-- UI Elemente oben rechts -->
  <div class="absolute top-4 right-4 z-10 space-y-3">
    <button onclick="uiManager.toggleSidebar()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
    </button>
     <button id="theme-toggle-btn" onclick="uiManager.toggleTheme()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
        <!-- Icon wird per JS gesetzt -->
    </button>
  </div>

  <!-- Wetter & KMH Widgets oben links -->
  <div class="absolute top-4 left-4 z-10 flex gap-2">
      <div id="weather-widget" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)] flex items-center gap-2 text-lg font-semibold">
          <span>-</span><span>-°C</span>
          <span id="offline-indicator" class="hidden text-xs text-red-500 font-bold" data-i18n="general.offline">OFFLINE</span>
      </div>
      <div id="speed-widget" class="hidden bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full px-4 py-3 border border-[var(--border-color)] flex items-center gap-2 text-lg font-semibold">
          <span>-- km/h</span>
      </div>
  </div>

  <!-- Schnellnavigation links mitte -->
  <div class="absolute left-4 top-1/2 -translate-y-1/2 z-10 flex flex-col gap-3">
       <a href="index.html" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon></svg>
      </a>
      <button onclick="uiManager.toggleSidebar()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>
      </button>
  </div>

  <!-- Navigationshinweise oben mitte -->
  <div class="absolute top-0 left-0 right-0 p-4 z-10 pointer-events-none">
    <div id="navHint" class="hidden items-center gap-3 bg-[var(--ui-bg)] text-[var(--text-color)] rounded-full px-4 py-2 max-w-sm mx-auto">
        <!-- Inhalt wird per JS gefüllt -->
    </div>
  </div>

  <!-- Dashboard/Seitenleiste -->
  <aside id="sidebar-panel">
    <div class="flex items-center justify-between p-4 border-b border-[var(--border-color)]">
        <h2 class="text-xl font-bold" data-i18n="dashboard.title">Dashboard</h2>
        <button onclick="uiManager.toggleSidebar()" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
    </div>

    <!-- Tab Navigation -->
    <nav class="flex border-b border-[var(--border-color)] p-2">
      <button data-tab="tab-tour" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.tour">Tour</button>
      <button data-tab="tab-raum" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.room">Raum</button>
      <button data-tab="tab-nutzer" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.profile">Profil</button>
      <button data-tab="tab-stats" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.stats">Statistik</button>
      <button data-tab="tab-einstellungen" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center" data-i18n="tabs.setup">Setup</button>
    </nav>

    <!-- Tab Inhalte -->
    <div class="flex-1 overflow-y-auto p-4 space-y-6">
      <!-- Tour Tab -->
      <section id="tab-tour" class="tab-panel space-y-4">
        <div class="p-3 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-800 rounded-lg">
            <h3 class="font-bold text-blue-800 dark:text-blue-300" data-i18n="tour.aiTitle">✨ KI Tour-Planer</h3>
            <p class="text-xs text-blue-600 dark:text-blue-400 mt-1 mb-3" data-i18n="tour.aiDesc">Lässt deine Vorlieben & Wetter einfließen!</p>
            <div class="flex gap-2">
                <select id="tour-difficulty" class="flex-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent text-sm">
                    <option value="einfache" data-i18n="tour.difficulty.easy">Leicht</option>
                    <option value="mittelschwere" data-i18n="tour.difficulty.medium">Mittel</option>
                    <option value="anspruchsvolle" data-i18n="tour.difficulty.hard">Anspruchsvoll</option>
                </select>
                <button id="suggest-tour-btn" onclick="geminiManager.suggestTour(weatherManager.currentWeather)" class="bg-blue-500 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-blue-600 transition" data-i18n="tour.aiSuggestBtn">Vorschlagen</button>
            </div>
        </div>
        <h3 class="font-bold" data-i18n="tour.stopsTitle">📋 Ausgewählte Stopps</h3>
        <p class="text-xs text-gray-500 -mt-3" data-i18n="tour.stopsDesc">Reihenfolge per Drag & Drop ändern.</p>
        <ul id="selectedList" class="space-y-2" ondragover="event.preventDefault()"></ul>
        <div id="tour-actions" class="hidden space-y-2">
            <p id="challenge-status" class="text-sm font-semibold text-center text-green-600"></p>
            <p id="tour-stats" class="text-sm text-gray-500 my-2 text-center"></p>
            <div id="elevation-chart-container" class="hidden w-full h-32 mt-2">
                <canvas id="elevation-chart"></canvas>
            </div>
            <button id="summarize-tour-btn" onclick="geminiManager.summarizeTour()" class="w-full bg-purple-500 text-white p-2 rounded-lg text-sm font-medium hover:bg-purple-600 transition" data-i18n="tour.aiSummaryBtn">
                ✨ Tour-Zusammenfassung
            </button>
        </div>
      </section>

      <!-- Raum Tab -->
      <section id="tab-raum" class="tab-panel hidden space-y-4">
        <h3 class="font-bold" data-i18n="room.title">👥 Raum-Verwaltung</h3>
        <div id="room-active-view" class="hidden space-y-2">
            <p class="text-sm" data-i18n="room.inRoom">Du bist im Raum: <strong id="current-room-id" class="font-mono bg-gray-100 dark:bg-gray-700 px-1 rounded"></strong></p>
            <p id="guide-info" class="text-sm"></p>
            <button id="invite-btn" onclick="uiManager.copyInviteLink()" class="w-full bg-indigo-500 text-white p-2 rounded-lg text-sm font-medium flex items-center justify-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M4.715 6.542 3.343 7.914a3 3 0 1 0 4.243 4.243l1.828-1.829A3 3 0 0 0 8.586 5.5L8 6.086a1.002 1.002 0 0 0-.154.199 2 2 0 0 1 .861 3.337L6.88 11.45a2 2 0 1 1-2.83-2.83l.793-.792a4.018 4.018 0 0 1-.128-1.287z"/>
                  <path d="M6.586 4.672A3 3 0 0 0 7.414 9.5l.775-.776a2 2 0 0 1-.896-3.346L9.12 3.55a2 2 0 1 1 2.83 2.83l-.793.792c.112.42.155.855.128 1.287l1.372-1.372a3 3 0 1 0-4.243-4.243L6.586 4.672z"/>
                </svg>
                <span data-i18n="room.copyInviteLink">Einladungslink kopieren</span>
            </button>
            <button id="guide-btn" onclick="firebaseManager.setGuide()" class="w-full bg-blue-500 text-white p-2 rounded-lg text-sm font-medium" data-i18n="room.becomeGuide">Guide werden</button>
            <div id="guided-tour-info" class="hidden text-sm p-2 bg-yellow-100 dark:bg-yellow-900 rounded-lg text-center" data-i18n="room.guidedTourActive">Eine geführte Tour ist aktiv.</div>
            <button onclick="firebaseManager.leaveRoom()" class="w-full bg-red-500 text-white p-2 rounded-lg text-sm font-medium" data-i18n="room.leaveBtn">Raum verlassen</button>
            <div class="mt-4">
                <h4 class="font-semibold text-sm mb-2" data-i18n="room.activeUsers">Aktive Nutzer im Raum:</h4>
                <ul id="room-user-list" class="space-y-1 text-sm text-gray-600 dark:text-gray-300"></ul>
            </div>
        </div>
        <div id="room-join-view" class="space-y-2">
            <p class="text-xs text-gray-500" data-i18n="room.joinHintSmart">Gib eine Raum-ID ein zum Beitreten, oder lass das Feld leer, um einen neuen Raum zu erstellen.</p>
            <input id="roomIdInput" type="text" maxlength="6" pattern="[A-Za-z0-9]{6}" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent uppercase" data-i18n-placeholder="room.roomIdPlaceholderJoinCreate" placeholder="Raum-ID (leer für neu)">
            <button onclick="firebaseManager.joinRoom()" class="w-full bg-green-500 text-white p-2 rounded-lg text-sm font-medium" data-i18n="room.joinCreateBtn">Beitreten / Erstellen</button>
        </div>
      </section>

      <!-- Nutzer Tab -->
      <section id="tab-nutzer" class="tab-panel hidden space-y-4">
          <h3 class="font-bold" data-i18n="profile.title">👤 Mein Profil</h3>
          <div>
              <label class="text-sm font-medium" data-i18n="profile.nameLabel">Dein Name</label>
              <div class="flex gap-2 mt-1">
                  <input id="usernameInput" type="text" class="flex-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent" data-i18n-placeholder="profile.namePlaceholder" placeholder="Dein Anzeigename">
                  <button onclick="userManager.saveUsername()" class="bg-blue-500 text-white px-4 py-2 rounded-lg text-sm font-medium" data-i18n="general.save">Speichern</button>
              </div>
          </div>
           <button onclick="userManager.showSOSModal()" class="w-full flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 text-white px-4 py-3 rounded-lg font-bold shadow-lg transition" data-i18n="profile.sosBtn">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>
            SOS Notruf
          </button>
      </section>

      <!-- Statistik Tab -->
      <section id="tab-stats" class="tab-panel hidden space-y-4">
          <h3 class="font-bold" data-i18n="stats.title">📊 Meine Statistiken</h3>
          <p class="text-xs text-gray-500 -mt-3" data-i18n="stats.desc">Hier sind deine gespeicherten Touren.</p>
          <div id="stats-list" class="space-y-3">
              <p data-i18n="stats.loading">Lade Statistiken...</p>
          </div>
      </section>

      <!-- Einstellungen Tab -->
      <section id="tab-einstellungen" class="tab-panel hidden space-y-4">
        <h3 class="font-bold" data-i18n="setup.title">⚙️ Einstellungen</h3>
        <div>
          <label for="user-pref-intensity" class="block text-sm font-medium mb-1" data-i18n="setup.intensityLabel">Bevorzugte Intensität</label>
          <select id="user-pref-intensity" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
              <option value="eher flach" data-i18n="setup.intensity.flat">Eher flach</option>
              <option value="hügelig" data-i18n="setup.intensity.hilly">Hügelig</option>
              <option value="anspruchsvolle Anstiege" data-i18n="setup.intensity.climbs">Anspruchsvolle Anstiege</option>
          </select>
        </div>
        <div>
          <label for="user-pref-type" class="block text-sm font-medium mb-1" data-i18n="setup.typeLabel">Bevorzugter Tour-Typ</label>
          <select id="user-pref-type" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
              <option value="naturfokussiert" data-i18n="setup.type.nature">Naturfokussiert</option>
              <option value="kulinarisch" data-i18n="setup.type.culinary">Kulinarisch</option>
              <option value="kulturelle Sehenswürdigkeiten" data-i18n="setup.type.culture">Kulturelle Sehenswürdigkeiten</option>
          </select>
        </div>
        <div>
          <label for="appLangSelect" class="block text-sm font-medium mb-1" data-i18n="setup.languageLabel">🗣️ App-Sprache</label>
          <select id="appLangSelect" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent"></select>
        </div>
        <div>
            <a href="#" onclick="uiManager.openPopup('Datenschutz', 'Hier stehen die Datenschutzbestimmungen...')" class="text-blue-500 hover:underline text-sm" data-i18n="setup.privacyLink">Datenschutz & Impressum</a>
        </div>
      </section>
    </div>
  </aside>
  <div id="sidebar-overlay" onclick="uiManager.toggleSidebar()"></div>

  <!-- Haupt-Toolbar unten -->
  <div id="toolbar" class="absolute bottom-5 left-1/2 -translate-x-1/2 z-10 flex items-center gap-2 p-2 rounded-full">
    <button id="startBtn" onclick="routeManager.startNavigation()" class="bg-green-500 text-white rounded-full px-6 py-3 font-bold text-lg" data-i18n="toolbar.start">Start</button>
    <button id="stopBtn" onclick="routeManager.stopNavigation()" class="bg-red-500 text-white rounded-full px-6 py-3 font-bold text-lg hidden" data-i18n="toolbar.stop">Stop</button>
    <button id="resetBtn" onclick="routeManager.resetRoute()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
    </button>
    <button id="voice-toggle" onclick="appState.toggleVoice()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3">
        <!-- Icon wird per JS gesetzt -->
    </button>
    <button id="follow-toggle" onclick="appState.toggleFollow()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3 hidden">
        <!-- Icon wird per JS gesetzt -->
    </button>
  </div>

  <!-- Popups & Modals -->
  <div id="popupOverlay" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9990] flex items-center justify-center p-4" onclick="uiManager.closePopup()">
    <div id="popupContent" class="bg-[var(--bg-color)] rounded-2xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto p-6 relative" onclick="event.stopPropagation()"></div>
  </div>
  <div id="add-warning-modal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9990] flex items-center justify-center p-4">
        <div class="bg-[var(--bg-color)] rounded-2xl shadow-xl max-w-sm w-full p-6 space-y-4">
            <h3 class="font-bold text-lg" data-i18n="warning.title">Gefahr an dieser Stelle melden</h3>
            <div>
                <label for="warning-type" class="text-sm font-medium" data-i18n="warning.typeLabel">Art der Gefahr</label>
                <select id="warning-type" class="w-full mt-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
                    <option data-i18n="warning.type.pothole">Schlagloch</option>
                    <option data-i18n="warning.type.obstacle">Hindernis</option>
                    <option data-i18n="warning.type.crossing">Gefährliche Kreuzung</option>
                    <option data-i18n="warning.type.other">Sonstiges</option>
                </select>
            </div>
            <div>
                <label for="warning-description" class="text-sm font-medium" data-i18n="warning.descLabel">Kurze Beschreibung (optional)</label>
                <input id="warning-description" type="text" class="w-full mt-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent" data-i18n-placeholder="warning.descPlaceholder" placeholder="z.B. Tiefe Spurrille">
            </div>
            <div class="flex gap-2 justify-end">
                <button onclick="uiManager.hideAddWarningModal()" class="px-4 py-2 rounded-lg" data-i18n="general.cancel">Abbrechen</button>
                <button onclick="firebaseManager.addWarning()" class="px-4 py-2 bg-blue-500 text-white rounded-lg" data-i18n="general.report">Melden</button>
            </div>
        </div>
    </div>

  <!-- Smart SOS Modal (Startet standardmäßig hidden) -->
  <div id="sos-modal-overlay" class="hidden fixed inset-0 z-[9990]" onclick="userManager.hideSOSModal()">
      <div id="sos-modal-content" class="space-y-4" onclick="event.stopPropagation()">
          <h3 class="text-xl font-bold text-red-600 flex items-center gap-2">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16">
                <path d="M8.982 1.566a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566zM8 5c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995A.905.905 0 0 1 8 5zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"/>
              </svg>
              <span data-i18n="sos.title">SOS Notruf Bestätigung</span>
          </h3>
          <p class="text-sm" data-i18n="sos.description">Überprüfe die Nachricht, füge Details hinzu und sende sie dann über WhatsApp.</p>
          <div class="p-3 bg-gray-100 dark:bg-gray-700 rounded-lg text-sm space-y-1">
              <p><strong>Von:</strong> <span id="sos-username">Dein Name</span></p>
              <p><strong>Zeit:</strong> <span id="sos-timestamp">--:--</span></p>
              <p><strong>Standort:</strong> <a id="sos-location-link" href="#" target="_blank" class="text-blue-500 hover:underline break-all">wird geladen...</a></p>
              <p id="sos-base-message" class="mt-2 font-semibold" data-i18n="sos.baseMessage">🚨 NOTRUF 🚨 Ich brauche Hilfe!</p>
          </div>
          <div>
              <label for="sos-custom-message" class="block text-sm font-medium mb-1" data-i18n="sos.customMessageLabel">Zusätzliche Nachricht (optional):</label>
              <input id="sos-custom-message" type="text" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent" data-i18n-placeholder="sos.customMessagePlaceholder" placeholder="z.B. Bin gestürzt, Akku fast leer">
          </div>
          <div class="flex gap-2 justify-end mt-4">
              <button onclick="userManager.hideSOSModal()" class="px-4 py-2 rounded-lg" data-i18n="general.cancel">Abbrechen</button>
              <button onclick="userManager.sendSOS()" class="px-4 py-2 bg-red-600 text-white rounded-lg font-semibold flex items-center gap-1">
                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M15.854.146a.5.5 0 0 1 .11.54l-5.819 14.547a.75.75 0 0 1-1.329.124l-3.178-4.995L.643 7.184a.75.75 0 0 1 .124-1.33L15.314.037a.5.5 0 0 1 .54.11ZM6.636 10.07l2.761 4.338L14.13 2.576zm6.787-8.201L1.591 6.602l4.339 2.76z"/>
                  </svg>
                  <span data-i18n="sos.sendBtn">SOS via WhatsApp senden</span>
              </button>
          </div>
      </div>
  </div>


  <!-- Firebase & Logik -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>

  <script>
    // ==========================================================
    //  🚲 RADLMAP - V6.3 - i18n Fix, Smart SOS, Room Fix
    // ==========================================================

    const GEMINI_API_KEY = "AIzaSyB3FT8CdN9WkNjfQ5vutbjLCEibGSl3nnQ";

    // ----------------------------------------------------------
    //  1. CONFIG & STATE
    // ----------------------------------------------------------
    const config = { /* Config */
      firebase: {
        apiKey: "5b3ce3597851110001cf624866907189b4974b88e5541b15dfed2e1603067f5b85cd6da44c68ee87",
        authDomain: "eierhuettentour.firebaseapp.com",
        projectId: "eierhuettentour"
      },
      map: {
        defaultCenter: [52.77, 7.28],
        defaultZoom: 13,
        navigationZoom: 18,
      },
      routing: {
        profile: 'cycling-regular',
        deviationThresholdMeters: 15,
        recalcDebounceMs: 10000,
      },
      noImagePlaceholders: [
        "https://radlmap.net/img/noimg/1.jpg",
        "https://radlmap.net/img/noimg/2.jpg",
        "https://radlmap.net/img/noimg/3.jpg",
      ]
     };
    const appState = { /* State */
      isFollowing: true,
      isVoiceOn: true,
      isDarkTheme: false,
      isNavigating: false,
      isSidebarOpen: false,
      currentLang: 'de',
      selectedHuts: [],
      allHuts: [],
      allWarnings: [],
      warnedAbout: new Set(),
      currentRoom: { id: null, guideId: null },
      roomUnsubscribe: null,
      userPositionsUnsubscribe: null,
      visitedStops: new Set(),
      navigationStartTime: null,
      lastBreakTime: null,
      currentSOSData: { link: '#', timestamp: '', baseMessage: '', username: '' },

      toggleFollow() {
        this.isFollowing = !this.isFollowing;
        uiManager.updateFollowButton();
        // Verwende state für Toast-Nachricht
        uiManager.showToast(i18nManager.getString(this.isFollowing ? 'toast.followOn' : 'toast.followOff', { state: this.isFollowing ? i18nManager.getString('general.state.active') : i18nManager.getString('general.state.paused') }));
        if(this.isFollowing && mapManager.userMarker) {
            mapManager.map.flyTo(mapManager.userMarker.getLatLng(), config.map.navigationZoom);
        }
      },
      toggleVoice() {
        this.isVoiceOn = !this.isVoiceOn;
        uiManager.updateVoiceButton();
        uiManager.showToast(i18nManager.getString(this.isVoiceOn ? 'toast.voiceOn' : 'toast.voiceOff'));
      },
     };

    // ----------------------------------------------------------
    //  2. i18n MANAGER (Internationalization)
    // ----------------------------------------------------------
    const i18nManager = {
        translations: {
            de: {
                "app.title": "RadlMap Navigation 🚲 (Smarter)",
                "loader.text": "Karte wird geladen...",
                "general.offline": "OFFLINE",
                "general.save": "Speichern",
                "general.cancel": "Abbrechen",
                "general.report": "Melden",
                "general.loading": "Lade...",
                "general.state.active": "aktiviert", // Neu
                "general.state.paused": "pausiert", // Neu
                "dashboard.title": "Dashboard",
                "tabs.tour": "Tour",
                "tabs.room": "Raum",
                "tabs.profile": "Profil",
                "tabs.stats": "Statistik",
                "tabs.setup": "Setup",
                "tour.aiTitle": "✨ KI Tour-Planer",
                "tour.aiDesc": "Lässt deine Vorlieben & Wetter einfließen!",
                "tour.difficulty.easy": "Leicht",
                "tour.difficulty.medium": "Mittel",
                "tour.difficulty.hard": "Anspruchsvoll",
                "tour.aiSuggestBtn": "Vorschlagen",
                "tour.aiSuggestBtn.loading": "Denke...",
                "tour.stopsTitle": "📋 Ausgewählte Stopps",
                "tour.stopsDesc": "Reihenfolge per Drag & Drop ändern.",
                "tour.stopsEmpty": "Noch keine Stopps ausgewählt. Klicke auf der Karte auf eine Hütte oder lass dir eine Tour vorschlagen.",
                "tour.stats": "Tour: {dist} km, ca. {time} min",
                "tour.stats.addMore": "Füge einen weiteren Stopp für eine Route hinzu.",
                "tour.aiSummaryBtn": "✨ Tour-Zusammenfassung",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "👥 Raum-Verwaltung",
                "room.inRoom": "Du bist im Raum:",
                "room.guide.isGuide": "Du bist der Guide.",
                "room.guide.isOther": "Guide: {name}",
                "room.guide.noGuide": "Niemand führt die Tour.",
                "room.becomeGuide": "Guide werden",
                "room.leaveGuide": "Guide-Rolle abgeben",
                "room.guidedTourActive": "Eine geführte Tour ist aktiv.",
                "room.leaveBtn": "Raum verlassen",
                "room.activeUsers": "Aktive Nutzer im Raum:",
                "room.noActiveUsers": "Keine anderen Nutzer aktiv.",
                "room.roomIdPlaceholderJoinCreate": "Raum-ID (leer für neu)",
                "room.joinCreateBtn": "Beitreten / Erstellen",
                "room.joinHintSmart": "Gib eine Raum-ID ein zum Beitreten, oder lass das Feld leer, um einen neuen Raum zu erstellen.",
                "room.copyInviteLink": "Einladungslink kopieren",
                "profile.title": "👤 Mein Profil",
                "profile.nameLabel": "Dein Name",
                "profile.namePlaceholder": "Dein Anzeigename",
                "profile.sosBtn": "SOS Notruf",
                "stats.title": "📊 Meine Statistiken",
                "stats.desc": "Hier sind deine gespeicherten Touren.",
                "stats.loading": "Lade Statistiken...",
                "stats.empty": "Du hast noch keine Touren abgeschlossen.",
                "stats.tourCard.stops": "Stopps",
                "stats.loadingError": "Fehler beim Laden der Statistiken.", // Neu
                "setup.title": "⚙️ Einstellungen",
                "setup.intensityLabel": "Bevorzugte Intensität",
                "setup.intensity.flat": "Eher flach",
                "setup.intensity.hilly": "Hügelig",
                "setup.intensity.climbs": "Anspruchsvolle Anstiege",
                "setup.typeLabel": "Bevorzugter Tour-Typ",
                "setup.type.nature": "Naturfokussiert",
                "setup.type.culinary": "Kulinarisch",
                "setup.type.culture": "Kulturelle Sehenswürdigkeiten",
                "setup.languageLabel": "🗣️ App-Sprache",
                "setup.privacyLink": "Datenschutz & Impressum",
                "toolbar.start": "Start",
                "toolbar.stop": "Stop",
                "warning.title": "Gefahr an dieser Stelle melden",
                "warning.typeLabel": "Art der Gefahr",
                "warning.type.pothole": "Schlagloch",
                "warning.type.obstacle": "Hindernis",
                "warning.type.crossing": "Gefährliche Kreuzung",
                "warning.type.other": "Sonstiges",
                "warning.descLabel": "Kurze Beschreibung (optional)",
                "warning.descPlaceholder": "z.B. Tiefe Spurrille",
                "toast.followOn": "Follow-Modus {state}", // Geändert
                "toast.followOff": "Follow-Modus {state}", // Geändert
                "toast.voiceOn": "Sprachansagen aktiviert",
                "toast.voiceOff": "Sprachansagen deaktiviert",
                "toast.apiKeyWarning": "KI-Funktion fehlgeschlagen: API-Schlüssel nicht konfiguriert.",
                "toast.geminiError": "Ein Fehler mit der KI-Funktion ist aufgetreten.",
                "toast.offlineAI": "Offline. KI-Funktionen nicht verfügbar.",
                "toast.routeError": "Route konnte nicht berechnet werden.",
                "toast.allStopsReached": "🏆 Alle Stopps erreicht!",
                "toast.allStopsReached.speak": "Herzlichen Glückwunsch, du hast alle Ziele erreicht!",
                "toast.routeDeviation": "Route verlassen, neue Route wird berechnet...",
                "toast.routeUpdating": "Route wird aktualisiert...",
                "toast.previewLoading": "Routenvorschau wird berechnet...",
                "toast.navStarting": "Navigation wird gestartet...",
                "toast.navStarted": "Navigation gestartet!",
                "toast.navStopped": "Navigation beendet.",
                "toast.noStops": "Bitte wähle zuerst mindestens einen Stopp.",
                "toast.guideOnly": "Nur der Guide kann dies tun.",
                "toast.guideExists": "Es gibt bereits einen Guide.",
                "toast.roomJoined": "Raum {id} beigetreten.",
                "toast.roomCreated": "Neuer Raum {id} erstellt.",
                "toast.roomLeft": "Raum verlassen.",
                "toast.roomTourUpdated": "Tour im Raum wurde aktualisiert!",
                "toast.nameSaved": "Name gespeichert!",
                "toast.warningReported": "Gefahr gemeldet!",
                "toast.hutsLoadingError": "Hütten konnten nicht geladen werden. Versuche Offline-Daten...",
                "toast.offlineHutsLoaded": "Offline-Hütten geladen.",
                "toast.offlineHutsNotFound": "Keine Offline-Hütten gefunden.",
                "toast.offlineRouteLoaded": "Zuletzt geplante Route (offline) geladen.",
                "toast.offlineRouteError": "Fehler beim Laden der Offline-Route.",
                "toast.offlineElevationError": "Offline. Höhenprofil kann nicht geladen werden.",
                "toast.elevationError": "Höhenprofil konnte nicht geladen werden.",
                "toast.smartBreak": "Du fährst schon seit einer Stunde. Zeit für eine kleine Pause?",
                "toast.hutsNotLoaded": "Hütten werden noch geladen. Bitte kurz warten.",
                "toast.inviteLinkCopied": "Einladungslink in die Zwischenablage kopiert!",
                "toast.roomRejoin": "Möchtest du dem Raum \"{id}\" wieder beitreten?",
                "toast.sosLocationError": "Standort für SOS konnte nicht abgerufen werden.",
                "toast.firebaseError": "Verbindungsfehler. Bitte später erneut versuchen.", // Neu
                "toast.gpsUnavailable": "GPS nicht verfügbar. Nutze Fallback-Position.", // Neu
                "toast.gpsDenied": "GPS Zugriff verweigert. Fallback-Position wird genutzt.", // Neu
                "toast.gpsTimeout": "GPS Timeout. Versuche Standardgenauigkeit...", // Neu
                "toast.gpsDeniedWatch": "GPS Zugriff wurde während der Überwachung verweigert.", // Neu
                "toast.gpsUnavailableWatch": "GPS Position vorübergehend nicht verfügbar während der Überwachung.", // Neu
                "popup.aiSuggestionTitle": "KI-Vorschlag: {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>Die Stopps wurden deiner Tour hinzugefügt.</p>",
                "popup.aiSummaryTitle": "✨ Deine Tour-Zusammenfassung",
                "popup.hut.loading": "Lade...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "Öffnungszeiten",
                "popup.hut.openingHours.always": "Immer geöffnet ✅",
                "popup.hut.openingHours.unknown": "Keine Angabe",
                "popup.hut.animals": "Tiere",
                "popup.hut.animals.none": "Keine",
                "popup.hut.power": "Strom",
                "popup.hut.power.unknown": "k.A.",
                "popup.hut.seats": "Plätze",
                "popup.hut.seats.unknown": "k.A.",
                "popup.hut.premiumInfo": "Premium Info",
                "popup.hut.addBtn": "Zur Tour hinzufügen",
                "popup.hut.removeBtn": "Von Tour entfernen",
                "elevation.yAxisLabel": "Höhe (m)",
                "elevation.tooltipLabel": "{value} m Höhe",
                "sos.title": "SOS Notruf Bestätigung",
                "sos.description": "Überprüfe die Nachricht, füge Details hinzu und sende sie dann über WhatsApp.",
                "sos.customMessageLabel": "Zusätzliche Nachricht (optional):",
                "sos.customMessagePlaceholder": "z.B. Bin gestürzt, Akku fast leer",
                "sos.sendBtn": "SOS via WhatsApp senden",
                "sos.baseMessage": "🚨 NOTRUF 🚨 Ich brauche Hilfe!",
            },
            en: { /* English */
                "app.title": "RadlMap Navigation 🚲 (Smarter)",
                "loader.text": "Loading map...",
                "general.offline": "OFFLINE",
                "general.save": "Save",
                "general.cancel": "Cancel",
                "general.report": "Report",
                "general.loading": "Loading...",
                "general.state.active": "activated", // New
                "general.state.paused": "paused", // New
                "dashboard.title": "Dashboard",
                "tabs.tour": "Tour",
                "tabs.room": "Room",
                "tabs.profile": "Profile",
                "tabs.stats": "Statistics",
                "tabs.setup": "Setup",
                "tour.aiTitle": "✨ AI Tour Planner",
                "tour.aiDesc": "Uses your preferences & the weather!",
                "tour.difficulty.easy": "Easy",
                "tour.difficulty.medium": "Medium",
                "tour.difficulty.hard": "Challenging",
                "tour.aiSuggestBtn": "Suggest",
                "tour.aiSuggestBtn.loading": "Thinking...",
                "tour.stopsTitle": "📋 Selected Stops",
                "tour.stopsDesc": "Change order via Drag & Drop.",
                "tour.stopsEmpty": "No stops selected yet. Click a hut on the map or let the AI suggest a tour.",
                "tour.stats": "Tour: {dist} km, approx. {time} min",
                "tour.stats.addMore": "Add another stop to plan a route.",
                "tour.aiSummaryBtn": "✨ Tour Summary",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "👥 Room Management",
                "room.inRoom": "You are in room:",
                "room.guide.isGuide": "You are the guide.",
                "room.guide.isOther": "Guide: {name}",
                "room.guide.noGuide": "Nobody is guiding this tour.",
                "room.becomeGuide": "Become Guide",
                "room.leaveGuide": "Resign as Guide",
                "room.guidedTourActive": "A guided tour is active.",
                "room.leaveBtn": "Leave Room",
                "room.activeUsers": "Active users in room:",
                "room.noActiveUsers": "No other users active.",
                "room.roomIdPlaceholderJoinCreate": "Room ID (empty for new)",
                "room.joinCreateBtn": "Join / Create",
                "room.joinHintSmart": "Enter a Room ID to join, or leave empty to create a new room.",
                "room.copyInviteLink": "Copy Invite Link",
                "profile.title": "👤 My Profile",
                "profile.nameLabel": "Your Name",
                "profile.namePlaceholder": "Your display name",
                "profile.sosBtn": "SOS Emergency Call",
                "stats.title": "📊 My Statistics",
                "stats.desc": "Here are your saved tours.",
                "stats.loading": "Loading statistics...",
                "stats.empty": "You haven't completed any tours yet.",
                "stats.tourCard.stops": "Stops",
                "stats.loadingError": "Error loading statistics.", // New
                "setup.title": "⚙️ Settings",
                "setup.intensityLabel": "Preferred Intensity",
                "setup.intensity.flat": "Rather flat",
                "setup.intensity.hilly": "Hilly",
                "setup.intensity.climbs": "Challenging climbs",
                "setup.typeLabel": "Preferred Tour Type",
                "setup.type.nature": "Nature-focused",
                "setup.type.culinary": "Culinary",
                "setup.type.culture": "Cultural sights",
                "setup.languageLabel": "🗣️ App Language",
                "setup.privacyLink": "Privacy & Legal",
                "toolbar.start": "Start",
                "toolbar.stop": "Stop",
                "warning.title": "Report Hazard at this Location",
                "warning.typeLabel": "Type of Hazard",
                "warning.type.pothole": "Pothole",
                "warning.type.obstacle": "Obstacle",
                "warning.type.crossing": "Dangerous Crossing",
                "warning.type.other": "Other",
                "warning.descLabel": "Short Description (optional)",
                "warning.descPlaceholder": "e.g., Deep rut",
                "toast.followOn": "Follow-mode {state}", // Changed
                "toast.followOff": "Follow-mode {state}", // Changed
                "toast.voiceOn": "Voice guidance activated",
                "toast.voiceOff": "Voice guidance deactivated",
                "toast.apiKeyWarning": "AI function failed: API key not configured.",
                "toast.geminiError": "An error occurred with the AI function.",
                "toast.offlineAI": "Offline. AI functions not available.",
                "toast.routeError": "Could not calculate route.",
                "toast.allStopsReached": "🏆 All stops reached!",
                "toast.allStopsReached.speak": "Congratulations, you have reached all destinations!",
                "toast.routeDeviation": "Off route, recalculating...",
                "toast.routeUpdating": "Updating route...",
                "toast.previewLoading": "Calculating route preview...",
                "toast.navStarting": "Starting navigation...",
                "toast.navStarted": "Navigation started!",
                "toast.navStopped": "Navigation stopped.",
                "toast.noStops": "Please select at least one stop first.",
                "toast.guideOnly": "Only the guide can do this.",
                "toast.guideExists": "There is already a guide.",
                "toast.roomJoined": "Joined room {id}.",
                "toast.roomCreated": "Created new room {id}.",
                "toast.roomLeft": "Left room.",
                "toast.roomTourUpdated": "Tour in room has been updated!",
                "toast.nameSaved": "Name saved!",
                "toast.warningReported": "Hazard reported!",
                "toast.hutsLoadingError": "Could not load huts.Trying offline data...",
                "toast.offlineHutsLoaded": "Offline huts loaded.",
                "toast.offlineHutsNotFound": "No offline huts found.",
                "toast.offlineRouteLoaded": "Last planned route (offline) loaded.",
                "toast.offlineRouteError": "Error loading offline route.",
                "toast.offlineElevationError": "Offline. Elevation profile cannot be loaded.",
                "toast.elevationError": "Could not load elevation profile.",
                "toast.smartBreak": "You've been riding for an hour. Time for a short break?",
                "toast.hutsNotLoaded": "Huts are still loading. Please wait a moment.",
                "toast.inviteLinkCopied": "Invite link copied to clipboard!",
                "toast.roomRejoin": "Do you want to rejoin room \"{id}\"?",
                "toast.sosLocationError": "Could not get location for SOS.",
                 "toast.firebaseError": "Connection error. Please try again later.", // New
                "toast.gpsUnavailable": "GPS unavailable. Using fallback position.", // New
                "toast.gpsDenied": "GPS access denied. Using fallback position.", // New
                "toast.gpsTimeout": "GPS Timeout. Trying standard accuracy...", // New
                "toast.gpsDeniedWatch": "GPS access denied during watch.", // New
                "toast.gpsUnavailableWatch": "GPS position temporarily unavailable during watch.", // New
                "popup.aiSuggestionTitle": "AI Suggestion: {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>The stops have been added to your tour.</p>",
                "popup.aiSummaryTitle": "✨ Your Tour Summary",
                "popup.hut.loading": "Loading...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "Opening Hours",
                "popup.hut.openingHours.always": "Always open ✅",
                "popup.hut.openingHours.unknown": "No information",
                "popup.hut.animals": "Animals",
                "popup.hut.animals.none": "None",
                "popup.hut.power": "Power",
                "popup.hut.power.unknown": "n/a",
                "popup.hut.seats": "Seats",
                "popup.hut.seats.unknown": "n/a",
                "popup.hut.premiumInfo": "Premium Info",
                "popup.hut.addBtn": "Add to Tour",
                "popup.hut.removeBtn": "Remove from Tour",
                "elevation.yAxisLabel": "Height (m)",
                "elevation.tooltipLabel": "{value} m Height",
                "sos.title": "SOS Emergency Confirmation",
                "sos.description": "Review the message, add details if needed, then send via WhatsApp.",
                "sos.customMessageLabel": "Additional Message (optional):",
                "sos.customMessagePlaceholder": "e.g., Fell down, battery low",
                "sos.sendBtn": "Send SOS via WhatsApp",
                "sos.baseMessage": "🚨 SOS Emergency 🚨 I need help!",
            },
            es: { /* Spanish */
                "app.title": "RadlMap Navegación 🚲 (Smarter)",
                "loader.text": "Cargando mapa...",
                "general.offline": "SIN CONEXIÓN",
                "general.save": "Guardar",
                "general.cancel": "Cancelar",
                "general.report": "Informar",
                "general.loading": "Cargando...",
                "general.state.active": "activado", // Nuevo
                "general.state.paused": "pausado", // Nuevo
                "dashboard.title": "Panel",
                "tabs.tour": "Ruta",
                "tabs.room": "Sala",
                "tabs.profile": "Perfil",
                "tabs.stats": "Estadísticas",
                "tabs.setup": "Ajustes",
                "tour.aiTitle": "✨ Planificador IA de Rutas",
                "tour.aiDesc": "¡Usa tus preferencias y el tiempo!",
                "tour.difficulty.easy": "Fácil",
                "tour.difficulty.medium": "Medio",
                "tour.difficulty.hard": "Difícil",
                "tour.aiSuggestBtn": "Sugerir",
                "tour.aiSuggestBtn.loading": "Pensando...",
                "tour.stopsTitle": "📋 Paradas Seleccionadas",
                "tour.stopsDesc": "Cambiar orden arrastrando.",
                "tour.stopsEmpty": "No hay paradas seleccionadas. Haz clic en una cabaña o deja que la IA sugiera una ruta.",
                "tour.stats": "Ruta: {dist} km, aprox. {time} min",
                "tour.stats.addMore": "Añade otra parada para planificar una ruta.",
                "tour.aiSummaryBtn": "✨ Resumen de la Ruta",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "👥 Gestión de Sala",
                "room.inRoom": "Estás en la sala:",
                "room.guide.isGuide": "Tú eres el guía.",
                "room.guide.isOther": "Guía: {name}",
                "room.guide.noGuide": "Nadie está guiando esta ruta.",
                "room.becomeGuide": "Ser Guía",
                "room.leaveGuide": "Dejar de ser Guía",
                "room.guidedTourActive": "Una ruta guiada está activa.",
                "room.leaveBtn": "Salir de la Sala",
                "room.activeUsers": "Usuarios activos en la sala:",
                "room.noActiveUsers": "No hay otros usuarios activos.",
                 "room.roomIdPlaceholderJoinCreate": "ID de Sala (vacío para nuevo)",
                "room.joinCreateBtn": "Unirse / Crear",
                "room.joinHintSmart": "Introduce un ID de Sala para unirte, o déjalo vacío para crear una nueva sala.",
                "room.copyInviteLink": "Copiar Enlace de Invitación",
                "profile.title": "👤 Mi Perfil",
                "profile.nameLabel": "Tu Nombre",
                "profile.namePlaceholder": "Tu nombre de usuario",
                "profile.sosBtn": "Llamada SOS",
                "stats.title": "📊 Mis Estadísticas",
                "stats.desc": "Aquí están tus rutas guardadas.",
                "stats.loading": "Cargando estadísticas...",
                "stats.empty": "Aún no has completado ninguna ruta.",
                "stats.tourCard.stops": "Paradas",
                "stats.loadingError": "Error al cargar estadísticas.", // Nuevo
                "setup.title": "⚙️ Ajustes",
                "setup.intensityLabel": "Intensidad Preferida",
                "setup.intensity.flat": "Bastante plano",
                "setup.intensity.hilly": "Montañoso",
                "setup.intensity.climbs": "Subidas exigentes",
                "setup.typeLabel": "Tipo de Ruta Preferido",
                "setup.type.nature": "Enfocado en la naturaleza",
                "setup.type.culinary": "Culinario",
                "setup.type.culture": "Vistas culturales",
                "setup.languageLabel": "🗣️ Idioma de la App",
                "setup.privacyLink": "Privacidad y Legal",
                "toolbar.start": "Empezar",
                "toolbar.stop": "Parar",
                "warning.title": "Informar de un Peligro Aquí",
                "warning.typeLabel": "Tipo de Peligro",
                "warning.type.pothole": "Bache",
                "warning.type.obstacle": "Obstáculo",
                "warning.type.crossing": "Cruce Peligroso",
                "warning.type.other": "Otro",
                "warning.descLabel": "Descripción Breve (opcional)",
                "warning.descPlaceholder": "p.ej., Surco profundo",
                "toast.followOn": "Modo seguimiento {state}", // Cambiado
                "toast.followOff": "Modo seguimiento {state}", // Cambiado
                "toast.voiceOn": "Guía por voz activada",
                "toast.voiceOff": "Guía por voz desactivada",
                "toast.apiKeyWarning": "Función IA falló: Clave API no configurada.",
                "toast.geminiError": "Ocurrió un error con la función IA.",
                "toast.offlineAI": "Sin conexión. Funciones IA no disponibles.",
                "toast.routeError": "No se pudo calcular la ruta.",
                "toast.allStopsReached": "🏆 ¡Todas las paradas alcanzadas!",
                "toast.allStopsReached.speak": "¡Felicidades, has llegado a todos los destinos!",
                "toast.routeDeviation": "Fuera de ruta, recalculando...",
                "toast.routeUpdating": "Actualizando ruta...",
                "toast.previewLoading": "Calculando vista previa de la ruta...",
                "toast.navStarting": "Iniciando navegación...",
                "toast.navStarted": "Navegación iniciada",
                "toast.navStopped": "Navegación detenida",
                "toast.noStops": "Por favor, selecciona al menos una parada.",
                "toast.guideOnly": "Solo el guía puede hacer esto.",
                "toast.guideExists": "Ya hay un guía.",
                "toast.roomJoined": "Te uniste a la sala {id}.",
                "toast.roomCreated": "Nueva sala {id} creada.",
                "toast.roomLeft": "Saliste de la sala.",
                "toast.roomTourUpdated": "¡La ruta en la sala ha sido actualizada!",
                "toast.nameSaved": "¡Nombre guardado!",
                "toast.warningReported": "¡Peligro informado!",
                "toast.hutsLoadingError": "No se pudieron cargar las cabañas. Intentando datos sin conexión...",
                "toast.offlineHutsLoaded": "Cabañas sin conexión cargadas.",
                "toast.offlineHutsNotFound": "No se encontraron cabañas sin conexión.",
                "toast.offlineRouteLoaded": "Última ruta planificada (sin conexión) cargada.",
                "toast.offlineRouteError": "Error al cargar ruta sin conexión.",
                "toast.offlineElevationError": "Sin conexión. No se puede cargar el perfil de elevación.",
                "toast.elevationError": "No se pudo cargar el perfil de elevación.",
                "toast.smartBreak": "Llevas una hora pedaleando. ¿Hora de un descanso?",
                "toast.hutsNotLoaded": "Las cabañas aún se están cargando. Espera un momento.",
                "toast.inviteLinkCopied": "¡Enlace de invitación copiado al portapapeles!",
                "toast.roomRejoin": "¿Quieres volver a unirte a la sala \"{id}\"?",
                "toast.sosLocationError": "No se pudo obtener la ubicación para SOS.",
                "toast.firebaseError": "Error de conexión. Inténtalo más tarde.", // Nuevo
                "toast.gpsUnavailable": "GPS no disponible. Usando posición de reserva.", // Nuevo
                "toast.gpsDenied": "Acceso GPS denegado. Usando posición de reserva.", // Nuevo
                "toast.gpsTimeout": "Tiempo de espera GPS. Intentando precisión estándar...", // Nuevo
                "toast.gpsDeniedWatch": "Acceso GPS denegado durante el seguimiento.", // Nuevo
                "toast.gpsUnavailableWatch": "Posición GPS temporalmente no disponible durante el seguimiento.", // Nuevo
                "popup.aiSuggestionTitle": "Sugerencia IA: {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>Las paradas han sido añadidas a tu ruta.</p>",
                "popup.aiSummaryTitle": "✨ Tu Resumen de Ruta",
                "popup.hut.loading": "Cargando...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "Horario",
                "popup.hut.openingHours.always": "Siempre abierto ✅",
                "popup.hut.openingHours.unknown": "No disponible",
                "popup.hut.animals": "Animales",
                "popup.hut.animals.none": "No",
                "popup.hut.power": "Electricidad",
                "popup.hut.power.unknown": "n/a",
                "popup.hut.seats": "Asientos",
                "popup.hut.seats.unknown": "n/a",
                "popup.hut.premiumInfo": "Info Premium",
                "popup.hut.addBtn": "Añadir a Ruta",
                "popup.hut.removeBtn": "Quitar de Ruta",
                "elevation.yAxisLabel": "Altitud (m)",
                "elevation.tooltipLabel": "{value} m Altitud",
                "sos.title": "Confirmación SOS Emergencia",
                "sos.description": "Revisa el mensaje, añade detalles si es necesario y envíalo por WhatsApp.",
                "sos.customMessageLabel": "Mensaje Adicional (opcional):",
                "sos.customMessagePlaceholder": "p.ej., Me caí, batería baja",
                "sos.sendBtn": "Enviar SOS por WhatsApp",
                "sos.baseMessage": "🚨 SOS Emergencia 🚨 ¡Necesito ayuda!",
            },
            fr: { /* French */
                "app.title": "RadlMap Navigation 🚲 (Smarter)",
                "loader.text": "Chargement de la carte...",
                "general.offline": "HORS LIGNE",
                "general.save": "Enregistrer",
                "general.cancel": "Annuler",
                "general.report": "Signaler",
                "general.loading": "Chargement...",
                "general.state.active": "activé", // Nouveau
                "general.state.paused": "en pause", // Nouveau
                "dashboard.title": "Tableau de bord",
                "tabs.tour": "Tour",
                "tabs.room": "Salle",
                "tabs.profile": "Profil",
                "tabs.stats": "Statistiques",
                "tabs.setup": "Réglages",
                "tour.aiTitle": "✨ Planificateur de Tour IA",
                "tour.aiDesc": "Prend en compte vos préférences et la météo !",
                "tour.difficulty.easy": "Facile",
                "tour.difficulty.medium": "Moyen",
                "tour.difficulty.hard": "Difficile",
                "tour.aiSuggestBtn": "Suggérer",
                "tour.aiSuggestBtn.loading": "Réflexion...",
                "tour.stopsTitle": "📋 Arrêts Sélectionnés",
                "tour.stopsDesc": "Changer l'ordre par glisser-déposer.",
                "tour.stopsEmpty": "Aucun arrêt sélectionné. Cliquez sur un refuge ou laissez l'IA suggérer un tour.",
                "tour.stats": "Tour : {dist} km, env. {time} min",
                "tour.stats.addMore": "Ajoutez un autre arrêt pour planifier un itinéraire.",
                "tour.aiSummaryBtn": "✨ Résumé du Tour",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "👥 Gestion de Salle",
                "room.inRoom": "Vous êtes dans la salle :",
                "room.guide.isGuide": "Vous êtes le guide.",
                "room.guide.isOther": "Guide : {name}",
                "room.guide.noGuide": "Personne ne guide ce tour.",
                "room.becomeGuide": "Devenir Guide",
                "room.leaveGuide": "Quitter le rôle de Guide",
                "room.guidedTourActive": "Un tour guidé est actif.",
                "room.leaveBtn": "Quitter la Salle",
                "room.activeUsers": "Utilisateurs actifs :",
                "room.noActiveUsers": "Aucun autre utilisateur actif.",
                 "room.roomIdPlaceholderJoinCreate": "ID de Salle (vide pour nouveau)",
                "room.joinCreateBtn": "Rejoindre / Créer",
                "room.joinHintSmart": "Entrez un ID de salle pour rejoindre, ou laissez vide pour créer une nouvelle salle.",
                "room.copyInviteLink": "Copier le Lien d'Invitation",
                "profile.title": "👤 Mon Profil",
                "profile.nameLabel": "Votre Nom",
                "profile.namePlaceholder": "Votre nom d'affichage",
                "profile.sosBtn": "Appel d'Urgence SOS",
                "stats.title": "📊 Mes Statistiques",
                "stats.desc": "Voici vos tours enregistrés.",
                "stats.loading": "Chargement des statistiques...",
                "stats.empty": "Vous n'avez pas encore terminé de tours.",
                "stats.tourCard.stops": "Arrêts",
                "stats.loadingError": "Erreur de chargement des statistiques.", // Nouveau
                "setup.title": "⚙️ Réglages",
                "setup.intensityLabel": "Intensité Préférée",
                "setup.intensity.flat": "Plutôt plat",
                "setup.intensity.hilly": "Vallonné",
                "setup.intensity.climbs": "Montées exigeantes",
                "setup.typeLabel": "Type de Tour Préféré",
                "setup.type.nature": "Axé sur la nature",
                "setup.type.culinary": "Culinaire",
                "setup.type.culture": "Sites culturels",
                "setup.languageLabel": "🗣️ Langue de l'App",
                "setup.privacyLink": "Confidentialité & Mentions",
                "toolbar.start": "Démarrer",
                "toolbar.stop": "Arrêter",
                "warning.title": "Signaler un Danger Ici",
                "warning.typeLabel": "Type de Danger",
                "warning.type.pothole": "Nid-de-poule",
                "warning.type.obstacle": "Obstacle",
                "warning.type.crossing": "Traversée Dangereuse",
                "warning.type.other": "Autre",
                "warning.descLabel": "Description Courte (optionnel)",
                "warning.descPlaceholder": "ex: Ornière profonde",
                "toast.followOn": "Mode suivi {state}", // Modifié
                "toast.followOff": "Mode suivi {state}", // Modifié
                "toast.voiceOn": "Guidage vocal activé",
                "toast.voiceOff": "Guidage vocal désactivé",
                "toast.apiKeyWarning": "Fonction IA échouée : Clé API non configurée.",
                "toast.geminiError": "Une erreur est survenue avec la fonction IA.",
                "toast.offlineAI": "Hors ligne. Fonctions IA indisponibles.",
                "toast.routeError": "Impossible de calculer l'itinéraire.",
                "toast.allStopsReached": "🏆 Tous les arrêts atteints !",
                "toast.allStopsReached.speak": "Félicitations, vous avez atteint toutes les destinations !",
                "toast.routeDeviation": "Sortie d'itinéraire, recalcul...",
                "toast.routeUpdating": "Mise à jour de l'itinéraire...",
                "toast.previewLoading": "Calcul de l'aperçu...",
                "toast.navStarting": "Démarrage de la navigation...",
                "toast.navStarted": "Navigation démarrée !",
                "toast.navStopped": "Navigation arrêtée.",
                "toast.noStops": "Veuillez sélectionner au moins un arrêt.",
                "toast.guideOnly": "Seul le guide peut faire cela.",
                "toast.guideExists": "Il y a déjà un guide.",
                "toast.roomJoined": "Salle {id} rejointe.",
                "toast.roomCreated": "Nouvelle salle {id} créée.",
                "toast.roomLeft": "Salle quittée.",
                "toast.roomTourUpdated": "Le tour dans la salle a été mis à jour !",
                "toast.nameSaved": "Nom enregistré !",
                "toast.warningReported": "Danger signalé !",
                "toast.hutsLoadingError": "Impossible de charger les refuges. Essai données hors ligne...",
                "toast.offlineHutsLoaded": "Refuges hors ligne chargés.",
                "toast.offlineHutsNotFound": "Aucun refuge hors ligne trouvé.",
                "toast.offlineRouteLoaded": "Dernier itinéraire (hors ligne) chargé.",
                "toast.offlineRouteError": "Erreur chargement itinéraire hors ligne.",
                "toast.offlineElevationError": "Hors ligne. Profil d'élévation indisponible.",
                "toast.elevationError": "Impossible de charger le profil d'élévation.",
                "toast.smartBreak": "Vous roulez depuis une heure. C'est l'heure d'une pause ?",
                "toast.hutsNotLoaded": "Chargement des refuges en cours. Veuillez patienter.",
                "toast.inviteLinkCopied": "Lien d'invitation copié dans le presse-papiers !",
                "toast.roomRejoin": "Voulez-vous rejoindre la salle \"{id}\" ?",
                "toast.sosLocationError": "Impossible d'obtenir la localisation pour SOS.",
                "toast.firebaseError": "Erreur de connexion. Veuillez réessayer plus tard.", // Nouveau
                "toast.gpsUnavailable": "GPS indisponible. Utilisation de la position par défaut.", // Nouveau
                "toast.gpsDenied": "Accès GPS refusé. Utilisation de la position par défaut.", // Nouveau
                "toast.gpsTimeout": "Délai GPS dépassé. Essai avec précision standard...", // Nouveau
                "toast.gpsDeniedWatch": "Accès GPS refusé pendant le suivi.", // Nouveau
                "toast.gpsUnavailableWatch": "Position GPS temporairement indisponible pendant le suivi.", // Nouveau
                "popup.aiSuggestionTitle": "Suggestion IA : {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>Les arrêts ont été ajoutés à votre tour.</p>",
                "popup.aiSummaryTitle": "✨ Votre Résumé de Tour",
                "popup.hut.loading": "Chargement...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "Horaires",
                "popup.hut.openingHours.always": "Toujours ouvert ✅",
                "popup.hut.openingHours.unknown": "Non disponible",
                "popup.hut.animals": "Animaux",
                "popup.hut.animals.none": "Aucun",
                "popup.hut.power": "Électricité",
                "popup.hut.power.unknown": "n/a",
                "popup.hut.seats": "Places",
                "popup.hut.seats.unknown": "n/a",
                "popup.hut.premiumInfo": "Info Premium",
                "popup.hut.addBtn": "Ajouter au Tour",
                "popup.hut.removeBtn": "Retirer du Tour",
                "elevation.yAxisLabel": "Altitude (m)",
                "elevation.tooltipLabel": "{value} m Altitude",
                "sos.title": "Confirmation Urgence SOS",
                "sos.description": "Vérifiez le message, ajoutez des détails si nécessaire, puis envoyez via WhatsApp.",
                "sos.customMessageLabel": "Message Supplémentaire (optionnel):",
                "sos.customMessagePlaceholder": "ex: Suis tombé, batterie faible",
                "sos.sendBtn": "Envoyer SOS via WhatsApp",
                "sos.baseMessage": "🚨 Urgence SOS 🚨 J'ai besoin d'aide !",
            },
            nl: { /* Dutch */
                "app.title": "RadlMap Navigatie 🚲 (Slimmer)",
                "loader.text": "Kaart laden...",
                "general.offline": "OFFLINE",
                "general.save": "Opslaan",
                "general.cancel": "Annuleren",
                "general.report": "Melden",
                "general.loading": "Laden...",
                "general.state.active": "geactiveerd", // Nieuw
                "general.state.paused": "gepauzeerd", // Nieuw
                "dashboard.title": "Dashboard",
                "tabs.tour": "Tour",
                "tabs.room": "Ruimte",
                "tabs.profile": "Profiel",
                "tabs.stats": "Statistieken",
                "tabs.setup": "Instellingen",
                "tour.aiTitle": "✨ AI Tourplanner",
                "tour.aiDesc": "Houdt rekening met uw voorkeuren & het weer!",
                "tour.difficulty.easy": "Makkelijk",
                "tour.difficulty.medium": "Gemiddeld",
                "tour.difficulty.hard": "Uitdagend",
                "tour.aiSuggestBtn": "Voorstellen",
                "tour.aiSuggestBtn.loading": "Denken...",
                "tour.stopsTitle": "📋 Geselecteerde Stops",
                "tour.stopsDesc": "Verander de volgorde via Drag & Drop.",
                "tour.stopsEmpty": "Nog geen stops geselecteerd. Klik op een hut op de kaart of laat de AI een tour voorstellen.",
                "tour.stats": "Tour: {dist} km, ca. {time} min",
                "tour.stats.addMore": "Voeg nog een stop toe om een route te plannen.",
                "tour.aiSummaryBtn": "✨ Toursamenvatting",
                "tour.aiSummaryBtn.loading": "...",
                "room.title": "👥 Ruimtebeheer",
                "room.inRoom": "U bent in ruimte:",
                "room.guide.isGuide": "U bent de gids.",
                "room.guide.isOther": "Gids: {name}",
                "room.guide.noGuide": "Niemand leidt deze tour.",
                "room.becomeGuide": "Gids worden",
                "room.leaveGuide": "Gidsrol opgeven",
                "room.guidedTourActive": "Een begeleide tour is actief.",
                "room.leaveBtn": "Ruimte verlaten",
                "room.activeUsers": "Actieve gebruikers in de ruimte:",
                "room.noActiveUsers": "Geen andere gebruikers actief.",
                 "room.roomIdPlaceholderJoinCreate": "Ruimte-ID (leeg voor nieuw)",
                "room.joinCreateBtn": "Deelnemen / Maken",
                "room.joinHintSmart": "Voer een ruimte-ID in om deel te nemen, of laat leeg om een nieuwe ruimte te maken.",
                "room.copyInviteLink": "Uitnodigingslink kopiëren",
                "profile.title": "👤 Mijn Profiel",
                "profile.nameLabel": "Uw Naam",
                "profile.namePlaceholder": "Uw weergavenaam",
                "profile.sosBtn": "SOS Noodoproep",
                "stats.title": "📊 Mijn Statistieken",
                "stats.desc": "Hier zijn uw opgeslagen tours.",
                "stats.loading": "Statistieken laden...",
                "stats.empty": "U heeft nog geen tours voltooid.",
                "stats.tourCard.stops": "Stops",
                "stats.loadingError": "Fout bij laden statistieken.", // Nieuw
                "setup.title": "⚙️ Instellingen",
                "setup.intensityLabel": "Voorkeursintensiteit",
                "setup.intensity.flat": "Vrij vlak",
                "setup.intensity.hilly": "Heuvelachtig",
                "setup.intensity.climbs": "Uitdagende beklimmingen",
                "setup.typeLabel": "Voorkeurstype Tour",
                "setup.type.nature": "Natuurgericht",
                "setup.type.culinary": "Culinair",
                "setup.type.culture": "Culturele bezienswaardigheden",
                "setup.languageLabel": "🗣️ App-taal",
                "setup.privacyLink": "Privacy & Juridisch",
                "toolbar.start": "Start",
                "toolbar.stop": "Stop",
                "warning.title": "Gevaar melden op deze locatie",
                "warning.typeLabel": "Type Gevaar",
                "warning.type.pothole": "Gat in de weg",
                "warning.type.obstacle": "Obstakel",
                "warning.type.crossing": "Gevaarlijke oversteek",
                "warning.type.other": "Anders",
                "warning.descLabel": "Korte Beschrijving (optioneel)",
                "warning.descPlaceholder": "bijv. Diepe sleuf",
                "toast.followOn": "Volgmodus {state}", // Veranderd
                "toast.followOff": "Volgmodus {state}", // Veranderd
                "toast.voiceOn": "Stembegeleiding geactiveerd",
                "toast.voiceOff": "Stembegeleiding gedeactiveerd",
                "toast.apiKeyWarning": "AI-functie mislukt: API-sleutel niet geconfigureerd.",
                "toast.geminiError": "Er is een fout opgetreden bij de AI-functie.",
                "toast.offlineAI": "Offline. AI-functies niet beschikbaar.",
                "toast.routeError": "Kon route niet berekenen.",
                "toast.allStopsReached": "🏆 Alle stops bereikt!",
                "toast.allStopsReached.speak": "Gefeliciteerd, u heeft alle bestemmingen bereikt!",
                "toast.routeDeviation": "Van route af, herberekenen...",
                "toast.routeUpdating": "Route bijwerken...",
                "toast.previewLoading": "Routevoorbeeld berekenen...",
                "toast.navStarting": "Navigatie starten...",
                "toast.navStarted": "Navigatie gestart!",
                "toast.navStopped": "Navigatie gestopt.",
                "toast.noStops": "Selecteer eerst minimaal één stop.",
                "toast.guideOnly": "Alleen de gids kan dit doen.",
                "toast.guideExists": "Er is al een gids.",
                "toast.roomJoined": "Deelgenomen aan ruimte {id}.",
                "toast.roomCreated": "Nieuwe ruimte {id} gemaakt.",
                "toast.roomLeft": "Ruimte verlaten.",
                "toast.roomTourUpdated": "Tour in ruimte is bijgewerkt!",
                "toast.nameSaved": "Naam opgeslagen!",
                "toast.warningReported": "Gevaar gemeld!",
                "toast.hutsLoadingError": "Kon hutten niet laden. Offline gegevens proberen...",
                "toast.offlineHutsLoaded": "Offline hutten geladen.",
                "toast.offlineHutsNotFound": "Geen offline hutten gevonden.",
                "toast.offlineRouteLoaded": "Laatst geplande route (offline) geladen.",
                "toast.offlineRouteError": "Fout bij laden offline route.",
                "toast.offlineElevationError": "Offline. Hoogteprofiel kan niet worden geladen.",
                "toast.elevationError": "Kon hoogteprofiel niet laden.",
                "toast.smartBreak": "U fietst al een uur. Tijd voor een korte pauze?",
                "toast.hutsNotLoaded": "Hutten worden nog geladen. Even geduld a.u.b.",
                "toast.inviteLinkCopied": "Uitnodigingslink naar klembord gekopieerd!",
                "toast.roomRejoin": "Wilt u opnieuw deelnemen aan ruimte \"{id}\"?",
                "toast.sosLocationError": "Kon locatie voor SOS niet ophalen.",
                "toast.firebaseError": "Verbindingsfout. Probeer het later opnieuw.", // Nieuw
                "toast.gpsUnavailable": "GPS niet beschikbaar. Terugvalpositie wordt gebruikt.", // Nieuw
                "toast.gpsDenied": "GPS-toegang geweigerd. Terugvalpositie wordt gebruikt.", // Nieuw
                "toast.gpsTimeout": "GPS Timeout. Standaard nauwkeurigheid proberen...", // Nieuw
                "toast.gpsDeniedWatch": "GPS-toegang geweigerd tijdens volgen.", // Nieuw
                "toast.gpsUnavailableWatch": "GPS-positie tijdelijk niet beschikbaar tijdens volgen.", // Nieuw
                "popup.aiSuggestionTitle": "AI Suggestie: {title}",
                "popup.aiSuggestionBody": "<p>{desc}</p><p class='mt-2 text-sm'>De stops zijn aan uw tour toegevoegd.</p>",
                "popup.aiSummaryTitle": "✨ Uw Toursamenvatting",
                "popup.hut.loading": "Laden...",
                "popup.hut.premium": "PREMIUM",
                "popup.hut.openingHours": "Openingstijden",
                "popup.hut.openingHours.always": "Altijd open ✅",
                "popup.hut.openingHours.unknown": "Geen informatie",
                "popup.hut.animals": "Dieren",
                "popup.hut.animals.none": "Geen",
                "popup.hut.power": "Stroom",
                "popup.hut.power.unknown": "n.v.t.",
                "popup.hut.seats": "Zitplaatsen",
                "popup.hut.seats.unknown": "n.v.t.",
                "popup.hut.premiumInfo": "Premium Info",
                "popup.hut.addBtn": "Toevoegen aan Tour",
                "popup.hut.removeBtn": "Verwijderen uit Tour",
                "elevation.yAxisLabel": "Hoogte (m)",
                "elevation.tooltipLabel": "{value} m Hoogte",
                "sos.title": "SOS Noodoproep Bevestiging",
                "sos.description": "Controleer het bericht, voeg details toe indien nodig en verstuur dan via WhatsApp.",
                "sos.customMessageLabel": "Extra Bericht (optioneel):",
                "sos.customMessagePlaceholder": "bijv. Gevallen, batterij bijna leeg",
                "sos.sendBtn": "Verstuur SOS via WhatsApp",
                "sos.baseMessage": "🚨 NOODOPROEP 🚨 Ik heb hulp nodig!",
            }
        },
        currentLang: 'de',
        init() { /* Unchanged */
            const select = document.getElementById('appLangSelect');
            if (!select) return;
            const languages = { 'de': 'Deutsch', 'en': 'English', 'es': 'Español', 'fr': 'Français', 'nl': 'Nederlands' };
            select.innerHTML = '';
            for (const [code, name] of Object.entries(languages)) {
                const option = document.createElement('option');
                option.value = code;
                option.textContent = name;
                select.appendChild(option);
            }
            const savedLang = localStorage.getItem('appLang') || 'de';
            select.value = savedLang;
            this.setLanguage(savedLang);
            select.addEventListener('change', (e) => this.setLanguage(e.target.value));
        },
        setLanguage(lang) { /* Unchanged */
            if (!this.translations[lang]) lang = 'de';
            this.currentLang = lang;
            appState.currentLang = lang;
            localStorage.setItem('appLang', lang);
            document.documentElement.lang = lang;
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.dataset.i18n;
                const translation = this.getString(key);
                if (translation !== key) { // Check if translation was found
                     if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') { /* Placeholder handled below */ }
                     else { el.textContent = translation; }
                }
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.dataset.i18nPlaceholder;
                const translation = this.getString(key);
                 if (translation !== key) { el.placeholder = translation; }
            });
            uiManager.updateSelectedList();
            uiManager.updateRoomUI(appState.currentRoom, []);
             if(uiManager.elevationChartInstance) {
                 try { // Add try-catch for safety
                    uiManager.elevationChartInstance.options.scales.y.title.text = this.getString('elevation.yAxisLabel');
                    uiManager.elevationChartInstance.options.plugins.tooltip.callbacks.label = (context) => this.getString('elevation.tooltipLabel', { value: context.parsed.y.toFixed(0) });
                    uiManager.elevationChartInstance.update('none'); // Update without animation
                 } catch (e) { console.error("Error updating chart language:", e); }
             }
         },
        // *** KORRIGIERTE getString Funktion ***
        getString(key, replacements = {}) {
            const keys = key.split('.');
            let langDict = this.translations[this.currentLang];
            let fallbackDict = this.translations['de']; // Immer Deutsch als Fallback
            let result = langDict;
            let fallbackResult = fallbackDict;
            let found = true;

            // Versuche, den Wert in der aktuellen Sprache zu finden
            for (const k of keys) {
                if (result && typeof result === 'object' && k in result) {
                    result = result[k];
                } else {
                    found = false;
                    break;
                }
            }

            // Wenn nicht gefunden UND nicht Deutsch, versuche Fallback auf Deutsch
            if (!found && this.currentLang !== 'de') {
                found = true; // Assume fallback might work
                for (const k of keys) {
                     if (fallbackResult && typeof fallbackResult === 'object' && k in fallbackResult) {
                         fallbackResult = fallbackResult[k];
                     } else {
                        found = false; // Fallback also failed
                        break;
                     }
                }
                if (found) {
                    result = fallbackResult; // Use the German fallback value
                }
            }

            // Wenn immer noch nicht gefunden oder kein String, gib Key zurück
            if (!found || typeof result !== 'string') {
                console.warn(`i18n key not found or not a string: ${key} for lang ${this.currentLang}`);
                return key;
            }

            let str = result;
            // Ersetze Platzhalter
            for (const [placeholder, value] of Object.entries(replacements)) {
                 const regex = new RegExp(`{${placeholder}}`, 'g');
                str = str.replace(regex, value);
            }
            return str;
        }
    };

    // ----------------------------------------------------------
    //  3. UI MANAGER
    // ----------------------------------------------------------
    const uiManager = { /* UI Manager (wie vorher) */
        elevationChartInstance: null,
        init() {
            this.initTheme();
            this.initTabs();
            this.updateVoiceButton();
            this.updateFollowButton();
            i18nManager.init();
            ttsManager.init();
            window.addEventListener('offline', () => document.getElementById('offline-indicator')?.classList.remove('hidden'));
            window.addEventListener('online', () => document.getElementById('offline-indicator')?.classList.add('hidden'));
            if (!navigator.onLine) document.getElementById('offline-indicator')?.classList.remove('hidden');
        },
        toggleSidebar() {
            appState.isSidebarOpen = !appState.isSidebarOpen;
            document.getElementById('sidebar-panel')?.classList.toggle('open', appState.isSidebarOpen);
            if(mapManager.map) setTimeout(() => mapManager.map.invalidateSize(), 400);
        },
        initTheme() {
            const savedTheme = localStorage.getItem('theme');
            appState.isDarkTheme = savedTheme === 'dark';
            document.body.classList.toggle('dark', appState.isDarkTheme);
            this.updateThemeButton();
        },
        toggleTheme() {
            appState.isDarkTheme = !appState.isDarkTheme;
            localStorage.setItem('theme', appState.isDarkTheme ? 'dark' : 'light');
            document.body.classList.toggle('dark', appState.isDarkTheme);
            this.updateThemeButton();
            if(mapManager.tileLayer) {
                mapManager.map.removeLayer(mapManager.tileLayer);
                mapManager.addTileLayer();
            }
            if(this.elevationChartInstance && routeManager.routeData) {
                 this.displayElevationChart(routeManager.elevationData);
            }
        },
        updateThemeButton() {
            const icon = appState.isDarkTheme ? '☀️' : '🌙';
            const btn = document.getElementById('theme-toggle-btn');
            if (btn) btn.textContent = icon;
        },
        updateVoiceButton() {
            const icon = appState.isVoiceOn ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>` : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v-2a7 7 0 0 0-11.21-.83"></path></svg>`;
            const btn = document.getElementById('voice-toggle');
            if (btn) btn.innerHTML = icon;
        },
        updateFollowButton() {
            const icon = appState.isFollowing ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Z M12 2.25a.75.75 0 0 1 .75.75v.31A9.743 9.743 0 0 1 21.435 12a.75.75 0 0 1-1.493.102 8.243 8.243 0 0 0-7.942-7.942A.75.75 0 0 1 12 2.25Z"/></svg>` : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>`;
            const btn = document.getElementById('follow-toggle');
            if (btn) btn.innerHTML = icon;
        },
        setLoading(isLoading, text = i18nManager.getString('general.loading')) {
            const loader = document.getElementById('loader');
            if (!loader) return;
            if (isLoading) {
                const p = loader.querySelector('p');
                if (p) p.textContent = text;
                loader.style.display = 'flex';
                loader.style.opacity = '1';
            } else {
                loader.style.opacity = '0';
                setTimeout(() => { if(loader) loader.style.display = 'none'; }, 500); // Add check inside timeout
            }
        },
        showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            // Use a variable to clear timeout if another toast comes quickly
             if (this.toastTimer) clearTimeout(this.toastTimer);
             this.toastTimer = setTimeout(() => toast.classList.remove('show'), 3000);
        },
        updateSelectedList() {
            const listEl = document.getElementById('selectedList');
            const actionsEl = document.getElementById('tour-actions');
            if (!listEl || !actionsEl) return;

            if (appState.selectedHuts.length === 0) {
                listEl.innerHTML = `<li class="text-sm text-gray-500">${i18nManager.getString('tour.stopsEmpty')}</li>`;
                actionsEl.classList.add('hidden');
                return;
            }
            listEl.innerHTML = appState.selectedHuts.map((hut, index) => `...`).join(''); // Simplified for brevity
             listEl.innerHTML = appState.selectedHuts.map((hut, index) => `
                <li draggable="true" ondragstart="dragAndDrop.start(event, ${index})" ondrop="dragAndDrop.drop(event, ${index})" ondragover="event.preventDefault()" class="flex items-center justify-between p-2 rounded-lg bg-gray-100 dark:bg-gray-700 cursor-grab" data-index="${index}">
                    <span class="font-medium text-sm">#${index + 1}: ${hut.name}</span>
                    <button onclick="routeManager.removeSelected(${index})" class="p-1 text-red-500 hover:text-red-700" aria-label="Remove ${hut.name}">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </li>
            `).join('');

            this.updateChallengeStatus();
            actionsEl.classList.remove('hidden');
        },
        updateChallengeStatus() {
            const statusEl = document.getElementById('challenge-status');
            if (!statusEl) return;
            if (appState.selectedHuts.length > 0) {
                 statusEl.textContent = `🏆 ${i18nManager.getString('stats.tourCard.stops')}: ${appState.visitedStops.size} / ${appState.selectedHuts.length}`;
            } else {
                statusEl.textContent = '';
            }
        },
        updateSpeedWidget(speed) {
            const widget = document.getElementById('speed-widget');
            const speedSpan = widget?.querySelector('span');
            if (!speedSpan) return;
            const speedText = speed !== null && speed > 0.5 ? `${speed.toFixed(0)} km/h` : `0 km/h`;
            if (speedSpan.textContent !== speedText) speedSpan.textContent = speedText;
        },
        setNavigationState(isNavigating) {
            const isGuide = appState.currentRoom.id && appState.currentRoom.guideId === userManager.userId;
            const isFollower = appState.currentRoom.id && appState.currentRoom.guideId && !isGuide;
            appState.isNavigating = isNavigating;
            document.getElementById('startBtn')?.classList.toggle('hidden', isNavigating || isFollower);
            document.getElementById('stopBtn')?.classList.toggle('hidden', !isNavigating || isFollower);
            const resetBtn = document.getElementById('resetBtn'); if (resetBtn) resetBtn.disabled = isFollower;
            document.getElementById('follow-toggle')?.classList.toggle('hidden', !isNavigating);
            document.getElementById('speed-widget')?.classList.toggle('hidden', !isNavigating);
            if(!isNavigating) {
                 document.getElementById('navHint')?.classList.add('hidden');
                 this.updateSpeedWidget(null);
            } else {
                 document.getElementById('speed-widget')?.classList.remove('hidden');
                 this.updateSpeedWidget(0);
            }
        },
        initTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabPanels = document.querySelectorAll('.tab-panel');
            tabButtons[0]?.classList.add('bg-gray-200', 'dark:bg-gray-700');
            tabPanels[0]?.classList.remove('hidden');
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('bg-gray-200', 'dark:bg-gray-700'));
                    tabPanels.forEach(panel => panel.classList.add('hidden'));
                    button.classList.add('bg-gray-200', 'dark:bg-gray-700');
                    const tabId = button.dataset.tab;
                    const targetPanel = document.getElementById(tabId);
                    if (targetPanel) targetPanel.classList.remove('hidden');
                    if (tabId === 'tab-stats') firebaseManager.loadTourLogs();
                });
            });
        },
        showNavHint(icon, text) {
            const hintEl = document.getElementById('navHint');
             if (!hintEl) return;
            hintEl.innerHTML = `${icon} <span class="text-sm font-semibold">${text}</span>`;
            hintEl.classList.remove('hidden');
             setTimeout(() => hintEl.classList.add('visible'), 10);
            if (this.navHintTimer) clearTimeout(this.navHintTimer);
            this.navHintTimer = setTimeout(() => hintEl.classList.remove('visible'), 8000);
        },
       getTurnIcon(type) {
           if (!type) return '⬆️';
           const maneuverType = type.toLowerCase();
            if (maneuverType.includes('sharp left')) return '↙️'; if (maneuverType.includes('slight left')) return '↖️'; if (maneuverType.includes('left')) return '⬅️';
            if (maneuverType.includes('sharp right')) return '↘️'; if (maneuverType.includes('slight right')) return '↗️'; if (maneuverType.includes('right')) return '➡️';
            if (maneuverType.includes('roundabout') || maneuverType.includes('rotary')) return '🔄';
            if (maneuverType.includes('arrive')) return '🏁'; if (maneuverType.includes('depart')) return '🏁';
            if (maneuverType.includes('merge')) return '➿'; if (maneuverType.includes('fork')) return '🍴'; if (maneuverType.includes('end of road')) return '🛑';
            return '⬆️';
        },
        updateRoomUI(roomData, users = []) {
            const inRoom = !!roomData?.id;
            document.getElementById('room-active-view')?.classList.toggle('hidden', !inRoom);
            document.getElementById('room-join-view')?.classList.toggle('hidden', inRoom);
            if(inRoom) {
                 document.getElementById('current-room-id').textContent = roomData.id;
                const guideInfo = document.getElementById('guide-info');
                const guideBtn = document.getElementById('guide-btn');
                const isSelfGuide = roomData.guideId === userManager.userId;
                 if (guideInfo && guideBtn) {
                    if (roomData.guideId) {
                        guideInfo.textContent = isSelfGuide ? i18nManager.getString('room.guide.isGuide') : i18nManager.getString('room.guide.isOther', { name: roomData.guideName || '...' });
                        guideBtn.textContent = isSelfGuide ? i18nManager.getString('room.leaveGuide') : i18nManager.getString('room.becomeGuide');
                        guideBtn.disabled = !isSelfGuide && !!roomData.guideId;
                    } else {
                        guideInfo.textContent = i18nManager.getString('room.guide.noGuide');
                        guideBtn.textContent = i18nManager.getString('room.becomeGuide');
                        guideBtn.disabled = false;
                    }
                 }
                const guidedTourInfo = document.getElementById('guided-tour-info');
                if (guidedTourInfo) guidedTourInfo.classList.toggle('hidden', !roomData.guideId || !roomData.isNavigating || isSelfGuide);
                const userListEl = document.getElementById('room-user-list');
                if(userListEl) {
                    userListEl.innerHTML = users.length > 0
                        ? users.map(user => `<li>- ${user.name || 'Anonym'}</li>`).join('')
                        : `<li>${i18nManager.getString('room.noActiveUsers')}</li>`;
                }
            }
            const activeView = document.getElementById('room-active-view'); if(activeView) activeView.style.display = inRoom ? '' : 'none';
            const joinView = document.getElementById('room-join-view'); if(joinView) joinView.style.display = inRoom ? 'none' : '';
        },
        openPopup(title, htmlContent) {
            const overlay = document.getElementById("popupOverlay"); const content = document.getElementById("popupContent"); if (!overlay || !content) return;
            overlay.classList.remove("hidden");
            content.innerHTML = `<div class="flex justify-between items-center mb-4 pb-2 border-b border-[var(--border-color)]"><h2 class="text-xl font-bold">${title}</h2><button onclick="uiManager.closePopup()" class="p-1 -mr-2 text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-white" aria-label="Close popup">&times;</button></div><div class="prose dark:prose-invert max-w-none">${htmlContent}</div>`;
        },
        closePopup() {
            const overlay = document.getElementById("popupOverlay"); if (overlay) overlay.classList.add("hidden");
            const content = document.getElementById("popupContent"); if (content) content.innerHTML = '';
        },
        showAddWarningModal(latlng) { this.tempWarningLatLng = latlng; document.getElementById('add-warning-modal')?.classList.remove('hidden'); },
        hideAddWarningModal() { document.getElementById('add-warning-modal')?.classList.add('hidden'); const descInput = document.getElementById('warning-description'); if (descInput) descInput.value = ''; },
        displayElevationChart(elevationData) {
            const container = document.getElementById('elevation-chart-container'); const canvas = document.getElementById('elevation-chart'); if (!container || !canvas) return;
            const ctx = canvas.getContext('2d');
            if (this.elevationChartInstance) { this.elevationChartInstance.destroy(); this.elevationChartInstance = null; }
            if (!elevationData?.elevation || elevationData.elevation.length === 0) { container.classList.add('hidden'); return; }
            container.classList.remove('hidden');
            const labels = elevationData.elevation.map((_, index) => index); const data = elevationData.elevation;
            const gridColor = appState.isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)'; const fontColor = appState.isDarkTheme ? '#f9fafb' : '#1f2937';
            const yAxisLabel = i18nManager.getString('elevation.yAxisLabel'); const tooltipFormat = i18nManager.getString('elevation.tooltipLabel');
            this.elevationChartInstance = new Chart(ctx, { /* Chart config... */
                type: 'line', data: { labels, datasets: [{ label: yAxisLabel, data, borderColor: '#3b82f6', backgroundColor: 'rgba(59, 130, 246, 0.1)', fill: true, tension: 0.3, pointRadius: 0 }] },
                options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: false, ticks: { color: fontColor, font: { size: 10 } }, grid: { color: gridColor }, title: { display: true, text: yAxisLabel, color: fontColor, font: { size: 10 } } }, x: { ticks: { display: false }, grid: { display: false } } }, plugins: { legend: { display: false }, tooltip: { enabled: true, intersect: false, mode: 'index', callbacks: { label: (context) => tooltipFormat.replace('{value}', context.parsed.y.toFixed(0)) } } } }
            });
        },
        copyInviteLink() { /* Unchanged */
            if (!appState.currentRoom.id) return; const roomId = appState.currentRoom.id; const inviteLink = `${window.location.origin}${window.location.pathname}?room=${roomId}`;
            if (navigator.clipboard?.writeText) { navigator.clipboard.writeText(inviteLink).then(() => uiManager.showToast(i18nManager.getString('toast.inviteLinkCopied'))).catch(err => { console.error('Async clipboard copy failed:', err); this.fallbackCopyTextToClipboard(inviteLink); }); }
            else { this.fallbackCopyTextToClipboard(inviteLink); }
         },
        fallbackCopyTextToClipboard(text) { /* Unchanged */
            const textArea = document.createElement("textarea"); textArea.value = text; textArea.style.position = 'fixed'; textArea.style.top = '-9999px'; textArea.style.left = '-9999px'; document.body.appendChild(textArea); textArea.focus(); textArea.select();
            try { if (document.execCommand('copy')) { uiManager.showToast(i18nManager.getString('toast.inviteLinkCopied')); } else { console.error('Fallback execCommand copy failed'); uiManager.showToast('Copy failed.'); } }
            catch (err) { console.error('Fallback copy error:', err); uiManager.showToast('Copy failed.'); } document.body.removeChild(textArea);
         }
    };

    // ----------------------------------------------------------
    //  4. MAP MANAGER
    // ----------------------------------------------------------
    const mapManager = { /* Map manager - unchanged */
        map: null, userMarker: null, tileLayer: null, clusterGroup: null, routeLine: null, previewLine: null, pastRouteLine: null, groupMarkers: {}, warningMarkers: {},
        init(center, zoom) { this.map = L.map('map', { center, zoom, zoomControl: false }); L.control.zoom({ position: 'bottomright' }).addTo(this.map); this.addTileLayer(); this.clusterGroup = L.markerClusterGroup(); this.map.addLayer(this.clusterGroup); this.map.on('dragstart', () => { if(appState.isFollowing) appState.toggleFollow() }); this.map.on('contextmenu', (e) => uiManager.showAddWarningModal(e.latlng)); this.map.on('popupopen', (e) => { const swiperEl = e.popup.getElement().querySelector('.popup-swiper'); if (swiperEl && !swiperEl.swiper) { new Swiper(swiperEl, { loop: true, pagination: { el: '.swiper-pagination', clickable: true }, navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev' } }); } }); },
        addTileLayer() { const url = appState.isDarkTheme ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png' : 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'; const attr = '&copy; OpenStreetMap &copy; CARTO'; this.tileLayer = L.tileLayer(url, { attribution: attr, maxZoom: 19 }); this.tileLayer.addTo(this.map); },
        updateUserMarker(latlng, accuracy, bearing) { const iconHtml = `<svg width="48" height="48" viewBox="0 0 48 48" style="transform: rotate(${bearing}deg); transition: transform 0.2s linear;"><circle cx="24" cy="24" r="20" fill="#4285F4" fill-opacity="0.2" class="pulse-circle"/><path d="M24 4 L34 28 H14 Z" fill="#4285F4" stroke="white" stroke-width="2" style="filter: drop-shadow(0px 2px 4px rgba(0,0,0,0.4));"/></svg>`; const userIcon = L.divIcon({ html: iconHtml, className: '', iconSize: [48, 48], iconAnchor: [24, 24] }); if (!this.userMarker) { this.userMarker = L.marker(latlng, { icon: userIcon }).addTo(this.map); } else { this.userMarker.setLatLng(latlng).setIcon(userIcon); } },
        updateGroupMarker(user) { const icon = L.divIcon({ className: 'group-marker', html: `<div style="background-color: ${user.color};" class="p-1 rounded-full shadow-lg">🚴</div><div class="text-xs -mt-1" style="color: ${user.color};">${user.name.substring(0,5)}</div>` }); if (this.groupMarkers[user.id]) { this.groupMarkers[user.id].setLatLng([user.lat, user.lng]); } else { this.groupMarkers[user.id] = L.marker([user.lat, user.lng], { icon }).addTo(this.map); } },
        addWarningMarker(warning) { const icon = L.divIcon({ className: 'warning-icon', html: '⚠️', iconSize: [24, 24] }); const marker = L.marker([warning.lat, warning.lng], { icon: icon }).bindPopup(`<b>${warning.type}</b><br>${warning.description || ''}`).addTo(this.map); this.warningMarkers[warning.id] = marker; },
        removeWarningMarker(warningId) { if (this.warningMarkers[warningId]) { this.map.removeLayer(this.warningMarkers[warningId]); delete this.warningMarkers[warningId]; } },
        removeGroupMarker(userId) { if (this.groupMarkers[userId]) { this.map.removeLayer(this.groupMarkers[userId]); delete this.groupMarkers[userId]; } },
        drawRoute(coordinates, isPreview = false) { const options = isPreview ? { color: "#9ca3af", weight: 5, dashArray: "10, 10" } : { color: "#3b82f6", weight: 6, opacity: 0.8 }; if(isPreview) { if(this.previewLine) this.map.removeLayer(this.previewLine); this.previewLine = L.polyline(coordinates, options).addTo(this.map); } else { if(this.routeLine) this.map.removeLayer(this.routeLine); this.routeLine = L.polyline(coordinates, options).addTo(this.map); if(this.pastRouteLine) this.map.removeLayer(this.pastRouteLine); this.pastRouteLine = L.polyline([], { color: 'gray', weight: 4, opacity: 0.7 }).addTo(this.map); } },
        addPointToPastRoute(latlng) { if (this.pastRouteLine) { this.pastRouteLine.addLatLng(latlng); } },
        clearRoute() { if(this.routeLine) this.map.removeLayer(this.routeLine); if(this.previewLine) this.map.removeLayer(this.previewLine); if(this.pastRouteLine) this.map.removeLayer(this.pastRouteLine); this.routeLine = null; this.previewLine = null; this.pastRouteLine = null; }
     };

    // ----------------------------------------------------------
    //  5. OTHER MANAGERS
    // ----------------------------------------------------------

    const ttsManager = { /* TTS Manager - unchanged */
        init() { const select = document.getElementById("appLangSelect"); if (!select || !window.speechSynthesis) return; select.onchange = () => i18nManager.setLanguage(select.value); const loadVoices = () => { const voices = speechSynthesis.getVoices(); if (voices.length === 0 && 'onvoiceschanged' in speechSynthesis) { speechSynthesis.onvoiceschanged = loadVoices; } }; loadVoices(); },
        async speak(text) { if (!appState.isVoiceOn || !text) return; speechSynthesis.cancel(); const targetLang = appState.currentLang || 'de'; let textToSpeak = text; try { const isLikelyGerman = /[äöüßÄÖÜ]/.test(text) || targetLang === 'de'; if (targetLang !== 'de' && isLikelyGerman && navigator.onLine) { textToSpeak = await geminiManager.translateText(text, targetLang); } else { textToSpeak = text; } } catch (e) { console.error("Fehler beim Übersetzen vor TTS:", e); textToSpeak = text; } if (!textToSpeak) textToSpeak = text; const utterance = new SpeechSynthesisUtterance(textToSpeak); utterance.lang = targetLang; const voices = speechSynthesis.getVoices(); let voice = voices.find(v => v.lang === targetLang && v.localService); if (!voice) voice = voices.find(v => v.lang === targetLang); if (!voice) voice = voices.find(v => v.lang.startsWith(targetLang.split('-')[0]) && v.localService); if (!voice) voice = voices.find(v => v.lang.startsWith(targetLang.split('-')[0])); if (voice) { utterance.voice = voice; } else { console.warn(`No suitable voice found for language ${targetLang}. Using default.`); } utterance.onerror = (event) => console.error(`Speech synthesis error: ${event.error}`); speechSynthesis.speak(utterance); }
     };
    const routeManager = { /* Route Manager - unchanged */
        routeData: null, elevationData: null, recalcTimer: null, announcedSteps: {}, lastRecalcTime: 0,
        async fetchRoute(startCoords, waypoints) { if (!startCoords || typeof startCoords.lat !== 'number' || typeof startCoords.lng !== 'number') { console.error("Invalid start coordinates."); uiManager.showToast(i18nManager.getString('toast.routeError')); return null; } const validWaypoints = waypoints.filter(wp => wp && typeof wp.lat === 'number' && typeof wp.lng === 'number'); const coordinatesString = [`${startCoords.lng},${startCoords.lat}`, ...validWaypoints.map(h => `${h.lng},${h.lat}`)].join(';'); const url = `https://router.project-osrm.org/route/v1/bicycle/${coordinatesString}?overview=full&geometries=geojson&steps=true`; try { const response = await fetch(url); if (!response.ok) { const errorText = await response.text(); console.error(`OSRM API Error ${response.status}:`, errorText); throw new Error(`OSRM API Fehler: ${response.statusText}`); } const data = await response.json(); if (data.code !== 'Ok' || !data.routes?.length) { console.error("OSRM could not find a route:", data.code); throw new Error('OSRM konnte keine Route finden.'); } const route = data.routes[0]; this.routeData = { coords: route.geometry.coordinates.map(p => [p[1], p[0]]), distance: route.distance, duration: route.duration, steps: route.legs.flatMap(leg => leg.steps) }; this.elevationData = await weatherManager.fetchElevation(this.routeData.coords); return this.routeData; } catch (error) { console.error("Fehler bei Routenberechnung/Höhenabfrage:", error); uiManager.showToast(i18nManager.getString('toast.routeError')); this.routeData = null; this.elevationData = null; return null; } },
        checkNextManeuver(userPos) { if (!this.routeData?.steps) return; for (let i = 0; i < this.routeData.steps.length; i++) { const step = this.routeData.steps[i]; let instructionText = step.maneuver.instruction; if (!instructionText?.trim()) { const type = step.maneuver.type || ''; const modifier = step.maneuver.modifier || ''; const road = step.name ? ` auf ${step.name}` : ''; if (type.includes('continue') || type.includes('new name')) instructionText = `Weiter geradeaus ${road}`; else if (type.includes('arrive')) instructionText = `Sie haben Ihr Ziel erreicht${road}`; else if (type.includes('depart')) instructionText = `Starten Sie ${road}`; else instructionText = `${modifier.replace(/_/g, ' ')}${road}`; instructionText = instructionText.charAt(0).toUpperCase() + instructionText.slice(1); } const stepLocation = L.latLng(step.maneuver.location[1], step.maneuver.location[0]); const distance = userPos.distanceTo(stepLocation); if (!this.announcedSteps[i]) this.announcedSteps[i] = { pre: false, imminent: false }; if (distance < 150 && distance > 40 && !this.announcedSteps[i].pre) { this.announcedSteps[i].pre = true; const instructionBase = `In ${Math.round(distance/10)*10} Metern ${instructionText}`; const icon = uiManager.getTurnIcon(step.maneuver.type); geminiManager.translateText(instructionBase, appState.currentLang).then(translatedHint => uiManager.showNavHint(icon, translatedHint || instructionBase)).catch(() => uiManager.showNavHint(icon, instructionBase)); ttsManager.speak(instructionBase); break; } if (distance < 25 && !this.announcedSteps[i].imminent) { this.announcedSteps[i].imminent = true; const instructionBase = `Jetzt ${instructionText}`; const icon = uiManager.getTurnIcon(step.maneuver.type); geminiManager.translateText(instructionBase, appState.currentLang).then(translatedHint => uiManager.showNavHint(icon, translatedHint || instructionBase)).catch(() => uiManager.showNavHint(icon, instructionBase)); ttsManager.speak(instructionBase); const nextHut = appState.selectedHuts.find(hut => hut && typeof hut.lat === 'number' && typeof hut.lng === 'number' && L.latLng(hut.lat, hut.lng).distanceTo(stepLocation) < 50); if (nextHut && !appState.visitedStops.has(nextHut.id)) { appState.visitedStops.add(nextHut.id); uiManager.updateChallengeStatus(); if(appState.visitedStops.size === appState.selectedHuts.length) { uiManager.showToast(i18nManager.getString('toast.allStopsReached')); ttsManager.speak(i18nManager.getString('toast.allStopsReached.speak')); firebaseManager.saveTourLog(this.routeData, appState.selectedHuts, appState.visitedStops); } } break; } } },
        checkDeviation(userPos) { if (!appState.isNavigating || !mapManager.routeLine) return; const now = Date.now(); if (now - this.lastRecalcTime < config.routing.recalcDebounceMs) return; const routeLatLngs = mapManager.routeLine.getLatLngs(); if (!routeLatLngs?.length || routeLatLngs.length < 2) return; const closestPointResult = L.GeometryUtil.closestLayerSnap(mapManager.map, [mapManager.routeLine], userPos, Infinity, false); if (!closestPointResult || closestPointResult.distance === undefined) { console.warn("Could not find closest point on route."); return; } const distance = closestPointResult.distance; if (distance > config.routing.deviationThresholdMeters) { this.lastRecalcTime = now; uiManager.showToast(i18nManager.getString('toast.routeDeviation')); this.startNavigation(); } },
        toggleSelect(hut) { const index = appState.selectedHuts.findIndex(h => h.id === hut.id); if (index > -1) { appState.selectedHuts.splice(index, 1); } else { appState.selectedHuts.push(hut); } uiManager.updateSelectedList(); if (appState.isNavigating) { uiManager.showToast(i18nManager.getString('toast.routeUpdating')); this.startNavigation(); } else { this.recalculatePreviewRoute(); } if(appState.currentRoom.id) firebaseManager.updateRoomHuts(); },
        removeSelected(index) { if (index < 0 || index >= appState.selectedHuts.length) return; appState.selectedHuts.splice(index, 1); uiManager.updateSelectedList(); if (appState.isNavigating) { uiManager.showToast(i18nManager.getString('toast.routeUpdating')); this.startNavigation(); } else { this.recalculatePreviewRoute(); } if(appState.currentRoom.id) firebaseManager.updateRoomHuts(); },
        async recalculatePreviewRoute() { const tourStatsEl = document.getElementById('tour-stats'); const actionsEl = document.getElementById('tour-actions'); if (appState.selectedHuts.length === 0) { mapManager.clearRoute(); this.routeData = null; this.elevationData = null; if (tourStatsEl) tourStatsEl.textContent = ''; uiManager.displayElevationChart(null); actionsEl?.classList.add('hidden'); return; } actionsEl?.classList.remove('hidden'); if (appState.selectedHuts.length === 1) { mapManager.clearRoute(); this.routeData = null; this.elevationData = null; if (tourStatsEl) tourStatsEl.textContent = i18nManager.getString('tour.stats.addMore'); uiManager.displayElevationChart(null); return; } uiManager.setLoading(true, i18nManager.getString('toast.previewLoading')); try { const startPos = await userManager.getCurrentPosition(); const route = await this.fetchRoute(startPos, appState.selectedHuts); if(route) { localStorage.setItem('lastRouteData', JSON.stringify(this.routeData)); mapManager.drawRoute(this.routeData.coords, true); if (!appState.isNavigating && mapManager.previewLine) { mapManager.map.fitBounds(mapManager.previewLine.getBounds(), {padding: [50,50]}); } const distanceKm = (this.routeData.distance / 1000).toFixed(1); const durationMin = Math.round(this.routeData.duration / 60); if (tourStatsEl) tourStatsEl.textContent = i18nManager.getString('tour.stats', { dist: distanceKm, time: durationMin }); uiManager.displayElevationChart(this.elevationData); } else { mapManager.clearRoute(); if (tourStatsEl) tourStatsEl.textContent = i18nManager.getString('toast.routeError'); uiManager.displayElevationChart(null); } } catch (error) { console.error("Error in recalculatePreviewRoute:", error); uiManager.showToast(i18nManager.getString('toast.routeError')); mapManager.clearRoute(); this.routeData = null; this.elevationData = null; if (tourStatsEl) tourStatsEl.textContent = ''; uiManager.displayElevationChart(null); } finally { uiManager.setLoading(false); } },
        async startNavigation() { if (appState.currentRoom.id && appState.currentRoom.guideId && appState.currentRoom.guideId !== userManager.userId) { uiManager.showToast(i18nManager.getString('toast.guideOnly')); return; } if (appState.selectedHuts.length === 0) { uiManager.showToast(i18nManager.getString('toast.noStops')); return; } uiManager.setLoading(true, i18nManager.getString('toast.navStarting')); try { const startPos = await userManager.getCurrentPosition(); const route = await this.fetchRoute(startPos, appState.selectedHuts); if(route) { localStorage.setItem('lastRouteData', JSON.stringify(this.routeData)); this.announcedSteps = {}; appState.visitedStops.clear(); appState.navigationStartTime = Date.now(); appState.lastBreakTime = Date.now(); uiManager.updateChallengeStatus(); mapManager.drawRoute(this.routeData.coords, false); mapManager.map.flyTo(startPos, config.map.navigationZoom, { duration: 2.0, easeLinearity: 0.5 }); uiManager.setNavigationState(true); userManager.startWatchingPosition(); uiManager.showToast(i18nManager.getString('toast.navStarted')); uiManager.displayElevationChart(this.elevationData); if (appState.currentRoom.id && appState.currentRoom.guideId === userManager.userId) { const serializableRoute = { coords: this.routeData.coords, distance: this.routeData.distance, duration: this.routeData.duration, steps: this.routeData.steps }; firebaseManager.updateGuidedRoute(true, serializableRoute); } } else { uiManager.showToast(i18nManager.getString('toast.routeError')); } } catch(error) { console.error("Error starting navigation:", error); uiManager.showToast(i18nManager.getString('toast.routeError')); } finally { uiManager.setLoading(false); } },
        stopNavigation() { if (appState.currentRoom.id && appState.currentRoom.guideId && appState.currentRoom.guideId !== userManager.userId) { uiManager.showToast(i18nManager.getString('toast.guideOnly')); return; } if(this.routeData && appState.navigationStartTime && appState.visitedStops.size > 0) { const actualDuration = (Date.now() - appState.navigationStartTime) / 1000; firebaseManager.saveTourLog({ distance: this.routeData.distance, duration: actualDuration }, appState.selectedHuts, appState.visitedStops); } userManager.stopWatchingPosition(); mapManager.clearRoute(); this.routeData = null; this.elevationData = null; this.announcedSteps = {}; appState.navigationStartTime = null; appState.lastBreakTime = null; uiManager.setNavigationState(false); uiManager.showToast(i18nManager.getString('toast.navStopped')); uiManager.displayElevationChart(null); if (appState.currentRoom.id && appState.currentRoom.guideId === userManager.userId) { firebaseManager.updateGuidedRoute(false, null); } this.recalculatePreviewRoute(); },
        resetRoute() { this.stopNavigation(); appState.selectedHuts = []; appState.visitedStops.clear(); uiManager.updateSelectedList(); mapManager.clearRoute(); this.routeData = null; this.elevationData = null; uiManager.displayElevationChart(null); const tourStatsEl = document.getElementById('tour-stats'); if (tourStatsEl) tourStatsEl.textContent = ''; document.getElementById('tour-actions')?.classList.add('hidden'); localStorage.removeItem('lastRouteData'); if(appState.currentRoom.id) firebaseManager.updateRoomHuts(); }
     };
    const userManager = { /* User Manager - Added SOS Modal logic */
        watchId: null, lastPosition: null, userId: localStorage.getItem('radlMapUserId') || `user_${Math.random().toString(36).substring(2, 9)}`, warnedAbout: new Set(),
        init() { localStorage.setItem('radlMapUserId', this.userId); const savedName = localStorage.getItem('username'); if(savedName) document.getElementById('usernameInput').value = savedName; this.getCurrentPosition(true).then(pos => { mapManager.updateUserMarker(pos, 20, 0); mapManager.map.setView(pos, config.map.defaultZoom); weatherManager.fetchWeather(pos.lat, pos.lng); }).finally(() => uiManager.setLoading(false)); /* rejoin moved */ },
        getCurrentPosition(highAccuracy = false) { return new Promise((resolve) => { if (!navigator.geolocation) { uiManager.showToast(i18nManager.getString('toast.gpsUnavailable')); resolve(L.latLng(config.map.defaultCenter[0], config.map.defaultCenter[1])); return; } navigator.geolocation.getCurrentPosition( pos => resolve(L.latLng(pos.coords.latitude, pos.coords.longitude)), async err => { console.warn("GPS Fehler:", err.code, err.message); let errorMsgKey = 'toast.gpsUnavailable'; if (err.code === err.PERMISSION_DENIED) errorMsgKey = 'toast.gpsDenied'; else if (err.code === err.POSITION_UNAVAILABLE) errorMsgKey = 'toast.gpsUnavailable'; else if (err.code === err.TIMEOUT) errorMsgKey = 'toast.gpsTimeout'; const errorMsg = i18nManager.getString(errorMsgKey); if(highAccuracy && err.code !== err.PERMISSION_DENIED) { if(err.code === err.TIMEOUT) uiManager.showToast(errorMsg); resolve(await this.getCurrentPosition(false)); } else { uiManager.showToast(errorMsg); resolve(L.latLng(config.map.defaultCenter[0], config.map.defaultCenter[1])); } }, { enableHighAccuracy: highAccuracy, timeout: highAccuracy ? 10000 : 6000, maximumAge: 60000 } ); }); },
        startWatchingPosition() { if (this.watchId) return; if (!navigator.geolocation) { console.error("Geolocation not supported."); return; } const options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }; this.watchId = navigator.geolocation.watchPosition( pos => { const currentPos = L.latLng(pos.coords.latitude, pos.coords.longitude); let bearing = 0; if (this.lastPosition && (this.lastPosition.lat !== currentPos.lat || this.lastPosition.lng !== currentPos.lng)) { bearing = this.getBearing(this.lastPosition, currentPos); } let speedKmh = null; if (pos.coords.speed !== null && pos.coords.speed >= 0) { speedKmh = pos.coords.speed * 3.6; } uiManager.updateSpeedWidget(speedKmh); mapManager.updateUserMarker(currentPos, pos.coords.accuracy, bearing); if (appState.isFollowing) mapManager.map.panTo(currentPos); if(appState.isNavigating) { routeManager.checkNextManeuver(currentPos); routeManager.checkDeviation(currentPos); mapManager.addPointToPastRoute(currentPos); this.checkSmartAlerts(); } if(appState.currentRoom.id) firebaseManager.updateUserPositionInRoom(currentPos); weatherManager.fetchWeather(currentPos.lat, currentPos.lng); this.checkProximityToWarnings(currentPos); this.lastPosition = currentPos; }, err => { console.error("GPS Watch Fehler:", err.code, err.message); if (err.code === err.PERMISSION_DENIED) { uiManager.showToast(i18nManager.getString('toast.gpsDeniedWatch')); this.stopWatchingPosition(); } else if (err.code === err.POSITION_UNAVAILABLE) { uiManager.showToast(i18nManager.getString('toast.gpsUnavailableWatch')); } }, options ); },
        stopWatchingPosition() { if(this.watchId) { navigator.geolocation.clearWatch(this.watchId); this.watchId = null; console.log("Stopped watching position."); } uiManager.updateSpeedWidget(null); this.lastPosition = null; },
        getBearing(from, to) { const lat1 = from.lat * Math.PI / 180; const lat2 = to.lat * Math.PI / 180; const dLon = (to.lng - from.lng) * Math.PI / 180; const y = Math.sin(dLon) * Math.cos(lat2); const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon); let brng = Math.atan2(y, x) * 180 / Math.PI; return (brng + 360) % 360; },
        checkProximityToWarnings(userPos) { for (const warning of appState.allWarnings) { if (!this.warnedAbout.has(warning.id)) { const warningPos = L.latLng(warning.lat, warning.lng); const distance = userPos.distanceTo(warningPos); if (distance < 100) { const messageBase = `Achtung, in ${Math.round(distance/10)*10} Metern gemeldete Gefahr: ${warning.type}.`; ttsManager.speak(messageBase); geminiManager.translateText(messageBase, appState.currentLang).then(translatedMsg => uiManager.showToast(translatedMsg || messageBase)).catch(() => uiManager.showToast(messageBase)); this.warnedAbout.add(warning.id); } } } },
        checkSmartAlerts() { if (!appState.isNavigating || !appState.navigationStartTime) return; const now = Date.now(); const lastActivityTime = appState.lastBreakTime || appState.navigationStartTime; const timeSinceLastBreak = now - lastActivityTime; if (timeSinceLastBreak > 3600000) { const message = i18nManager.getString('toast.smartBreak'); ttsManager.speak(message); uiManager.showToast(message); appState.lastBreakTime = now; } },
        saveUsername() { const nameInput = document.getElementById('usernameInput'); if (!nameInput) return; const name = nameInput.value.trim(); if(name) { localStorage.setItem('username', name); uiManager.showToast(i18nManager.getString('toast.nameSaved')); if (appState.currentRoom.id && userManager.lastPosition) { firebaseManager.updateUserPositionInRoom(userManager.lastPosition); } } },
        // *** SMART SOS ***
        async showSOSModal() {
            const overlay = document.getElementById('sos-modal-overlay');
            if (!overlay) { console.error("SOS Modal overlay element not found!"); return; }
            overlay.classList.remove('hidden'); // Show overlay immediately
            try {
                uiManager.setLoading(true, i18nManager.getString('general.loading')); // Show loading indicator
                const pos = await this.getCurrentPosition(true);
                const link = `https://maps.google.com/?q=${pos.lat},${pos.lng}`;
                const now = new Date();
                const timestamp = now.toLocaleTimeString(appState.currentLang || 'de', { hour: '2-digit', minute: '2-digit' });
                const username = localStorage.getItem('username') || 'Anonym';
                const baseMessage = i18nManager.getString('sos.baseMessage');
                appState.currentSOSData = { link, timestamp, baseMessage, username }; // Store data

                // Populate modal fields safely
                const usernameEl = document.getElementById('sos-username'); if (usernameEl) usernameEl.textContent = username;
                const timestampEl = document.getElementById('sos-timestamp'); if (timestampEl) timestampEl.textContent = timestamp;
                const linkEl = document.getElementById('sos-location-link'); if (linkEl) { linkEl.href = link; linkEl.textContent = `${pos.lat.toFixed(5)}, ${pos.lng.toFixed(5)}`; }
                const baseMsgEl = document.getElementById('sos-base-message'); if (baseMsgEl) baseMsgEl.textContent = baseMessage; // Ensure base message is also set dynamically if translated
                const customMsgInput = document.getElementById('sos-custom-message'); if (customMsgInput) customMsgInput.value = '';

                uiManager.setLoading(false); // Hide loading indicator
                // Ensure overlay is still visible (it was shown at the start)

            } catch (error) {
                console.error("Error preparing SOS modal:", error);
                uiManager.setLoading(false); // Hide loading on error
                uiManager.showToast(i18nManager.getString('toast.sosLocationError'));
                this.hideSOSModal(); // Hide modal if location fails
            }
        },
        hideSOSModal() {
            const overlay = document.getElementById('sos-modal-overlay');
            if (overlay) overlay.classList.add('hidden'); // Use add('hidden')
             // Optional: Clear custom message input on close
             const customMsgInput = document.getElementById('sos-custom-message'); if (customMsgInput) customMsgInput.value = '';
        },
        sendSOS() { // Called by the "Send" button in the modal
            const { link, timestamp, baseMessage, username } = appState.currentSOSData;
            const customMessageInput = document.getElementById('sos-custom-message');
            const customMessage = customMessageInput ? customMessageInput.value.trim() : '';

            // Construct final message
            let message = `${baseMessage}\nVon: ${username}\nZeit: ${timestamp}\nStandort: ${link}`;
            if (customMessage) {
                message += `\nInfo: ${customMessage}`;
            }
            const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(message)}`;
            window.open(whatsappUrl, "_blank"); // Open WhatsApp
            this.hideSOSModal(); // Close the modal
        }
     };
    const geminiManager = { /* Gemini Manager - unchanged */
        async callGemini(prompt, jsonSchema = null) { if (!navigator.onLine) { uiManager.showToast(i18nManager.getString('toast.offlineAI')); return null; } if (!GEMINI_API_KEY || GEMINI_API_KEY === "DEIN_API_KEY_HIER") { console.error("Gemini API Key missing."); uiManager.showToast(i18nManager.getString('toast.apiKeyWarning')); return null; } const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`; const payload = { contents: [{ parts: [{ text: prompt }] }] }; if (jsonSchema) { payload.generationConfig = { responseMimeType: "application/json", responseSchema: jsonSchema }; } let attempts = 0; const maxAttempts = 3; let delay = 1000; while (attempts < maxAttempts) { try { const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) }); if (response.ok) { const result = await response.json(); const candidate = result.candidates?.[0]; if (!candidate?.content?.parts?.[0]?.text) throw new Error("Invalid API response."); return candidate.content.parts[0].text; } else if (response.status === 429 || response.status >= 500) { console.warn(`Gemini API rate limit/server error (${response.status}). Retrying in ${delay / 1000}s...`); await new Promise(resolve => setTimeout(resolve, delay)); delay *= 2; attempts++; } else { throw new Error(`API Error: ${response.status} ${await response.text()}`); } } catch (error) { if (attempts < maxAttempts -1) { console.warn(`Gemini API request failed: ${error}. Retrying in ${delay / 1000}s...`); await new Promise(resolve => setTimeout(resolve, delay)); delay *= 2; attempts++; } else { console.error("Gemini API error after retries:", error); uiManager.showToast(i18nManager.getString('toast.geminiError')); return null; } } } console.error("Gemini API failed after max attempts."); uiManager.showToast(i18nManager.getString('toast.geminiError')); return null; },
        async translateText(text, targetLang) { if (!text || !targetLang || !navigator.onLine || targetLang === 'de') return text; const langName = new Intl.DisplayNames([targetLang], { type: 'language' }).of(targetLang); const sourceLangName = new Intl.DisplayNames(['de'], { type: 'language'}).of('de'); const prompt = `Translate the following ${sourceLangName} text for a bicycle navigation app into ${langName} (lang code ${targetLang}). Keep proper names (streets, places) unchanged. Reply ONLY with the pure translation, no intro/quotes. Text: "${text}"`; try { const translation = await this.callGemini(prompt); return (translation?.trim() && !translation.toLowerCase().includes("translate") && !translation.toLowerCase().includes("sorry")) ? translation.trim() : text; } catch (error) { console.error("TranslateText Error:", error); return text; } },
        async suggestTour(weatherData = null) { if (!navigator.onLine) { uiManager.showToast(i18nManager.getString('toast.offlineAI')); return; } const btn = document.getElementById('suggest-tour-btn'); btn.disabled = true; btn.textContent = i18nManager.getString('tour.aiSuggestBtn.loading'); try { const userPos = await userManager.getCurrentPosition(); if (appState.allHuts.length === 0) { uiManager.showToast(i18nManager.getString('toast.hutsNotLoaded')); return; } const difficultyEl = document.getElementById('tour-difficulty'); const intensityEl = document.getElementById('user-pref-intensity'); const tourTypeEl = document.getElementById('user-pref-type'); const difficulty = difficultyEl.options[difficultyEl.selectedIndex].text; const intensity = intensityEl.options[intensityEl.selectedIndex].text; const tourType = tourTypeEl.options[tourTypeEl.selectedIndex].text; const weatherText = weatherData ? `Current weather: ${weatherData.temperature}°C.` : "Weather unknown."; const hutsString = appState.allHuts.map(h => `id: ${h.id}, name: ${h.name}`).join('; '); const targetLang = appState.currentLang; const langName = new Intl.DisplayNames([targetLang], { type: 'language' }).of(targetLang); const prompt = `I am at ${userPos.lat},${userPos.lng}. Suggest a ${difficulty} bike tour. Preferences: Intensity "${intensity}", Type "${tourType}". ${weatherText}. Select 3-5 stops from: ${hutsString}. List IDs in order. Provide title and description in ${langName} (code "${targetLang}"). Respond ONLY in JSON format:`; const schema = { type: "OBJECT", properties: { "title": { "type": "STRING", description: `Title in ${langName}` }, "description": { "type": "STRING", description: `Description in ${langName}` }, "stop_ids": { "type": "ARRAY", "items": { "type": "STRING" }, description: "Hut IDs array" } }, required: ["title", "description", "stop_ids"] }; const resultText = await this.callGemini(prompt, schema); if (!resultText) return; const resultJson = JSON.parse(resultText); const validStopIds = resultJson.stop_ids.filter(id => appState.allHuts.some(hut => hut.id === id)); if (validStopIds.length !== resultJson.stop_ids.length) console.warn("AI suggested invalid hut IDs."); if (validStopIds.length === 0) { uiManager.showToast("AI couldn't find suitable stops."); return; } uiManager.openPopup(`${i18nManager.getString('popup.aiSuggestionTitle', { title: '' })}${resultJson.title}`, i18nManager.getString('popup.aiSuggestionBody', { desc: resultJson.description })); appState.selectedHuts = validStopIds.map(id => appState.allHuts.find(h => h.id === id)).filter(Boolean); uiManager.updateSelectedList(); routeManager.recalculatePreviewRoute(); if (appState.currentRoom.id) firebaseManager.updateRoomHuts(); } catch(e) { console.error("Error processing tour suggestion:", e); uiManager.showToast(i18nManager.getString('toast.geminiError')); } finally { btn.disabled = false; btn.textContent = i18nManager.getString('tour.aiSuggestBtn'); } },
        async summarizeTour() { if (!navigator.onLine) { uiManager.showToast(i18nManager.getString('toast.offlineAI')); return; } if (appState.selectedHuts.length === 0) return; const btn = document.getElementById('summarize-tour-btn'); btn.disabled = true; const originalText = btn.textContent; btn.innerHTML = `<div class="loader-spinner !w-5 !h-5 !border-2 mx-auto"></div>`; try { const stops = appState.selectedHuts.map(h => h.name).join(', '); const distance = routeManager.routeData ? `${(routeManager.routeData.distance / 1000).toFixed(1)} km` : "unknown distance"; const targetLang = appState.currentLang; const langName = new Intl.DisplayNames([targetLang], { type: 'language' }).of(targetLang); const prompt = `Write a fun, adventurous summary (2 paragraphs) for a bike tour in ${langName} (code "${targetLang}"). Stops: ${stops}. Distance: approx. ${distance}. Make it engaging.`; const summary = await this.callGemini(prompt); if (summary) { const formattedSummary = summary.replace(/\n/g, '<br>'); uiManager.openPopup(i18nManager.getString('popup.aiSummaryTitle'), `<p>${formattedSummary}</p>`); } } finally { btn.disabled = false; btn.textContent = originalText; } }
     };
    const firebaseManager = { /* Firebase Manager - Modified joinRoom and leaveRoom */
        db: null, warningListener: null, // Add listener reference
        init() { try { if (!firebase.apps.length) firebase.initializeApp(config.firebase); else firebase.app(); this.db = firebase.firestore(); this.loadHuts(); this.listenToWarnings(); } catch(e) { console.error("Firebase Init Error:", e); uiManager.showToast(i18nManager.getString('toast.hutsLoadingError')); this.loadOfflineHuts(); } },
        loadOfflineHuts() { const offlineHuts = localStorage.getItem('allHutsData'); if (offlineHuts) { try { appState.allHuts = JSON.parse(offlineHuts); this.displayHuts(appState.allHuts); uiManager.showToast(i18nManager.getString('toast.offlineHutsLoaded')); } catch (e) { console.error("Error loading offline huts:", e); } } else { uiManager.showToast(i18nManager.getString('toast.offlineHutsNotFound')); } const lastRoute = localStorage.getItem('lastRouteData'); if(lastRoute && appState.selectedHuts.length > 0){ try { routeManager.routeData = JSON.parse(lastRoute); if (routeManager.routeData.coords) mapManager.drawRoute(routeManager.routeData.coords, true); uiManager.showToast(i18nManager.getString('toast.offlineRouteLoaded')); } catch(e){ console.error(i18nManager.getString('toast.offlineRouteError'), e); } } },
        displayHuts(huts) { mapManager.clusterGroup.clearLayers(); huts.forEach(hut => { if (!hut || typeof hut.lat !== 'number' || typeof hut.lng !== 'number') { console.warn("Skipping hut with invalid data:", hut); return; } const marker = L.marker([hut.lat, hut.lng]); marker.bindTooltip(hut.name || 'Unnamed Hut', { permanent: true, direction: 'bottom', className: 'hutten-bubble', offset: [0, 10] }); marker.bindPopup(i18nManager.getString('popup.hut.loading'), {minWidth: 300}); marker.on('click', () => { const isSelected = appState.selectedHuts.some(h => h.id === hut.id); const bilderUrls = (hut.fotos || []).filter(f => typeof f === 'string' || f?.status === 'freigegeben').map(f => typeof f === 'string' ? f : f?.url).filter(Boolean); let oeffnungszeitenHTML = `<p>${i18nManager.getString('popup.hut.openingHours.unknown')}</p>`; if (hut.immerGeoeffnet === true) oeffnungszeitenHTML = `<p>${i18nManager.getString('popup.hut.openingHours.always')}</p>`; else if (Array.isArray(hut.oeffnungszeiten) && hut.oeffnungszeiten.length > 0) { if (typeof hut.oeffnungszeiten[0] === 'object' && hut.oeffnungszeiten[0] !== null && 'tag' in hut.oeffnungszeiten[0]) oeffnungszeitenHTML = `<ul class='oeffnungszeiten-list'>${hut.oeffnungszeiten.map(e => `<li><span class="tag">${e.tag}:</span> <span class="zeit">${e.von || '–'} - ${e.bis || '–'}</span></li>`).join("")}</ul>`; else oeffnungszeitenHTML = `<ul class='oeffnungszeiten-list'>${hut.oeffnungszeiten.map(e => `<li>${e}</li>`).join("")}</ul>`; } else if (typeof hut.oeffnungszeiten === "object" && hut.oeffnungszeiten !== null && !Array.isArray(hut.oeffnungszeiten)) { const tage = Object.entries(hut.oeffnungszeiten); if (tage.length > 0) oeffnungszeitenHTML = `<ul class='oeffnungszeiten-list'>${tage.map(([tag, val]) => { const timeStr = (typeof val === 'object' && val !== null) ? `${(val.start || "–")} - ${(val.ende || "–")}` : (typeof val === 'string' ? val : '–'); return `<li><span class="tag">${tag}:</span> <span class="zeit">${timeStr}</span></li>`; }).join("")}</ul>`; } else if (typeof hut.oeffnungszeiten === "string" && hut.oeffnungszeiten.trim()) oeffnungszeitenHTML = `<p>${hut.oeffnungszeiten.replace(/\n/g, '<br>')}</p>`; const popupContent = `...`; /* Popup HTML structure */ marker.setPopupContent(popupContent).openPopup(); setTimeout(() => { const btn = document.getElementById(`btn-${hut.id}`); if(btn) btn.onclick = () => { routeManager.toggleSelect(hut); marker.closePopup(); }; const swiperEl = marker.getPopup()?.getElement()?.querySelector('.popup-swiper'); if (swiperEl && !swiperEl.swiper) new Swiper(swiperEl, { loop: bilderUrls.length > 1, pagination: { el: '.swiper-pagination', clickable: true }, navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev' } }); }, 0); }); mapManager.clusterGroup.addLayer(marker); }); },
        loadHuts() { this.db.collection("eierhuetten").where("status", "==", "angenommen").onSnapshot(snapshot => { const huts = []; snapshot.forEach(doc => { const data = doc.data(); if (data.location?.latitude != null && data.location?.longitude != null) { huts.push({ id: doc.id, ...data, lat: data.location.latitude, lng: data.location.longitude }); } else console.warn(`Hut ${doc.id} missing location.`); }); appState.allHuts = huts; this.displayHuts(huts); localStorage.setItem('allHutsData', JSON.stringify(huts)); }, err => { console.error("Error loading huts:", err); uiManager.showToast(i18nManager.getString('toast.hutsLoadingError')); this.loadOfflineHuts(); }); },
        rejoinLastRoom() { const lastRoomId = localStorage.getItem('lastRoomId'); if(lastRoomId) { if(confirm(i18nManager.getString('toast.roomRejoin', { id: lastRoomId }))) { this.joinRoom(lastRoomId); } else { localStorage.removeItem('lastRoomId'); } } },
        // *** SMART JOIN/CREATE ***
        joinRoom(id = null) {
            let roomIdToJoin = id; let isCreatingNew = false;
            if (!roomIdToJoin) {
                const inputElement = document.getElementById('roomIdInput');
                const inputId = inputElement ? inputElement.value.trim().toUpperCase() : '';
                if (inputId) {
                    roomIdToJoin = inputId;
                     if (!/^[A-Z0-9]{6}$/.test(roomIdToJoin)) { uiManager.showToast("Invalid Room ID format."); return; } // Add translation
                } else {
                    roomIdToJoin = Math.random().toString(36).substring(2, 8).toUpperCase(); isCreatingNew = true; console.log("Generating new Room ID:", roomIdToJoin);
                }
            } else {
                 roomIdToJoin = roomIdToJoin.toUpperCase();
                 if (!/^[A-Z0-9]{6}$/.test(roomIdToJoin)) { console.warn(`Invalid Room ID from param: ${roomIdToJoin}`); /* Optionally fail */ }
            }
            console.log(`Attempting to ${isCreatingNew ? 'create' : 'join'} room: ${roomIdToJoin}`);
            appState.currentRoom.id = roomIdToJoin; localStorage.setItem('lastRoomId', roomIdToJoin);
            this.listenToRoom(roomIdToJoin); this.listenToUsersInRoom(roomIdToJoin); userManager.startWatchingPosition();
            uiManager.updateRoomUI(appState.currentRoom);
            uiManager.showToast(isCreatingNew ? i18nManager.getString('toast.roomCreated', { id: roomIdToJoin }) : i18nManager.getString('toast.roomJoined', { id: roomIdToJoin }));
             const inputElement = document.getElementById('roomIdInput'); if (inputElement) inputElement.value = '';
        },
        // *** SMART URL CLEAR ***
        leaveRoom() {
            if (appState.roomUnsubscribe) appState.roomUnsubscribe(); if (appState.userPositionsUnsubscribe) appState.userPositionsUnsubscribe(); appState.roomUnsubscribe = null; appState.userPositionsUnsubscribe = null;
            localStorage.removeItem('lastRoomId');
            const roomToLeave = appState.currentRoom.id;
            if (roomToLeave && userManager.userId) {
                this.db.collection('room_positions').doc(roomToLeave).collection('users').doc(userManager.userId).delete().catch(err => console.error("Error removing user pos:", err));
                 if (appState.currentRoom.guideId === userManager.userId) { this.db.collection('rooms').doc(roomToLeave).set({ guideId: null, guideName: null, isNavigating: false, guidedRoute: null }, { merge: true }).catch(err => console.error("Error clearing guide status:", err)); }
            }
            appState.currentRoom.id = null; appState.currentRoom.guideId = null;
            Object.keys(mapManager.groupMarkers).forEach(id => mapManager.removeGroupMarker(id)); mapManager.groupMarkers = {};
            uiManager.updateRoomUI(appState.currentRoom); uiManager.showToast(i18nManager.getString('toast.roomLeft'));
            const urlParams = new URLSearchParams(window.location.search); if (urlParams.get('room')?.toUpperCase() === roomToLeave) { window.history.replaceState({}, document.title, window.location.pathname); console.log("Cleared room param from URL."); }
        },
        listenToRoom(roomId) { if(appState.roomUnsubscribe) appState.roomUnsubscribe(); appState.roomUnsubscribe = this.db.collection("rooms").doc(roomId).onSnapshot(doc => { const roomData = doc.data() || {}; if (appState.currentRoom.id !== roomId) { if (appState.roomUnsubscribe) appState.roomUnsubscribe(); return; } appState.currentRoom = { id: roomId, ...roomData }; const isSelfGuide = userManager.userId === roomData.guideId; if (!isSelfGuide) { const roomHutIds = roomData.hutIds || []; const localHutIds = appState.selectedHuts.map(h => h.id); if (JSON.stringify(roomHutIds) !== JSON.stringify(localHutIds)) { console.log("Syncing room huts."); appState.selectedHuts = roomHutIds.map(id => appState.allHuts.find(h => h.id === id)).filter(Boolean); uiManager.updateSelectedList(); routeManager.recalculatePreviewRoute(); uiManager.showToast(i18nManager.getString('toast.roomTourUpdated')); } const isRoomNavigating = roomData.isNavigating === true; const guidedRouteData = roomData.guidedRoute; if (isRoomNavigating && !appState.isNavigating && guidedRouteData) { console.log("Syncing follower start nav."); routeManager.routeData = guidedRouteData; routeManager.elevationData = null; mapManager.drawRoute(guidedRouteData.coords, false); uiManager.setNavigationState(true); userManager.startWatchingPosition(); uiManager.displayElevationChart(null); if (userManager.lastPosition) mapManager.map.panTo(userManager.lastPosition); } else if (!isRoomNavigating && appState.isNavigating && !isSelfGuide) { console.log("Syncing follower stop nav."); routeManager.stopNavigation(); } } uiManager.updateRoomUI(appState.currentRoom); }, error => { console.error(`Error listening to room ${roomId}:`, error); uiManager.showToast(i18nManager.getString('toast.firebaseError')); this.leaveRoom(); }); },
        listenToUsersInRoom(roomId) { if (appState.userPositionsUnsubscribe) appState.userPositionsUnsubscribe(); appState.userPositionsUnsubscribe = this.db.collection('room_positions').doc(roomId).collection('users') .onSnapshot(snapshot => { if (appState.currentRoom.id !== roomId) { if(appState.userPositionsUnsubscribe) appState.userPositionsUnsubscribe(); return; } const activeUsers = []; const now = Date.now(); const currentMemberIds = new Set(); snapshot.forEach(doc => { const user = doc.data(); const userId = doc.id; currentMemberIds.add(userId); if (userId !== userManager.userId && user.timestamp?.toMillis && (now - user.timestamp.toMillis()) < 60000) { mapManager.updateGroupMarker({ id: userId, ...user }); activeUsers.push(user); } else if (userId !== userManager.userId) { mapManager.removeGroupMarker(userId); } }); Object.keys(mapManager.groupMarkers).forEach(markerId => { if (!currentMemberIds.has(markerId)) mapManager.removeGroupMarker(markerId); }); uiManager.updateRoomUI(appState.currentRoom, activeUsers); }, error => { console.error(`Error listening to users in room ${roomId}:`, error); uiManager.showToast(i18nManager.getString('toast.firebaseError')); }); },
        updateUserPositionInRoom(pos) { if(!appState.currentRoom.id || !userManager.userId) return; const name = localStorage.getItem('username') || 'Anonym'; const colors = ['#e11d48', '#2563eb', '#16a34a', '#f97316', '#9333ea']; let hash = 0; for (let i = 0; i < userManager.userId.length; i++) hash = userManager.userId.charCodeAt(i) + ((hash << 5) - hash); const color = colors[Math.abs(hash % colors.length)]; this.db.collection('room_positions').doc(appState.currentRoom.id).collection('users').doc(userManager.userId).set({ lat: pos.lat, lng: pos.lng, name: name, color: color, timestamp: firebase.firestore.FieldValue.serverTimestamp() }, { merge: true }).catch(err => console.error("Error updating user pos:", err)); },
        updateRoomHuts() { if(!appState.currentRoom.id) return; const hutIds = appState.selectedHuts.map(h => h.id); this.db.collection("rooms").doc(appState.currentRoom.id).set({ hutIds }, { merge: true }).catch(err => console.error("Error updating room huts:", err)); },
        setGuide() { if(!appState.currentRoom.id) return; let newGuideData = { guideId: userManager.userId, guideName: localStorage.getItem('username') || 'Anonym' }; if (appState.currentRoom.guideId === userManager.userId) { newGuideData = { guideId: null, guideName: null, isNavigating: false, guidedRoute: null }; } else if (appState.currentRoom.guideId) { uiManager.showToast(i18nManager.getString('toast.guideExists')); return; } this.db.collection("rooms").doc(appState.currentRoom.id).set(newGuideData, { merge: true }).catch(err => console.error("Error setting guide:", err)); },
        updateGuidedRoute(isNavigating, routeData) { if(!appState.currentRoom.id || appState.currentRoom.guideId !== userManager.userId) return; const updateData = { isNavigating: isNavigating, guidedRoute: isNavigating && routeData ? JSON.parse(JSON.stringify(routeData)) : null, }; this.db.collection("rooms").doc(appState.currentRoom.id).set(updateData, { merge: true }).catch(err => console.error("Error updating guided route:", err)); },
        addWarning() { const typeSelect = document.getElementById('warning-type'); const type = typeSelect.options[typeSelect.selectedIndex].text; const description = document.getElementById('warning-description').value; const latlng = uiManager.tempWarningLatLng; if(!latlng) return; this.db.collection('warnings').add({ lat: latlng.lat, lng: latlng.lng, type: type, description: description, createdAt: firebase.firestore.FieldValue.serverTimestamp(), userId: userManager.userId }).then(() => { uiManager.showToast(i18nManager.getString('toast.warningReported')); uiManager.hideAddWarningModal(); }).catch(error => { console.error("Error adding warning:", error); uiManager.showToast(i18nManager.getString('toast.firebaseError')); }); },
       listenToWarnings() { const twentyFourHoursAgoTimestamp = firebase.firestore.Timestamp.fromMillis(Date.now() - (24 * 60 * 60 * 1000)); if (this.warningListener) this.warningListener(); this.warningListener = this.db.collection('warnings').where('createdAt', '>', twentyFourHoursAgoTimestamp).onSnapshot(snapshot => { const currentWarningIds = new Set(); const newOrModifiedWarnings = []; snapshot.docChanges().forEach(change => { const warning = { id: change.doc.id, ...change.doc.data() }; if (warning.createdAt?.toDate) warning.createdAt = warning.createdAt.toDate(); else warning.createdAt = new Date(); if (change.type === "added" || change.type === "modified") { newOrModifiedWarnings.push(warning); currentWarningIds.add(warning.id); } else if (change.type === "removed") { /* Handled below by filtering */ } }); appState.allWarnings = appState.allWarnings.filter(w => snapshot.docs.some(doc => doc.id === w.id)) .map(existing => newOrModifiedWarnings.find(nw => nw.id === existing.id) || existing); newOrModifiedWarnings.forEach(nw => { if (!appState.allWarnings.some(w => w.id === nw.id)) appState.allWarnings.push(nw); }); appState.allWarnings.forEach(warning => { if (!mapManager.warningMarkers[warning.id]) mapManager.addWarningMarker(warning); }); Object.keys(mapManager.warningMarkers).forEach(markerId => { const exists = snapshot.docs.some(doc => doc.id === markerId); if (!exists) mapManager.removeWarningMarker(markerId); }); userManager.warnedAbout.forEach(warnedId => { const exists = snapshot.docs.some(doc => doc.id === warnedId); if (!exists) userManager.warnedAbout.delete(warnedId); }); }, error => { console.error("Error listening to warnings:", error); uiManager.showToast(i18nManager.getString('toast.firebaseError')); }); },
        saveTourLog(routeData, selectedHuts, visitedStops) { if (!routeData || !userManager.userId || visitedStops.size === 0) return; const logData = { userId: userManager.userId, createdAt: firebase.firestore.FieldValue.serverTimestamp(), distance: routeData.distance || 0, duration: routeData.duration || 0, stops: selectedHuts.map(hut => hut.name), stopsVisited: visitedStops.size }; const statsCollection = this.db.collection('user_stats').doc(userManager.userId).collection('tours'); statsCollection.add(logData).then(ref => console.log("Tour log saved:", ref.id)).catch(err => console.error("Error saving tour log:", err)); },
        async loadTourLogs() { const statsListEl = document.getElementById('stats-list'); if (!statsListEl || !userManager.userId) return; statsListEl.innerHTML = `<p>${i18nManager.getString('stats.loading')}</p>`; try { const statsCollection = this.db.collection('user_stats').doc(userManager.userId).collection('tours'); const snapshot = await statsCollection.get(); if (snapshot.empty) { statsListEl.innerHTML = `<p>${i18nManager.getString('stats.empty')}</p>`; return; } const logs = []; snapshot.forEach(doc => { const data = doc.data(); data.createdAt = data.createdAt?.toDate ? data.createdAt.toDate() : new Date(); logs.push(data); }); logs.sort((a, b) => b.createdAt - a.createdAt); const recentLogs = logs.slice(0, 20); statsListEl.innerHTML = recentLogs.map(log => { const date = log.createdAt.toLocaleDateString(appState.currentLang || 'de', { day: '2-digit', month: '2-digit', year: 'numeric' }); const distanceKm = ((log.distance || 0) / 1000).toFixed(1); const durationMin = Math.round((log.duration || 0) / 60); const stopsCount = log.stops?.length || 0; return `<div class="p-3 rounded-lg bg-gray-100 dark:bg-gray-700"><p class="font-semibold">${date}</p><p class="text-sm text-gray-600 dark:text-gray-300">${distanceKm} km | ${durationMin} min | ${log.stopsVisited || 0} / ${stopsCount} ${i18nManager.getString('stats.tourCard.stops')}</p><p class="text-xs text-gray-500 mt-1">${log.stops?.join(', ') || '-'}</p></div>`; }).join(''); } catch (error) { console.error("Error loading stats:", error); statsListEl.innerHTML = `<p>${i18nManager.getString('stats.loadingError')}</p>`; } }
    };
    const dragAndDrop = { /* Drag & Drop - unchanged */
        draggedIndex: null, start(event, index) { this.draggedIndex = index; event.dataTransfer.effectAllowed = 'move'; event.target.style.opacity = '0.5'; }, drop(event, targetIndex) { event.preventDefault(); const targetLi = event.target.closest('li'); if (targetLi) targetLi.style.opacity = '1'; if (this.draggedIndex === null || this.draggedIndex === targetIndex) return; const draggedItem = appState.selectedHuts.splice(this.draggedIndex, 1)[0]; appState.selectedHuts.splice(targetIndex, 0, draggedItem); this.draggedIndex = null; uiManager.updateSelectedList(); if (appState.isNavigating) { uiManager.showToast(i18nManager.getString('toast.routeUpdating')); routeManager.startNavigation(); } else { routeManager.recalculatePreviewRoute(); } if (appState.currentRoom.id) firebaseManager.updateRoomHuts(); }, initDragListeners() { const listEl = document.getElementById('selectedList'); if (listEl) { listEl.addEventListener('dragend', (event) => { if (event.target.tagName === 'LI') event.target.style.opacity = '1'; this.draggedIndex = null; }); listEl.addEventListener('dragover', (event) => { event.preventDefault(); event.dataTransfer.dropEffect = 'move'; }); } }
     };
    const weatherManager = { /* Weather Manager - unchanged */
        lastFetchTime: 0, currentWeather: null,
        async fetchWeather(lat, lng) { const now = Date.now(); if (now - this.lastFetchTime < 600000) return; this.lastFetchTime = now; if (!navigator.onLine) return; try { const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat.toFixed(4)}&longitude=${lng.toFixed(4)}&current_weather=true`); if (!response.ok) throw new Error(`Weather API Error: ${response.status}`); const data = await response.json(); if(data?.current_weather) this.updateWidget(data.current_weather); else console.warn("Invalid weather data:", data); } catch (error) { console.error("Error fetching weather:", error); } },
        updateWidget(weather) { this.currentWeather = weather; const widget = document.getElementById('weather-widget'); if (!widget) return; const icon = this.getWeatherIcon(weather.weathercode); const temp = Math.round(weather.temperature); const iconSpan = widget.querySelector('span:first-child'); const tempSpan = widget.querySelector('span:nth-child(2)'); if (iconSpan) iconSpan.textContent = icon; if (tempSpan) tempSpan.textContent = `${temp}°C`; },
        getWeatherIcon(code) { if (code === 0) return '☀️'; if (code === 1) return '🌤️'; if (code === 2) return '⛅️'; if (code === 3) return '☁️'; if (code === 45 || code === 48) return '🌫️'; if (code >= 51 && code <= 57) return '🌦️'; if (code >= 61 && code <= 65) return '🌧️'; if (code === 66 || code === 67) return '🥶'; if (code >= 71 && code <= 75) return '❄️'; if (code === 77) return '❄️'; if (code >= 80 && code <= 82) return '⛈️'; if (code === 85 || code === 86) return '🌨️'; if (code === 95) return '🌩️'; if (code === 96 || code === 99) return '⚡️'; return '-'; },
        async fetchElevation(coordinates) { if (!navigator.onLine) { uiManager.showToast(i18nManager.getString('toast.offlineElevationError')); return null; } if (!coordinates?.length) return null; const sampleRate = Math.max(1, Math.floor(coordinates.length / 150)); const sampledCoords = coordinates.filter((_, i) => i % sampleRate === 0); const lats = sampledCoords.map(c => (typeof c?.[0] === 'number') ? c[0].toFixed(4) : null).filter(Boolean).join(','); const lngs = sampledCoords.map(c => (typeof c?.[1] === 'number') ? c[1].toFixed(4) : null).filter(Boolean).join(','); if (!lats || !lngs) { console.warn("No valid coords for elevation."); return null; } const url = `https://api.open-meteo.com/v1/elevation?latitude=${lats}&longitude=${lngs}`; try { const response = await fetch(url); if (!response.ok) { let errorDetail = response.statusText; try { const errorBody = await response.json(); if (errorBody?.reason) errorDetail = errorBody.reason; } catch(e) {} throw new Error(`Elevation API Error ${response.status}: ${errorDetail}`); } const data = await response.json(); if (!data?.elevation || !Array.isArray(data.elevation)) throw new Error('Invalid elevation data format.'); const validElevations = data.elevation.filter(e => typeof e === 'number'); if (validElevations.length !== data.elevation.length) console.warn("Invalid elevation points received."); if (validElevations.length === 0) throw new Error("No valid elevation points."); return { elevation: validElevations }; } catch (error) { console.error("Error fetching/processing elevation:", error); uiManager.showToast(i18nManager.getString('toast.elevationError')); return null; } }
     };

    // ----------------------------------------------------------
    //  6. INITIALIZATION
    // ----------------------------------------------------------
    document.addEventListener('DOMContentLoaded', () => {
        uiManager.setLoading(true);
        uiManager.init();
        mapManager.init(config.map.defaultCenter, config.map.defaultZoom);
        firebaseManager.init();
        userManager.init();
         dragAndDrop.initDragListeners(); // Init drag listeners

        const urlParams = new URLSearchParams(window.location.search);
        const roomIdFromUrl = urlParams.get('room');
        if (roomIdFromUrl) {
            setTimeout(() => { // Delay slightly
                 if (appState.currentRoom.id !== roomIdFromUrl.toUpperCase()) {
                     console.log(`Joining room ${roomIdFromUrl} from URL.`);
                     firebaseManager.joinRoom(roomIdFromUrl);
                 }
                 // No automatic URL clearing here, only on leave
            }, 1500);
        } else {
            firebaseManager.rejoinLastRoom(); // Only rejoin if no room in URL
        }
    });

  </script>
</body>
</html>

