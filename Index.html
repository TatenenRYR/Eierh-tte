<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>RadlMap Navigation üö≤ (Smarter)</title>

  <!-- Meta Tags f√ºr Social Media Vorschau -->
  <meta property="og:title" content="üè†üö≤ RadlMap Tourplaner" />
  <meta property="og:description" content="Plane deine n√§chste Radtour mit H√ºtten! Mit Live-GPS, Tourenspeicher, Gruppenfunktion & mehr." />
  <meta property="og:image" content="https://radlmap.net/img/preview.png" />
  <meta property="og:url" content="https://radlmap.net" />
  <meta name="twitter:card" content="summary_large_image" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üö≤</text></svg>">

  <!-- Externe Bibliotheken -->
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>
  <script src="https://unpkg.com/@mapbox/polyline"></script>
  <link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"/>
  <script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script>
  <script src="https://unpkg.com/leaflet-geometryutil"></script> <!-- Library for distance calculations -->
  
  <!-- NEU: Chart.js f√ºr H√∂henprofil -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>


  <style>
    /* Inter Schriftart f√ºr ein modernes UI */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      -webkit-tap-highlight-color: transparent;
    }

    #map {
      height: 100%;
      width: 100%;
      background: #f0f0f0;
      z-index: 1;
    }

    /* Lade-Overlay */
    #loader {
      position: fixed;
      inset: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(8px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.5s ease;
    }
    .loader-spinner {
      border: 4px solid rgba(0,0,0,0.1);
      border-left-color: #2563eb;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Dark Mode Variablen & √úberg√§nge */
    :root {
      --bg-color: #ffffff;
      --text-color: #1f2937;
      --ui-bg: rgba(255, 255, 255, 0.85);
      --border-color: #e5e7eb;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .dark {
      --bg-color: #111827;
      --text-color: #f9fafb;
      --ui-bg: rgba(31, 41, 55, 0.85);
      --border-color: #374151;
      --shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    body, .ui-element {
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    .leaflet-popup-content-wrapper, .leaflet-popup-tip {
      background: var(--ui-bg) !important;
      color: var(--text-color) !important;
      backdrop-filter: blur(10px);
      border-radius: 12px; /* Rounded popups */
    }
     .leaflet-popup-content {
        margin: 0 !important; /* Remove default margin for card design */
        line-height: 1.5;
        width: 300px !important; /* Fixed width for popup */
    }


    /* Toast-Nachrichten */
    #toast {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #1f2937;
      color: white;
      padding: 10px 20px;
      border-radius: 9999px;
      font-size: 14px;
      z-index: 9000;
      box-shadow: var(--shadow);
      opacity: 0;
      transition: transform 0.4s ease, opacity 0.4s ease;
      pointer-events: none;
    }
    #toast.show {
      transform: translateX(-50%) translateY(0);
      opacity: 1;
    }

    /* Haupt-Toolbar */
    #toolbar {
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      background: var(--ui-bg);
      border: 1px solid var(--border-color);
    }
    #toolbar button {
      transition: background-color 0.2s, transform 0.1s;
    }
    #toolbar button:active {
      transform: scale(0.95);
    }

    /* Seitenleisten-Panel (Dashboard) */
    #sidebar-panel {
        position: fixed;
        top: 0;
        right: 0;
        height: 100%;
        width: 320px;
        max-width: 90vw;
        background: var(--bg-color);
        z-index: 5000;
        transform: translateX(100%);
        transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        box-shadow: -10px 0 25px rgba(0,0,0,0.1);
        border-left: 1px solid var(--border-color);
        display: flex;
        flex-direction: column;
    }
    #sidebar-panel.open {
        transform: translateX(0);
    }
    #sidebar-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.4);
        z-index: 4999;
        opacity: 0;
        transition: opacity 0.4s ease;
        pointer-events: none;
    }
    #sidebar-panel.open + #sidebar-overlay {
        opacity: 1;
        pointer-events: auto;
    }

    /* Verbesserte Scrollbars */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
    .dark ::-webkit-scrollbar-thumb { background: #555; }

    /* Navigations-Hinweise */
    #navHint {
        position: absolute;
        top: 80px; /* Angepasste Position */
        left: 50%;
        backdrop-filter: blur(10px);
        box-shadow: var(--shadow);
        border: 1px solid var(--border-color);
        transition: transform 0.4s ease, opacity 0.4s ease;
        transform: translate(-50%, 50px);
        opacity: 0;
        font-size: 1.2rem;
        font-weight: 600;
        pointer-events: auto;
    }
     #navHint.visible {
        transform: translate(-50%, 0);
        opacity: 1;
    }

    /* User Marker SVG mit Animation */
    @keyframes pulse {
      0% { r: 0; opacity: 0.6; }
      100% { r: 40; opacity: 0; }
    }
    .pulse-circle {
      animation: pulse 2s infinite ease-out;
    }

    /* Popup Styling */
    .popup-card {
        font-size: 0.9rem; /* Slightly smaller text */
        overflow: hidden; /* Prevent content spill */
    }
    .popup-content-area { /* Scrollbarer Bereich */
        max-height: 250px; /* Maximale H√∂he f√ºr den Inhaltsbereich */
        overflow-y: auto;
        padding: 1rem; /* Padding f√ºr den Inhalt */
        scrollbar-width: thin; /* Firefox scrollbar */
        scrollbar-color: #888 transparent; /* Firefox scrollbar color */
    }
     .popup-content-area::-webkit-scrollbar { width: 5px; } /* Chrome/Safari scrollbar */
    .popup-content-area::-webkit-scrollbar-thumb { background: #888; border-radius: 3px; }
     .dark .popup-content-area::-webkit-scrollbar-thumb { background: #555; }
    .dark .popup-content-area { scrollbar-color: #555 transparent; }


    .popup-swiper img {
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
        width: 100%;
        height: 150px;
        object-fit: cover;
    }
     .popup-button-container { /* Button Container */
        padding: 0.5rem 1rem 1rem 1rem; /* Padding um den Button */
        border-top: 1px solid var(--border-color); /* Trennlinie */
        background: var(--ui-bg); /* Hintergrund, damit Inhalt nicht durchscheint */
    }

    .group-marker {
        text-align: center;
        font-weight: bold;
        color: #fff;
    }

    .hutten-bubble {
        background: rgba(255, 255, 255, 0.8);
        border: none;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 10px;
        font-weight: 600;
        color: #333;
    }
    .dark .hutten-bubble {
        background: rgba(31, 41, 55, 0.8);
        color: #f9fafb;
    }
    .warning-icon {
        background: none;
        border: none;
        font-size: 20px; /* Make warning icon slightly larger */
    }
     .leaflet-div-icon {
        background: none;
        border: none;
    }
    
    /* SMARTER: Stil f√ºr Offline-Indikator */
    #offline-indicator {
        animation: pulse-offline 2s infinite;
    }
    @keyframes pulse-offline {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    /* NEU: CSS f√ºr √ñffnungszeiten-Liste */
    .oeffnungszeiten-list {
        list-style: none;
        padding-left: 0;
        margin: 0;
        font-size: 0.85rem;
    }
    .oeffnungszeiten-list li {
        padding: 2px 0;
        display: flex;
    }
    .oeffnungszeiten-list li .tag {
        font-weight: 600;
        width: 3rem; /* 48px */
        display: inline-block;
        flex-shrink: 0;
    }
    .oeffnungszeiten-list li .zeit {
        display: inline-block;
    }

  </style>
</head>
<body class="antialiased">

  <!-- Ladebildschirm -->
  <div id="loader">
    <div class="loader-spinner"></div>
    <p class="mt-4 text-gray-600">Karte wird geladen...</p>
  </div>

  <!-- Karten-Container -->
  <div id="map"></div>

  <!-- Toast Element -->
  <div id="toast"></div>
  
  <!-- UI Elemente √ºber der Karte -->
  <div class="absolute top-4 right-4 z-10 space-y-3">
    <button onclick="uiManager.toggleSidebar()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
    </button>
     <button id="theme-toggle-btn" onclick="uiManager.toggleTheme()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
        <!-- Icon wird per JS gesetzt -->
    </button>
  </div>
  
  <!-- Wetter Widget & NEU: KMH Anzeige -->
  <div class="absolute top-4 left-4 z-10 flex gap-2">
      <div id="weather-widget" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)] flex items-center gap-2 text-lg font-semibold">
          <span>-</span><span>-¬∞C</span>
          <!-- SMARTER: Offline-Indikator -->
          <span id="offline-indicator" class="hidden text-xs text-red-500 font-bold">OFFLINE</span>
      </div>
      <!-- NEU: KMH Anzeige -->
      <div id="speed-widget" class="hidden bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full px-4 py-3 border border-[var(--border-color)] flex items-center gap-2 text-lg font-semibold">
          <span>-- km/h</span>
      </div>
  </div>
  
  <!-- Schnellnavigation -->
  <div class="absolute left-4 top-1/2 -translate-y-1/2 z-10 flex flex-col gap-3">
       <a href="index.html" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon></svg>
      </a>
      <button onclick="uiManager.toggleSidebar()" class="bg-[var(--ui-bg)] backdrop-blur-md shadow-lg rounded-full p-3 border border-[var(--border-color)]">
         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>
      </button>
  </div>

  <div class="absolute top-0 left-0 right-0 p-4 z-10 pointer-events-none">
     <!-- Navigationshinweise oben -->
    <div id="navHint" class="hidden items-center gap-3 bg-[var(--ui-bg)] text-[var(--text-color)] rounded-full px-4 py-2 max-w-sm mx-auto">
        <!-- Inhalt wird per JS gef√ºllt -->
    </div>
  </div>

  <!-- Dashboard/Seitenleiste -->
  <aside id="sidebar-panel">
    <div class="flex items-center justify-between p-4 border-b border-[var(--border-color)]">
        <h2 class="text-xl font-bold">Dashboard</h2>
        <button onclick="uiManager.toggleSidebar()" class="p-2 rounded-full hover:bg-gray-100 dark:hover:bg-gray-700">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
        </button>
    </div>
    
    <!-- Tab Navigation -->
    <nav class="flex border-b border-[var(--border-color)] p-2">
      <button data-tab="tab-tour" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center">Tour</button>
      <button data-tab="tab-raum" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center">Raum</button>
      <button data-tab="tab-nutzer" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center">Profil</button>
      <button data-tab="tab-einstellungen" class="tab-btn flex-1 p-2 text-sm font-semibold rounded-md text-center">Setup</button>
    </nav>
    
    <div class="flex-1 overflow-y-auto p-4 space-y-6">
      <!-- Tour Tab -->
      <section id="tab-tour" class="tab-panel space-y-4">
        <!-- Gemini Tour Suggestion -->
        <div class="p-3 bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-800 rounded-lg">
            <h3 class="font-bold text-blue-800 dark:text-blue-300">‚ú® KI Tour-Planer</h3>
            <p class="text-xs text-blue-600 dark:text-blue-400 mt-1 mb-3">L√§sst deine Vorlieben & Wetter einflie√üen!</p>
            <div class="flex gap-2">
                <select id="tour-difficulty" class="flex-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent text-sm">
                    <option value="einfache">Leicht</option>
                    <option value="mittelschwere">Mittel</option>
                    <option value="anspruchsvolle">Anspruchsvoll</option>
                </select>
                <!-- SMARTER: √úbergibt das aktuelle Wetter an die KI -->
                <button id="suggest-tour-btn" onclick="geminiManager.suggestTour(weatherManager.currentWeather)" class="bg-blue-500 text-white px-4 py-2 rounded-lg text-sm font-medium hover:bg-blue-600 transition">Vorschlagen</button>
            </div>
        </div>
        
        <h3 class="font-bold">üìã Ausgew√§hlte Stopps</h3>
        <p class="text-xs text-gray-500 -mt-3">Reihenfolge per Drag & Drop √§ndern.</p>
        <ul id="selectedList" class="space-y-2" ondragover="event.preventDefault()"></ul>
        <div id="tour-actions" class="hidden space-y-2">
            <p id="challenge-status" class="text-sm font-semibold text-center text-green-600"></p>
            <p id="tour-stats" class="text-sm text-gray-500 my-2 text-center"></p>
            
            <!-- SMARTER: H√∂henprofil-Container -->
            <div id="elevation-chart-container" class="hidden w-full h-32 mt-2">
                <canvas id="elevation-chart"></canvas>
            </div>

            <!-- HINWEIS: Dieser Button wird jetzt nicht mehr ben√∂tigt, da die Aktualisierung
                 automatisch beim Hinzuf√ºgen/Entfernen von Stopps passiert.
                 Ich lasse ihn hier, falls du ihn f√ºr eine manuelle Aktualisierung behalten willst.
            <button onclick="routeManager.recalculatePreviewRoute()" class="w-full bg-gray-500 text-white p-2 rounded-lg text-sm font-medium hover:bg-gray-600 transition">
                üîÑ Vorschau aktualisieren
            </button>
            -->
            
            <button id="summarize-tour-btn" onclick="geminiManager.summarizeTour()" class="w-full bg-purple-500 text-white p-2 rounded-lg text-sm font-medium hover:bg-purple-600 transition">
                ‚ú® Tour-Zusammenfassung
            </button>
        </div>
      </section>
      
      <!-- Raum Tab -->
      <section id="tab-raum" class="tab-panel hidden space-y-4">
        <h3 class="font-bold">üë• Raum-Verwaltung</h3>
        <div id="room-active-view" class="hidden space-y-2">
            <p class="text-sm">Du bist im Raum: <strong id="current-room-id" class="font-mono bg-gray-100 dark:bg-gray-700 px-1 rounded"></strong></p>
            <p id="guide-info" class="text-sm"></p>
            <button id="guide-btn" onclick="firebaseManager.setGuide()" class="w-full bg-blue-500 text-white p-2 rounded-lg text-sm font-medium">Guide werden</button>
            <div id="guided-tour-info" class="hidden text-sm p-2 bg-yellow-100 dark:bg-yellow-900 rounded-lg text-center">Eine gef√ºhrte Tour ist aktiv.</div>

            <button onclick="firebaseManager.leaveRoom()" class="w-full bg-red-500 text-white p-2 rounded-lg text-sm font-medium">Raum verlassen</button>
            <div class="mt-4">
                <h4 class="font-semibold text-sm mb-2">Aktive Nutzer im Raum:</h4>
                <ul id="room-user-list" class="space-y-1 text-sm text-gray-600 dark:text-gray-300"></ul>
            </div>
        </div>
        <div id="room-join-view" class="space-y-2">
            <input id="roomIdInput" type="text" placeholder="Raum-ID (leer f√ºr neu)" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
            <button onclick="firebaseManager.joinRoom()" class="w-full bg-green-500 text-white p-2 rounded-lg text-sm font-medium">Beitreten / Erstellen</button>
        </div>
      </section>

      <!-- Nutzer Tab -->
      <section id="tab-nutzer" class="tab-panel hidden space-y-4">
          <h3 class="font-bold">üë§ Mein Profil</h3>
          <div>
              <label class="text-sm font-medium">Dein Name</label>
              <div class="flex gap-2 mt-1">
                  <input id="usernameInput" type="text" class="flex-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent" placeholder="Dein Anzeigename">
                  <button onclick="userManager.saveUsername()" class="bg-blue-500 text-white px-4 py-2 rounded-lg text-sm font-medium">Speichern</button>
              </div>
          </div>
           <button onclick="userManager.sendSOS()" class="w-full flex items-center justify-center gap-2 bg-red-600 hover:bg-red-700 text-white px-4 py-3 rounded-lg font-bold shadow-lg transition">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>
            SOS Notruf
          </button>
      </section>

      <!-- Einstellungen Tab -->
      <section id="tab-einstellungen" class="tab-panel hidden space-y-4">
        <h3 class="font-bold">‚öôÔ∏è Einstellungen</h3>
        
        <!-- SMARTER: KI-Pr√§ferenzen -->
        <div>
          <label for="user-pref-intensity" class="block text-sm font-medium mb-1">Bevorzugte Intensit√§t</label>
          <select id="user-pref-intensity" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
              <option value="eher flach">Eher flach</option>
              <option value="h√ºgelig">H√ºgelig</option>
              <option value="anspruchsvolle Anstiege">Anspruchsvolle Anstiege</option>
          </select>
        </div>
        <div>
          <label for="user-pref-type" class="block text-sm font-medium mb-1">Bevorzugter Tour-Typ</label>
          <select id="user-pref-type" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
              <option value="naturfokussiert">Naturfokussiert</option>
              <option value="kulinarisch">Kulinarisch</option>
              <option value="kulturelle Sehensw√ºrdigkeiten">Kulturelle Sehensw√ºrdigkeiten</option>
          </select>
        </div>

        <!-- NEU: √úbersetzungs- und Sprachauswahl -->
        <div>
          <label for="voiceLang" class="block text-sm font-medium mb-1">üó£Ô∏è Sprache (Sprachausgabe & √úbersetzung)</label>
          <select id="voiceLang" class="w-full p-2 border border-[var(--border-color)] rounded-lg bg-transparent"></select>
        </div>
        <div>
            <a href="#" onclick="uiManager.openPopup('Datenschutz', 'Hier stehen die Datenschutzbestimmungen...')" class="text-blue-500 hover:underline text-sm">Datenschutz & Impressum</a>
        </div>
      </section>
    </div>
  </aside>
  <div id="sidebar-overlay" onclick="uiManager.toggleSidebar()"></div>
  

  <!-- Haupt-Toolbar unten -->
  <div id="toolbar" class="absolute bottom-5 left-1/2 -translate-x-1/2 z-10 flex items-center gap-2 p-2 rounded-full">
    <button id="startBtn" onclick="routeManager.startNavigation()" class="bg-green-500 text-white rounded-full px-6 py-3 font-bold text-lg">Start</button>
    <button id="stopBtn" onclick="routeManager.stopNavigation()" class="bg-red-500 text-white rounded-full px-6 py-3 font-bold text-lg hidden">Stop</button>
    <button id="resetBtn" onclick="routeManager.resetRoute()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
    </button>
    <button id="voice-toggle" onclick="appState.toggleVoice()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3">
        <!-- Icon wird per JS gesetzt -->
    </button>
    <button id="follow-toggle" onclick="appState.toggleFollow()" class="bg-gray-200 dark:bg-gray-600 rounded-full p-3 hidden">
        <!-- Icon wird per JS gesetzt -->
    </button>
  </div>

  <!-- Popup f√ºr Datenschutz, KI-Ergebnisse etc. -->
  <div id="popupOverlay" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9990] flex items-center justify-center p-4" onclick="uiManager.closePopup()">
    <div id="popupContent" class="bg-[var(--bg-color)] rounded-2xl shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto p-6 relative" onclick="event.stopPropagation()">
        <!-- Inhalt wird dynamisch geladen -->
    </div>
  </div>

  <!-- Modal zum Melden einer Gefahr -->
    <div id="add-warning-modal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-[9990] flex items-center justify-center p-4">
        <div class="bg-[var(--bg-color)] rounded-2xl shadow-xl max-w-sm w-full p-6 space-y-4">
            <h3 class="font-bold text-lg">Gefahr an dieser Stelle melden</h3>
            <div>
                <label for="warning-type" class="text-sm font-medium">Art der Gefahr</label>
                <select id="warning-type" class="w-full mt-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent">
                    <option>Schlagloch</option>
                    <option>Hindernis</option>
                    <option>Gef√§hrliche Kreuzung</option>
                    <option>Sonstiges</option>
                </select>
            </div>
            <div>
                <label for="warning-description" class="text-sm font-medium">Kurze Beschreibung (optional)</label>
                <input id="warning-description" type="text" class="w-full mt-1 p-2 border border-[var(--border-color)] rounded-lg bg-transparent" placeholder="z.B. Tiefe Spurrille">
            </div>
            <div class="flex gap-2 justify-end">
                <button onclick="uiManager.hideAddWarningModal()" class="px-4 py-2 rounded-lg">Abbrechen</button>
                <button onclick="firebaseManager.addWarning()" class="px-4 py-2 bg-blue-500 text-white rounded-lg">Melden</button>
            </div>
        </div>
    </div>


  <!-- Scripte: Firebase & Logik -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore-compat.js"></script>
  
  <script>
    // ==========================================================
    //  üö≤ RADLMAP - V5.8 - Live Route Update & √ñffnungszeiten Fix
    // ==========================================================

    // WICHTIG: F√ºge hier deinen Google AI Studio API-Schl√ºssel ein!
    // Ohne diesen Schl√ºssel funktionieren die KI-Funktionen (√úbersetzung, Tour-Vorschlag) nicht.
    const GEMINI_API_KEY = "DEIN_API_KEY_HIER"; 

    // ----------------------------------------------------------
    //  1. KONFIGURATION & ZUSTAND
    // ----------------------------------------------------------

    const config = {
      firebase: { 
        apiKey: "5b3ce3597851110001cf624866907189b4974b88e5541b15dfed2e1603067f5b85cd6da44c68ee87",
        authDomain: "eierhuettentour.firebaseapp.com",
        projectId: "eierhuettentour"
      },
      map: {
        defaultCenter: [47.3, 11.4],
        defaultZoom: 13,
        navigationZoom: 18, // Ge√§ndert auf 18 f√ºr "ganz nah"
      },
      routing: {
        profile: 'cycling-regular',
        deviationThresholdMeters: 10, // Ge√§ndert auf 10 Meter
        recalcDebounceMs: 8000,      // Verz√∂gerung f√ºr Neuberechnung
      },
      noImagePlaceholders: [
        "https://radlmap.net/img/noimg/1.jpg",
        "https://radlmap.net/img/noimg/2.jpg",
        "https://radlmap.net/img/noimg/3.jpg",
      ]
    };
    
    const appState = {
      isFollowing: true,
      isVoiceOn: true,
      isDarkTheme: false,
      isNavigating: false,
      isSidebarOpen: false,
      selectedHuts: [],
      allHuts: [],
      allWarnings: [],
      warnedAbout: new Set(),
      currentRoom: { id: null, guideId: null },
      roomUnsubscribe: null,
      userPositionsUnsubscribe: null,
      visitedStops: new Set(),
      navigationStartTime: null, // SMARTER: F√ºr proaktive Tipps
      lastBreakTime: null,       // SMARTER: F√ºr proaktive Tipps
      
      toggleFollow() {
        this.isFollowing = !this.isFollowing;
        uiManager.updateFollowButton();
        uiManager.showToast(`Follow-Modus ${this.isFollowing ? 'aktiviert' : 'pausiert'}`);
        if(this.isFollowing && mapManager.userMarker) {
            mapManager.map.flyTo(mapManager.userMarker.getLatLng(), config.map.navigationZoom); // Weicher Zoom
        }
      },
      toggleVoice() {
        this.isVoiceOn = !this.isVoiceOn;
        uiManager.updateVoiceButton();
        uiManager.showToast(`Sprachansagen ${this.isVoiceOn ? 'aktiviert' : 'deaktiviert'}`);
      },
    };

    // ----------------------------------------------------------
    //  2. UI MANAGER - Alles was die Oberfl√§che betrifft
    // ----------------------------------------------------------
    const uiManager = {
        elevationChartInstance: null, // SMARTER: Referenz auf Chart.js Instanz

        init() {
            this.initTheme();
            this.initTabs();
            this.updateVoiceButton();
            this.updateFollowButton();
            ttsManager.init();
            
            // SMARTER: Offline-Status-Listener
            window.addEventListener('offline', () => {
                document.getElementById('offline-indicator').classList.remove('hidden');
                uiManager.showToast("Offline-Modus. Karten werden aus dem Cache geladen.");
            });
            window.addEventListener('online', () => {
                document.getElementById('offline-indicator').classList.add('hidden');
                uiManager.showToast("Wieder online.");
            });
            if (!navigator.onLine) { // Initialer Check
                 document.getElementById('offline-indicator').classList.remove('hidden');
            }
        },

        toggleSidebar() {
            appState.isSidebarOpen = !appState.isSidebarOpen;
            document.getElementById('sidebar-panel').classList.toggle('open', appState.isSidebarOpen);
            if(mapManager.map) {
                setTimeout(() => mapManager.map.invalidateSize(), 400);
            }
        },

        initTheme() {
            const savedTheme = localStorage.getItem('theme');
            appState.isDarkTheme = savedTheme === 'dark';
            document.body.classList.toggle('dark', appState.isDarkTheme);
            this.updateThemeButton();
        },

        toggleTheme() {
            appState.isDarkTheme = !appState.isDarkTheme;
            localStorage.setItem('theme', appState.isDarkTheme ? 'dark' : 'light');
            document.body.classList.toggle('dark', appState.isDarkTheme);
            this.updateThemeButton();
            if(mapManager.tileLayer) {
                mapManager.map.removeLayer(mapManager.tileLayer);
                mapManager.addTileLayer();
            }
            // SMARTER: H√∂henprofil neu zeichnen, wenn Theme √§ndert (f√ºr Gitterlinien-Farbe)
            if(this.elevationChartInstance) {
                this.elevationChartInstance.destroy();
                this.elevationChartInstance = null; // Zwingt Neubezug der Daten beim n√§chsten Mal
                routeManager.recalculatePreviewRoute(); // Einfachster Weg zum Neuzeichnen
            }
        },
        
        updateThemeButton() {
            const icon = appState.isDarkTheme ? '‚òÄÔ∏è' : 'üåô';
            document.getElementById('theme-toggle-btn').textContent = icon;
        },

        updateVoiceButton() {
            const icon = appState.isVoiceOn 
                ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>`
                : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v-2a7 7 0 0 0-11.21-.83"></path></svg>`;
            document.getElementById('voice-toggle').innerHTML = icon;
        },

        updateFollowButton() {
            const icon = appState.isFollowing 
                ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Z M12 2.25a.75.75 0 0 1 .75.75v.31A9.743 9.743 0 0 1 21.435 12a.75.75 0 0 1-1.493.102 8.243 8.243 0 0 0-7.942-7.942A.75.75 0 0 1 12 2.25Z"/></svg>` 
                : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>`;
            document.getElementById('follow-toggle').innerHTML = icon;
        },
        
        setLoading(isLoading, text = 'Lade...') {
            const loader = document.getElementById('loader');
            if (isLoading) {
                loader.querySelector('p').textContent = text;
                loader.style.display = 'flex';
                loader.style.opacity = '1';
            } else {
                loader.style.opacity = '0';
                setTimeout(() => loader.style.display = 'none', 500);
            }
        },

        showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        },

        updateSelectedList() {
            const listEl = document.getElementById('selectedList');
            if (appState.selectedHuts.length === 0) {
                listEl.innerHTML = `<li class="text-sm text-gray-500">Noch keine Stopps ausgew√§hlt. Klicke auf der Karte auf eine H√ºtte oder lass dir eine Tour vorschlagen.</li>`;
                document.getElementById('tour-actions').classList.add('hidden');
                return;
            }

            listEl.innerHTML = appState.selectedHuts.map((hut, index) => `
                <li draggable="true" ondragstart="dragAndDrop.start(event, ${index})" ondrop="dragAndDrop.drop(event, ${index})" ondragover="event.preventDefault()" class="flex items-center justify-between p-2 rounded-lg bg-gray-100 dark:bg-gray-700 cursor-grab" data-index="${index}">
                    <span class="font-medium text-sm">#${index + 1}: ${hut.name}</span>
                    <button onclick="routeManager.removeSelected(${index})" class="p-1 text-red-500 hover:text-red-700">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </li>
            `).join('');
            
            this.updateChallengeStatus();
            document.getElementById('tour-actions').classList.toggle('hidden', appState.selectedHuts.length < 1);
        },

        updateChallengeStatus() {
            const statusEl = document.getElementById('challenge-status');
            if (appState.selectedHuts.length > 0) {
                statusEl.textContent = `üèÜ Stopps besucht: ${appState.visitedStops.size} / ${appState.selectedHuts.length}`;
            } else {
                statusEl.textContent = '';
            }
        },
        
        /**
         * NEU: Aktualisiert die km/h-Anzeige.
         * @param {number | null} speed - Geschwindigkeit in km/h oder null.
         */
        updateSpeedWidget(speed) {
            const widget = document.getElementById('speed-widget');
            if (speed !== null && speed > 0.5) { // Kleine Schwelle, um "Zittern" bei 0 zu vermeiden
                widget.classList.remove('hidden');
                widget.querySelector('span').textContent = `${speed.toFixed(0)} km/h`;
            } else {
                 widget.querySelector('span').textContent = `0 km/h`; // Zeige 0 an, statt zu verstecken
                // widget.classList.add('hidden'); // Verstecken bei 0 km/h oder null
            }
        },

        setNavigationState(isNavigating) {
            const isGuide = appState.currentRoom.guideId === userManager.userId;
            const guidedTourActive = !!appState.currentRoom.guideId && !isGuide;

            appState.isNavigating = isNavigating;
            document.getElementById('startBtn').classList.toggle('hidden', isNavigating || guidedTourActive);
            document.getElementById('stopBtn').classList.toggle('hidden', !isNavigating || guidedTourActive);
            document.getElementById('resetBtn').disabled = guidedTourActive;
            document.getElementById('follow-toggle').classList.toggle('hidden', !isNavigating);
            
            // NEU: Speed-Widget bei Start/Stopp der Navigation ein/ausblenden
            document.getElementById('speed-widget').classList.toggle('hidden', !isNavigating);

            if(!isNavigating) {
                 document.getElementById('navHint').classList.add('hidden');
                 this.updateSpeedWidget(null); // NEU: Speed-Widget bei Stopp ausblenden
            }
        },
        
        initTabs() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const tabPanels = document.querySelectorAll('.tab-panel');
            
            tabButtons[0].classList.add('bg-gray-200', 'dark:bg-gray-700');
            tabPanels[0].classList.remove('hidden');

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('bg-gray-200', 'dark:bg-gray-700'));
                    button.classList.add('bg-gray-200', 'dark:bg-gray-700');
                    tabPanels.forEach(panel => panel.classList.add('hidden'));
                    document.getElementById(button.dataset.tab).classList.remove('hidden');
                });
            });
        },

        showNavHint(icon, text) {
            const hintEl = document.getElementById('navHint');
            hintEl.innerHTML = `${icon} <span class="text-sm font-semibold">${text}</span>`;
            hintEl.classList.remove('hidden');
            hintEl.classList.add('visible');

            if (this.navHintTimer) clearTimeout(this.navHintTimer);
            this.navHintTimer = setTimeout(() => {
                hintEl.classList.remove('visible');
            }, 8000);
        },
        
       getTurnIcon(type) { // Angepasst f√ºr OSRM instruction types
            if (type.includes('left')) {
                if (type.includes('sharp')) return '‚ÜôÔ∏è';
                if (type.includes('slight')) return '‚ÜñÔ∏è';
                return '‚¨ÖÔ∏è';
            }
            if (type.includes('right')) {
                 if (type.includes('sharp')) return '‚ÜòÔ∏è';
                 if (type.includes('slight')) return '‚ÜóÔ∏è';
                return '‚û°Ô∏è';
            }
            if (type.includes('roundabout')) return 'üîÑ';
            if (type.includes('arrive')) return 'üèÅ';
            if (type.includes('depart')) return 'üèÅ'; // Start considered finish of prev leg
            return '‚¨ÜÔ∏è'; // continue, new name, etc.
        },

        updateRoomUI(roomData, users = []) {
            const inRoom = !!roomData.id;
            document.getElementById('room-active-view').classList.toggle('hidden', !inRoom);
            document.getElementById('room-join-view').classList.toggle('hidden', inRoom);

            if(inRoom) {
                document.getElementById('current-room-id').textContent = roomData.id;
                
                const guideInfo = document.getElementById('guide-info');
                const guideBtn = document.getElementById('guide-btn');
                const isSelfGuide = roomData.guideId === userManager.userId;

                if (roomData.guideId) {
                    guideInfo.textContent = isSelfGuide ? "Du bist der Guide." : `Guide: ${roomData.guideName || 'Unbekannt'}`;
                    guideBtn.textContent = isSelfGuide ? "Guide-Rolle abgeben" : "Guide werden";
                    guideBtn.disabled = !isSelfGuide && !!roomData.guideId;
                } else {
                    guideInfo.textContent = "Niemand f√ºhrt die Tour.";
                    guideBtn.textContent = "Guide werden";
                    guideBtn.disabled = false;
                }
                
                const guidedTourInfo = document.getElementById('guided-tour-info');
                guidedTourInfo.classList.toggle('hidden', !roomData.isNavigating || isSelfGuide);


                const userListEl = document.getElementById('room-user-list');
                if(users.length > 0) {
                    userListEl.innerHTML = users.map(user => `<li>- ${user.name || 'Anonym'}</li>`).join('');
                } else {
                    userListEl.innerHTML = `<li>Keine anderen Nutzer aktiv.</li>`;
                }
            }
        },
        
        openPopup(title, htmlContent) {
            const overlay = document.getElementById("popupOverlay");
            const content = document.getElementById("popupContent");
            overlay.classList.remove("hidden");
            content.innerHTML = `
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-bold">${title}</h2>
                    <button onclick="uiManager.closePopup()" class="p-2 -mr-2 text-2xl">&times;</button>
                </div>
                <div>${htmlContent}</div>`;
        },

        closePopup() {
            document.getElementById("popupOverlay").classList.add("hidden");
        },

        showAddWarningModal(latlng) {
            this.tempWarningLatLng = latlng;
            document.getElementById('add-warning-modal').classList.remove('hidden');
        },
        hideAddWarningModal() {
            document.getElementById('add-warning-modal').classList.add('hidden');
            document.getElementById('warning-description').value = ''; // Clear description
        },

        /**
         * SMARTER: Zeigt das H√∂henprofil an oder blendet es aus.
         * @param {object | null} elevationData - Die von der API abgerufenen H√∂hendaten oder null zum Ausblenden.
         */
        displayElevationChart(elevationData) {
            const container = document.getElementById('elevation-chart-container');
            const ctx = document.getElementById('elevation-chart').getContext('2d');

            // Altes Chart zerst√∂ren, falls vorhanden
            if (this.elevationChartInstance) {
                this.elevationChartInstance.destroy();
                this.elevationChartInstance = null;
            }

            if (!elevationData || !elevationData.elevation) {
                container.classList.add('hidden');
                return;
            }

            container.classList.remove('hidden');

            const labels = elevationData.elevation.map((_, index) => index); // Einfache Indizes als Label
            const data = elevationData.elevation;
            
            const gridColor = appState.isDarkTheme ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            const fontColor = appState.isDarkTheme ? '#f9fafb' : '#1f2937';

            this.elevationChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'H√∂he (m)',
                        data: data,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 0, // Keine Punkte f√ºr saubere Linie
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: { color: fontColor },
                            grid: { color: gridColor },
                            title: {
                                display: true,
                                text: 'H√∂he (m)',
                                color: fontColor,
                                font: { size: 10 }
                            }
                        },
                        x: {
                            ticks: { display: false }, // X-Achsen-Beschriftung ausblenden
                            grid: { display: false }
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            intersect: false,
                            mode: 'index',
                            callbacks: {
                                label: (context) => `${context.parsed.y} m H√∂he`
                            }
                        }
                    }
                }
            });
        }
    };

    // ----------------------------------------------------------
    //  3. KARTEN MANAGER - Alles rund um Leaflet
    // ----------------------------------------------------------
    const mapManager = {
        map: null,
        userMarker: null,
        tileLayer: null,
        clusterGroup: null,
        routeLine: null,
        previewLine: null,
        pastRouteLine: null,
        groupMarkers: {},
        warningMarkers: {},

        init(center, zoom) {
            this.map = L.map('map', { center, zoom, zoomControl: false });
            L.control.zoom({ position: 'bottomright' }).addTo(this.map);
            this.addTileLayer();

            this.clusterGroup = L.markerClusterGroup();
            this.map.addLayer(this.clusterGroup);

            this.map.on('dragstart', () => { if(appState.isFollowing) appState.toggleFollow() });
            this.map.on('contextmenu', (e) => uiManager.showAddWarningModal(e.latlng)); // Right-click or long-press
            
            this.map.on('popupopen', (e) => {
              const swiperEl = e.popup.getElement().querySelector('.popup-swiper');
              if (swiperEl && !swiperEl.swiper) {
                new Swiper(swiperEl, {
                  loop: true,
                  pagination: { el: '.swiper-pagination', clickable: true },
                  navigation: {
                    nextEl: '.swiper-button-next',
                    prevEl: '.swiper-button-prev',
                  },
                });
              }
            });
        },

        addTileLayer() {
            const url = appState.isDarkTheme
                ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
                : 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
            const attr = '&copy; OpenStreetMap &copy; CARTO';
            
            this.tileLayer = L.tileLayer(url, { attribution: attr, maxZoom: 19 });
            this.tileLayer.addTo(this.map);
            
            // SMARTER: Offline-Caching-Logik k√∂nnte hier mit Plugins wie Leaflet.PouchDB
            // oder Service Workern hinzugef√ºgt werden.
        },
        
        updateUserMarker(latlng, accuracy, bearing) {
            const iconHtml = `
                <svg width="48" height="48" viewBox="0 0 48 48" style="transform: rotate(${bearing}deg); transition: transform 0.2s linear;">
                    <circle cx="24" cy="24" r="20" fill="#4285F4" fill-opacity="0.2" class="pulse-circle"/>
                    <path d="M24 4 L34 28 H14 Z" fill="#4285F4" stroke="white" stroke-width="2" style="filter: drop-shadow(0px 2px 4px rgba(0,0,0,0.4));"/>
                </svg>
            `;
            const userIcon = L.divIcon({
                html: iconHtml,
                className: '',
                iconSize: [48, 48],
                iconAnchor: [24, 24]
            });

            if (!this.userMarker) {
                this.userMarker = L.marker(latlng, { icon: userIcon }).addTo(this.map);
            } else {
                this.userMarker.setLatLng(latlng).setIcon(userIcon);
            }
        },
        
        updateGroupMarker(user) {
            const icon = L.divIcon({
                className: 'group-marker',
                html: `<div style="background-color: ${user.color};" class="p-1 rounded-full shadow-lg">üö¥</div><div class="text-xs -mt-1" style="color: ${user.color};">${user.name.substring(0,5)}</div>`
            });

            if (this.groupMarkers[user.id]) {
                this.groupMarkers[user.id].setLatLng([user.lat, user.lng]);
            } else {
                this.groupMarkers[user.id] = L.marker([user.lat, user.lng], { icon }).addTo(this.map);
            }
        },
        
        addWarningMarker(warning) {
            const icon = L.divIcon({
                className: 'warning-icon',
                html: '‚ö†Ô∏è',
                iconSize: [24, 24]
            });
            const marker = L.marker([warning.lat, warning.lng], { icon: icon })
                .bindPopup(`<b>${warning.type}</b><br>${warning.description || ''}`)
                .addTo(this.map);
            this.warningMarkers[warning.id] = marker;
        },

        removeWarningMarker(warningId) {
             if (this.warningMarkers[warningId]) {
                this.map.removeLayer(this.warningMarkers[warningId]);
                delete this.warningMarkers[warningId];
            }
        },

        removeGroupMarker(userId) {
            if (this.groupMarkers[userId]) {
                this.map.removeLayer(this.groupMarkers[userId]);
                delete this.groupMarkers[userId];
            }
        },

        drawRoute(coordinates, isPreview = false) {
            const options = isPreview
                ? { color: "#9ca3af", weight: 5, dashArray: "10, 10" }
                : { color: "#3b82f6", weight: 6, opacity: 0.8 };

            if(isPreview) {
                if(this.previewLine) this.map.removeLayer(this.previewLine);
                this.previewLine = L.polyline(coordinates, options).addTo(this.map);
            } else {
                if(this.routeLine) this.map.removeLayer(this.routeLine);
                this.routeLine = L.polyline(coordinates, options).addTo(this.map);
                if(this.pastRouteLine) this.map.removeLayer(this.pastRouteLine); // Clear previous track
                this.pastRouteLine = L.polyline([], { color: 'gray', weight: 4, opacity: 0.7 }).addTo(this.map); // Initialize new track
            }
        },
        
        addPointToPastRoute(latlng) {
            if (this.pastRouteLine) {
                this.pastRouteLine.addLatLng(latlng);
            }
        },

        clearRoute() {
            if(this.routeLine) this.map.removeLayer(this.routeLine);
            if(this.previewLine) this.map.removeLayer(this.previewLine);
            if(this.pastRouteLine) this.map.removeLayer(this.pastRouteLine);
            this.routeLine = null;
            this.previewLine = null;
            this.pastRouteLine = null;
        }
    };
    
    // ----------------------------------------------------------
    //  4. WEITERE MANAGER (Routing, Gemini, Firebase, Nutzer, TTS, DragDrop)
    // ----------------------------------------------------------

    const ttsManager = {
        /**
         * NEU: F√ºllt die Sprachauswahl mit g√§ngigen Zielsprachen f√ºr die √úbersetzung.
         */
        init() {
            const select = document.getElementById("voiceLang");
            if (!select || !window.speechSynthesis) return;

            // Feste Liste g√§ngiger Sprachen f√ºr die √úbersetzung
            const commonLangs = {
                "de-DE": "Deutsch",
                "en-US": "English (US)",
                "en-GB": "English (UK)",
                "es-ES": "Espa√±ol",
                "fr-FR": "Fran√ßais",
                "it-IT": "Italiano",
                "nl-NL": "Nederlands"
            };

            select.innerHTML = '';
            for (const [code, name] of Object.entries(commonLangs)) {
                const option = document.createElement('option');
                option.textContent = name;
                option.value = code;
                select.appendChild(option);
            }
            
            // Gespeicherte Sprache ODER Deutsch als Standard
            select.value = localStorage.getItem('voiceLang') || 'de-DE';
            
            select.onchange = () => localStorage.setItem('voiceLang', select.value);
            
            // Sicherstellen, dass die Stimmen geladen sind (wichtig f√ºr einige Browser)
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = () => {}; // Leerer Handler, um das Laden zu triggern
            }
            speechSynthesis.getVoices();
        },
        
        /**
         * NEU: √úbersetzt den Text bei Bedarf vor der Sprachausgabe.
         * @param {string} text - Der deutsche Originaltext.
         */
        async speak(text) {
            if (!appState.isVoiceOn || !text) return;
            speechSynthesis.cancel();
            
            const targetLang = document.getElementById("voiceLang").value || 'de-DE';
            let textToSpeak = text;

            try {
                // √úbersetzen, wenn die Zielsprache nicht Deutsch ist
                if (targetLang !== 'de-DE' && navigator.onLine) {
                    textToSpeak = await geminiManager.translateText(text, targetLang);
                }
            } catch (e) {
                console.error("Fehler beim √úbersetzen:", e);
                // Fallback: Originaltext verwenden
                textToSpeak = text; 
            }
            
            if (!textToSpeak) textToSpeak = text; // Sicherheitsnetz

            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = targetLang; // Die Sprache der Stimme/√úbersetzung festlegen
            
            // Versuchen, eine passende Stimme zu finden (optional, aber besser)
            const voices = speechSynthesis.getVoices();
            // Priorisiere Stimmen, die exakt zur Sprache passen
            let voice = voices.find(v => v.lang === targetLang); 
            if (!voice) {
                // Fallback: Finde eine Stimme, die zumindest die Hauptsprache spricht (z.B. 'en' statt 'en-US')
                 voice = voices.find(v => v.lang.startsWith(targetLang.split('-')[0]));
            }
            if (voice) {
                utterance.voice = voice;
            }

            speechSynthesis.speak(utterance);
        }
    };

    const routeManager = {
        routeData: null,
        recalcTimer: null,
        announcedSteps: {},
        lastRecalcTime: 0,

        async fetchRoute(startCoords, waypoints) {
            const coordinatesString = [
                `${startCoords.lng},${startCoords.lat}`,
                ...waypoints.map(h => `${h.lng},${h.lat}`)
            ].join(';');
            
            const url = `https://router.project-osrm.org/route/v1/bicycle/${coordinatesString}?overview=full&geometries=geojson&steps=true`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`OSRM API Fehler: ${response.statusText}`);
                const data = await response.json();
                if (data.code !== 'Ok' || !data.routes || data.routes.length === 0) throw new Error('OSRM konnte keine Route finden.');
                
                const route = data.routes[0];
                this.routeData = {
                    coords: route.geometry.coordinates.map(p => [p[1], p[0]]),
                    distance: route.distance,
                    duration: route.duration,
                    steps: route.legs.flatMap(leg => leg.steps)
                };
                return this.routeData;
            } catch (error) {
                console.error("Fehler bei der Routenberechnung:", error);
                uiManager.showToast("Route konnte nicht berechnet werden.");
                return null;
            }
        },
        
        checkNextManeuver(userPos) {
            if (!this.routeData || !this.routeData.steps) return;
        
            for (let i = 0; i < this.routeData.steps.length; i++) {
                const step = this.routeData.steps[i];
                let instructionText = step.maneuver.instruction;

                // Fallback for missing instruction text - corrected logic
                if (!instructionText || instructionText.trim() === '') {
                    const type = step.maneuver.type;
                    const modifier = step.maneuver.modifier || '';
                    const road = step.name ? ` auf ${step.name}` : '';
                    
                    if (type === 'continue' || type === 'new name') instructionText = `Weiter geradeaus ${road}`;
                    else if (type === 'arrive') instructionText = `Sie haben Ihr Ziel erreicht${road}`;
                    else if (type === 'depart') instructionText = `Starten Sie ${road}`;
                    else instructionText = `${modifier.replace(/_/g, ' ')}${road}`; // More generic for turns etc.
                    instructionText = instructionText.charAt(0).toUpperCase() + instructionText.slice(1); // Capitalize
                }


                const stepLocation = L.latLng(step.maneuver.location[1], step.maneuver.location[0]);
                const distance = userPos.distanceTo(stepLocation);
        
                if (!this.announcedSteps[i]) this.announcedSteps[i] = { pre: false, imminent: false };
        
                if (distance < 150 && distance > 40 && !this.announcedSteps[i].pre) {
                    this.announcedSteps[i].pre = true;
                    const instruction = `In ${Math.round(distance/10)*10} Metern ${instructionText}`;
                    const icon = uiManager.getTurnIcon(step.maneuver.type);
                    uiManager.showNavHint(icon, instruction);
                    ttsManager.speak(instruction);
                    break;
                }
        
                if (distance < 25 && !this.announcedSteps[i].imminent) {
                    this.announcedSteps[i].imminent = true;
                    const instruction = `Jetzt ${instructionText}`;
                    const icon = uiManager.getTurnIcon(step.maneuver.type);
                    uiManager.showNavHint(icon, instruction);
                    ttsManager.speak(instruction);
                    
                    const nextHut = appState.selectedHuts.find(hut => L.latLng(hut.lat, hut.lng).distanceTo(stepLocation) < 50);
                    if (nextHut && !appState.visitedStops.has(nextHut.id)) {
                       appState.visitedStops.add(nextHut.id);
                       uiManager.updateChallengeStatus();
                       if(appState.visitedStops.size === appState.selectedHuts.length) {
                           uiManager.showToast("üèÜ Alle Stopps erreicht!");
                           ttsManager.speak("Herzlichen Gl√ºckwunsch, du hast alle Ziele erreicht!");
                       }
                    }
                    break; 
                }
            }
        },

        checkDeviation(userPos) {
            if (!appState.isNavigating || !mapManager.routeLine) return;

            const now = Date.now();
            if (now - this.lastRecalcTime < config.routing.recalcDebounceMs) return;

            // Ensure routeLine has coordinates
            const routeLatLngs = mapManager.routeLine.getLatLngs();
            if (!routeLatLngs || routeLatLngs.length < 2) return; 

            const closestPoint = L.GeometryUtil.closest(mapManager.map, routeLatLngs, userPos);
             if (!closestPoint || !closestPoint.latlng) { // Check if closest point is valid and has latlng
                 console.warn("Could not find closest point on route.");
                 return; 
             }

            const distance = userPos.distanceTo(closestPoint.latlng); // Use latlng property

            if (distance > config.routing.deviationThresholdMeters) {
                this.lastRecalcTime = now;
                uiManager.showToast("Route verlassen, neue Route wird berechnet...");
                this.startNavigation(); // Recalculate from current position
            }
        },
        
        toggleSelect(hut) {
            const index = appState.selectedHuts.findIndex(h => h.id === hut.id);
            if (index > -1) {
                appState.selectedHuts.splice(index, 1);
            } else {
                appState.selectedHuts.push(hut);
            }
            uiManager.updateSelectedList();
            
            // *** √ÑNDERUNG HIER: Live-Neuberechnung ***
            if (appState.isNavigating) {
                uiManager.showToast("Route wird aktualisiert...");
                this.startNavigation(); // Live-Update der Navigation
            } else {
                this.recalculatePreviewRoute(); // Nur Vorschau aktualisieren
            }
            
            if(appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        },
        
        removeSelected(index) {
            appState.selectedHuts.splice(index, 1);
            uiManager.updateSelectedList();
            
            // *** √ÑNDERUNG HIER: Live-Neuberechnung ***
            if (appState.isNavigating) {
                 uiManager.showToast("Route wird aktualisiert...");
                this.startNavigation(); // Live-Update der Navigation
            } else {
                this.recalculatePreviewRoute(); // Nur Vorschau aktualisieren
            }
             
            if(appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        },

        async recalculatePreviewRoute() {
            if (appState.selectedHuts.length < 1) {
                mapManager.clearRoute();
                document.getElementById('tour-stats').textContent = '';
                uiManager.displayElevationChart(null); // SMARTER: H√∂henprofil ausblenden
                return;
            }
            if (appState.selectedHuts.length < 2) {
                if(mapManager.previewLine) mapManager.map.removeLayer(mapManager.previewLine);
                document.getElementById('tour-stats').textContent = 'F√ºge einen weiteren Stopp f√ºr eine Route hinzu.';
                uiManager.displayElevationChart(null); // SMARTER: H√∂henprofil ausblenden
                return;
            }
            
            uiManager.setLoading(true, 'Routenvorschau wird berechnet...');
            const startPos = await userManager.getCurrentPosition();
            const route = await this.fetchRoute(startPos, appState.selectedHuts);
             // Save route to local storage for offline use
            if(route) localStorage.setItem('lastRouteData', JSON.stringify(route));
            
            if(route) {
                mapManager.drawRoute(route.coords, true);
                
                // *** √ÑNDERUNG HIER: Nur zoomen, wenn NICHT navigiert wird ***
                if (!appState.isNavigating) {
                    mapManager.map.fitBounds(mapManager.previewLine.getBounds(), {padding: [50,50]});
                }
                
                const distanceKm = (route.distance / 1000).toFixed(1);
                const durationMin = Math.round(route.duration / 60);
                document.getElementById('tour-stats').textContent = `Tour: ${distanceKm} km, ca. ${durationMin} min`;
                
                // SMARTER: H√∂henprofil abrufen und anzeigen
                const elevationData = await weatherManager.fetchElevation(route.coords);
                uiManager.displayElevationChart(elevationData);
            }
            uiManager.setLoading(false);
        },

        async startNavigation() {
            if (appState.currentRoom.id && appState.currentRoom.guideId && appState.currentRoom.guideId !== userManager.userId) {
                uiManager.showToast("Nur der Guide kann die Navigation starten.");
                return;
            }

            if(appState.selectedHuts.length < 1) {
                uiManager.showToast("Bitte w√§hle zuerst mindestens einen Stopp.");
                return;
            }
            uiManager.setLoading(true, 'Navigation wird gestartet...');
            const startPos = await userManager.getCurrentPosition();
            const route = await this.fetchRoute(startPos, appState.selectedHuts);
            uiManager.setLoading(false);

            if(route) {
                localStorage.setItem('lastRouteData', JSON.stringify(route)); // Save for offline
                this.announcedSteps = {};
                appState.visitedStops.clear();
                appState.navigationStartTime = Date.now(); // SMARTER: Startzeit f√ºr Assistent
                appState.lastBreakTime = Date.now();      // SMARTER: Startzeit f√ºr Assistent
                uiManager.updateChallengeStatus();
                mapManager.drawRoute(route.coords);
                
                // *** √ÑNDERUNG HIER: ***
                mapManager.map.flyTo(startPos, config.map.navigationZoom, { 
                    duration: 2.5, // 2.5 Sekunden f√ºr einen weichen Flug
                    easeLinearity: 0.5
                }); // NEU: Weicher "Fly-To" Zoom
                
                uiManager.setNavigationState(true);
                userManager.startWatchingPosition();
                uiManager.showToast("Navigation gestartet!");
                
                // SMARTER: H√∂henprofil abrufen und anzeigen
                const elevationData = await weatherManager.fetchElevation(route.coords);
                uiManager.displayElevationChart(elevationData);
                
                if (appState.currentRoom.id && appState.currentRoom.guideId === userManager.userId) {
                    const serializableRoute = { coords: route.coords, distance: route.distance, duration: route.duration, steps: route.steps };
                    firebaseManager.updateGuidedRoute(true, serializableRoute);
                }
            }
        },

        stopNavigation() {
            if (appState.currentRoom.id && appState.currentRoom.guideId && appState.currentRoom.guideId !== userManager.userId) {
                uiManager.showToast("Nur der Guide kann die Navigation beenden.");
                return;
            }

            userManager.stopWatchingPosition();
            mapManager.clearRoute();
            this.routeData = null;
            this.announcedSteps = {};
            appState.navigationStartTime = null; // SMARTER: Assistent stoppen
            appState.lastBreakTime = null;
            uiManager.setNavigationState(false);
            uiManager.showToast("Navigation beendet.");
            uiManager.displayElevationChart(null); // SMARTER: H√∂henprofil ausblenden

            if (appState.currentRoom.id && appState.currentRoom.guideId === userManager.userId) {
                firebaseManager.updateGuidedRoute(false, null);
            }
        },
        
        resetRoute() {
            this.stopNavigation();
            appState.selectedHuts = [];
            appState.visitedStops.clear();
            uiManager.updateSelectedList();
             localStorage.removeItem('lastRouteData'); // Clear offline route
            if(appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        }
    };

    const userManager = {
        watchId: null,
        lastPosition: null,
        userId: localStorage.getItem('radlMapUserId') || `user_${Math.random().toString(36).substring(2, 9)}`,
        warnedAbout: new Set(),

        init() {
            localStorage.setItem('radlMapUserId', this.userId);
            const savedName = localStorage.getItem('username');
            if(savedName) document.getElementById('usernameInput').value = savedName;
            
            this.getCurrentPosition(true).then(pos => { // Initial position with high accuracy
                mapManager.updateUserMarker(pos, 20, 0);
                mapManager.map.setView(pos, config.map.defaultZoom);
                weatherManager.fetchWeather(pos.lat, pos.lng);
            }).finally(() => uiManager.setLoading(false));
            
            firebaseManager.rejoinLastRoom();
        },
        
        getCurrentPosition(highAccuracy = false) {
             return new Promise((resolve) => {
                navigator.geolocation.getCurrentPosition(
                    pos => resolve(L.latLng(pos.coords.latitude, pos.coords.longitude)),
                    async err => { // Make error handler async
                        console.warn("GPS Fehler:", err);
                        // Try fallback if high accuracy failed
                        if(highAccuracy) {
                            uiManager.showToast("Hohe GPS-Genauigkeit fehlgeschlagen, versuche Standard...");
                            resolve(await this.getCurrentPosition(false)); // Await the fallback call
                        } else {
                            uiManager.showToast("GPS nicht verf√ºgbar. Nutze Fallback-Position.");
                            resolve(L.latLng(config.map.defaultCenter[0], config.map.defaultCenter[1]));
                        }
                    },
                    { enableHighAccuracy: highAccuracy, timeout: highAccuracy ? 10000 : 5000, maximumAge: 60000 }
                );
            });
        },

        startWatchingPosition() {
            if (this.watchId) return;
            const options = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 };
            this.watchId = navigator.geolocation.watchPosition(
                pos => {
                    const currentPos = L.latLng(pos.coords.latitude, pos.coords.longitude);
                    let bearing = this.lastPosition ? this.getBearing(this.lastPosition, currentPos) : 0;
                    
                    // NEU: Geschwindigkeit verarbeiten
                    let speedKmh = null;
                    if (pos.coords.speed !== null && pos.coords.speed >= 0) { // pos.coords.speed ist in m/s
                        speedKmh = pos.coords.speed * 3.6;
                    }
                    uiManager.updateSpeedWidget(speedKmh); // km/h-Anzeige aktualisieren
                    
                    mapManager.updateUserMarker(currentPos, pos.coords.accuracy, bearing);
                    if (appState.isFollowing) mapManager.map.panTo(currentPos);
                    
                    if(appState.isNavigating) {
                        routeManager.checkNextManeuver(currentPos);
                        routeManager.checkDeviation(currentPos);
                        mapManager.addPointToPastRoute(currentPos); // Add point to grey track
                        this.checkSmartAlerts(); // SMARTER: Proaktiven Assistenten pr√ºfen
                    }
                    if(appState.currentRoom.id) firebaseManager.updateUserPositionInRoom(currentPos);

                    weatherManager.fetchWeather(currentPos.lat, currentPos.lng);
                    this.checkProximityToWarnings(currentPos);

                    this.lastPosition = currentPos;
                },
                err => console.error("GPS Watch Fehler:", err),
                options
            );
        },

        stopWatchingPosition() {
            if(this.watchId) navigator.geolocation.clearWatch(this.watchId);
            this.watchId = null;
            uiManager.updateSpeedWidget(null); // km/h-Anzeige ausblenden
        },
        
        getBearing(from, to) {
            const lat1 = from.lat * Math.PI / 180;
            const lat2 = to.lat * Math.PI / 180;
            const dLon = (to.lng - from.lng) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
            return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
        },

        checkProximityToWarnings(userPos) {
            for (const warning of appState.allWarnings) {
                if (!this.warnedAbout.has(warning.id)) {
                    const warningPos = L.latLng(warning.lat, warning.lng);
                    const distance = userPos.distanceTo(warningPos);
                    if (distance < 100) {
                        const message = `Achtung, in ${Math.round(distance/10)*10} Metern gemeldete Gefahr: ${warning.type}.`;
                        ttsManager.speak(message);
                        uiManager.showToast(message);
                        this.warnedAbout.add(warning.id);
                        // Optionally remove from warnedAbout after some time if needed
                    }
                }
            }
        },

        /**
         * SMARTER: Pr√ºft auf proaktive Warnungen, z.B. Pausen-Erinnerungen.
         */
        checkSmartAlerts() {
            if (!appState.isNavigating || !appState.navigationStartTime) return;
            
            const now = Date.now();
            const timeSinceLastBreak = now - (appState.lastBreakTime || appState.navigationStartTime);
            
            // Erinnere an Pause nach 60 Minuten (3600000 ms)
            if (timeSinceLastBreak > 3600000) {
                const message = "Du f√§hrst schon seit einer Stunde. Zeit f√ºr eine kleine Pause?";
                ttsManager.speak(message);
                uiManager.showToast(message);
                appState.lastBreakTime = now; // Timer zur√ºcksetzen
            }
        },

        saveUsername() {
            const name = document.getElementById('usernameInput').value.trim();
            if(name) {
                localStorage.setItem('username', name);
                uiManager.showToast('Name gespeichert!');
            }
        },

        async sendSOS() {
            if (!confirm("Sicher, dass du einen SOS-Notruf per WhatsApp senden m√∂chtest?")) return;
            const pos = await this.getCurrentPosition();
            const link = `https://maps.google.com/?q=${pos.lat},${pos.lng}`;
            const message = `üö® NOTRUF üö® Ich brauche Hilfe! Mein Standort: ${link}`;
            window.open(`https://wa.me/?text=${encodeURIComponent(message)}`, "_blank");
        }
    };
    
    const geminiManager = {
        // API Key wird von der globalen Konstante oben geholt

        async callGemini(prompt, jsonSchema = null) {
            // Check if online before making API call
            if (!navigator.onLine) {
                 uiManager.showToast("Offline. KI-Funktionen nicht verf√ºgbar.");
                 return null;
            }
            // KI-Schl√ºssel-Pr√ºfung
            if (GEMINI_API_KEY === "DEIN_API_KEY_HIER" || !GEMINI_API_KEY) {
                console.error("Gemini API Key fehlt.");
                uiManager.showToast("KI-Funktion fehlgeschlagen: API-Schl√ºssel nicht konfiguriert.");
                return null;
            }
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${GEMINI_API_KEY}`;
            const payload = { contents: [{ parts: [{ text: prompt }] }] };

            if (jsonSchema) {
                payload.generationConfig = {
                    responseMimeType: "application/json",
                    responseSchema: jsonSchema,
                };
            }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                const result = await response.json();
                const candidate = result.candidates?.[0];
                if (!candidate?.content?.parts?.[0]?.text) throw new Error("Invalid API response structure.");
                return candidate.content.parts[0].text;
            } catch (error) {
                console.error("Fehler bei der Gemini-API-Anfrage:", error);
                uiManager.showToast("Ein Fehler mit der KI-Funktion ist aufgetreten.");
                return null;
            }
        },
        
        /**
         * NEU: √úbersetzt Text mit der Gemini API f√ºr die Sprachausgabe.
         * @param {string} text - Der deutsche Originaltext.
         * @param {string} targetLang - Der Ziel-Sprachcode (z.B. "en-US").
         * @returns {string} Der √ºbersetzte Text oder der Originaltext bei Fehler.
         */
        async translateText(text, targetLang) {
            if (!text || !targetLang || targetLang === 'de-DE' || !navigator.onLine) {
                return text; // Nichts zu tun
            }
            
            const prompt = `√úbersetze den folgenden deutschen Text f√ºr eine Navigations-App in die Zielsprache "${targetLang}". Behalte Eigennamen (Stra√üen, Orte) bei. Antworte nur mit der reinen √úbersetzung, ohne Einleitung. Text: "${text}"`;
            
            try {
                // Hier *kein* JSON-Schema, wir wollen reinen Text
                const translation = await this.callGemini(prompt); 
                return translation || text; // Fallback auf Originaltext bei Fehler
            } catch (error) {
                console.error("√úbersetzungsfehler:", error);
                return text; // Fallback
            }
        },

        /**
         * SMARTER: KI-Tourenvorschlag, der Wetter und Nutzerpr√§ferenzen ber√ºcksichtigt.
         * @param {object | null} weatherData - Das aktuelle Wetterobjekt von Open-Meteo.
         */
        async suggestTour(weatherData = null) {
             if (!navigator.onLine) {
                 uiManager.showToast("Offline. KI-Funktionen nicht verf√ºgbar.");
                 return;
            }
            const btn = document.getElementById('suggest-tour-btn');
            btn.disabled = true;
            btn.textContent = 'Denke...';

            try {
                const userPos = await userManager.getCurrentPosition();
                if (appState.allHuts.length === 0) {
                    uiManager.showToast("H√ºtten werden noch geladen. Bitte kurz warten.");
                    return;
                }
                const difficulty = document.getElementById('tour-difficulty').value;
                // SMARTER: Lese Nutzerpr√§ferenzen aus
                const intensity = document.getElementById('user-pref-intensity').value;
                const tourType = document.getElementById('user-pref-type').value;
                const weatherText = weatherData 
                    ? `Das aktuelle Wetter ist: ${weatherData.temperature}¬∞C.` 
                    : "Das Wetter ist unbekannt.";
                
                const hutsString = appState.allHuts.map(h => `id: ${h.id}, name: ${h.name}`).join('; ');

                // SMARTER: Deutlich verbesserter Prompt mit mehr Kontext
                const prompt = `
                  Ich bin ein Radfahrer bei Position ${userPos.lat},${userPos.lng}. 
                  Schlage mir eine ${difficulty} Fahrradtour vor.
                  Meine Pr√§ferenzen sind: Intensit√§t: "${intensity}", Tour-Typ: "${tourType}".
                  ${weatherText}
                  Bitte ber√ºcksichtige diese Pr√§ferenzen bei der Auswahl der Stopps (z.B. bei "anspruchsvoll" eher H√ºtten in den Bergen, bei "kulinarisch" H√ºtten mit guter Bewertung).
                  Hier ist eine Liste verf√ºgbarer H√ºtten: ${hutsString}. 
                  Schlage eine Route mit 3 bis 5 Stopps vor, liste die IDs der H√ºtten in der richtigen Reihenfolge auf und gib der Tour einen eing√§ngigen Titel und eine kurze, motivierende Beschreibung (auf Deutsch). 
                  Gib die Antwort ausschlie√ülich im folgenden JSON-Format zur√ºck:`;
                
                const schema = {
                    type: "OBJECT",
                    properties: {
                        "title": { "type": "STRING" },
                        "description": { "type": "STRING" },
                        "stop_ids": { "type": "ARRAY", "items": { "type": "STRING" } }
                    },
                    required: ["title", "description", "stop_ids"]
                };

                const resultText = await this.callGemini(prompt, schema);
                if (!resultText) { // Fehler wurde bereits in callGemini angezeigt
                    btn.disabled = false;
                    btn.textContent = 'Vorschlagen';
                    return; 
                }

                const resultJson = JSON.parse(resultText);
                uiManager.openPopup(`KI-Vorschlag: ${resultJson.title}`, `<p>${resultJson.description}</p><p class="mt-2 text-sm">Die Stopps wurden deiner Tour hinzugef√ºgt.</p>`);
                
                appState.selectedHuts = resultJson.stop_ids
                    .map(stopId => appState.allHuts.find(h => h.id === stopId))
                    .filter(Boolean);
                
                uiManager.updateSelectedList();
                routeManager.recalculatePreviewRoute(); // Automatische Neuberechnung
                if (appState.currentRoom.id) {
                    firebaseManager.updateRoomHuts();
                }

            } catch(e) {
                console.error("Fehler beim Verarbeiten des Tour-Vorschlags:", e);
                uiManager.showToast("KI-Vorschlag konnte nicht verarbeitet werden.");
            }
            finally {
                btn.disabled = false;
                btn.textContent = 'Vorschlagen';
            }
        },

        async summarizeTour() {
             if (!navigator.onLine) {
                 uiManager.showToast("Offline. KI-Funktionen nicht verf√ºgbar.");
                 return;
            }
            if (appState.selectedHuts.length < 1) return;
             const btn = document.getElementById('summarize-tour-btn');
            btn.disabled = true;
            btn.innerHTML = '<div class="loader-spinner !w-5 !h-5 !border-2 mx-auto"></div>';


            try {
                const stops = appState.selectedHuts.map(h => h.name).join(', ');
                const distance = routeManager.routeData ? (routeManager.routeData.distance / 1000).toFixed(1) + " km" : "unbekannter Distanz";
                
                const prompt = `Schreibe eine lustige und abenteuerliche Zusammenfassung (ca. 2 Abs√§tze) f√ºr eine Fahrradtour auf Deutsch. Die Tour hat folgende Stopps: ${stops}. Die Gesamtdistanz betr√§gt ca. ${distance}. Die Zusammenfassung soll Lust aufs Radfahren machen.`;

                const summary = await this.callGemini(prompt);
                if (summary) {
                    const formattedSummary = summary.replace(/\n/g, '<br>');
                    uiManager.openPopup("‚ú® Deine Tour-Zusammenfassung", `<p>${formattedSummary}</p>`);
                }
            } finally {
                btn.disabled = false;
                btn.textContent = '‚ú® Tour-Zusammenfassung';
            }
        }
    };

    const firebaseManager = {
        db: null,
        
        init() {
            try {
                firebase.initializeApp(config.firebase);
                this.db = firebase.firestore();
                this.loadHuts(); // Attempt to load from Firestore first
                this.listenToWarnings();
            } catch(e) {
                console.error("Firebase Init Fehler:", e);
                uiManager.showToast("Firebase konnte nicht geladen werden. Lade Offline-Daten...");
                this.loadOfflineHuts(); // Load offline huts if Firebase fails
            }
        },
        
        loadOfflineHuts() { // Function to load huts from localStorage
            const offlineHuts = localStorage.getItem('allHutsData');
            if (offlineHuts) {
                try {
                    appState.allHuts = JSON.parse(offlineHuts);
                    this.displayHuts(appState.allHuts);
                    uiManager.showToast("Offline-H√ºtten geladen.");
                } catch (e) {
                    console.error("Fehler beim Laden der Offline-H√ºtten:", e);
                }
            } else {
                 uiManager.showToast("Keine Offline-H√ºtten gefunden.");
            }
             // Load last route if offline
            const lastRoute = localStorage.getItem('lastRouteData');
             if(lastRoute && appState.selectedHuts.length > 1){
                 try {
                     routeManager.routeData = JSON.parse(lastRoute);
                     mapManager.drawRoute(routeManager.routeData.coords, true); // Show as preview
                     uiManager.showToast("Zuletzt geplante Route (offline) geladen.");
                 } catch(e){
                     console.error("Fehler beim Laden der Offline-Route:", e);
                 }
             }
        },

        displayHuts(huts) { // Helper to display huts (used by online and offline load)
            mapManager.clusterGroup.clearLayers();
             huts.forEach(hut => {
                  const marker = L.marker([hut.lat, hut.lng]);
                  marker.bindTooltip(hut.name, { permanent: true, direction: 'bottom', className: 'hutten-bubble', offset: [0, 10] });
                  marker.bindPopup("Lade...", {minWidth: 300});

                  marker.on('click', () => {
                        const isSelected = appState.selectedHuts.some(h => h.id === hut.id);
                        const bilderUrls = (hut.fotos || []).filter(f => typeof f === 'string' || f.status === 'freigegeben').map(f => typeof f === 'string' ? f : f.url);
                        
                        // *** NEUE √ñFFNUNGSZEITEN-LOGIK (von dir bereitgestellt) ***
                        let oeffnungszeitenHTML = '<p>Keine Angabe</p>';
                        if (hut.immerGeoeffnet === true) {
                            oeffnungszeitenHTML = "<p>Immer ge√∂ffnet ‚úÖ</p>";
                        } else if (Array.isArray(hut.oeffnungszeiten) && hut.oeffnungszeiten.length > 0) {
                            // Pr√ºfen, ob es das {tag, von, bis} Format ist
                            if (typeof hut.oeffnungszeiten[0] === 'object' && hut.oeffnungszeiten[0] !== null && 'tag' in hut.oeffnungszeiten[0]) {
                                oeffnungszeitenHTML = "<ul class='oeffnungszeiten-list'>" +
                                    hut.oeffnungszeiten
                                    .map(e => `<li><span class="tag">${e.tag}:</span> <span class="zeit">${e.von || '‚Äì'} - ${e.bis || '‚Äì'}</span></li>`)
                                    .join("") +
                                "</ul>";
                            } else {
                                // Fallback f√ºr einfaches String-Array
                                oeffnungszeitenHTML = "<ul class='oeffnungszeiten-list'>" + hut.oeffnungszeiten.map(e => `<li>${e}</li>`).join("") + "</ul>";
                            }
                        } else if (typeof hut.oeffnungszeiten === "object" && hut.oeffnungszeiten !== null && !Array.isArray(hut.oeffnungszeiten)) {
                            // Handling f√ºr Map-Objekt {Mo: {start: "...", ende: "..."}}
                            const tage = Object.entries(hut.oeffnungszeiten);
                            if (tage.length > 0) {
                                oeffnungszeitenHTML = "<ul class='oeffnungszeiten-list'>" +
                                    tage.map(([tag, val]) =>
                                    `<li><span class="tag">${tag}:</span> <span class="zeit">${(val.start || "‚Äì")} - ${(val.ende || "‚Äì")}</span></li>`
                                    ).join("") +
                                    "</ul>";
                            }
                        } else if (typeof hut.oeffnungszeiten === "string" && hut.oeffnungszeiten.trim()) {
                            // Fallback f√ºr den alten String-Typ
                            oeffnungszeitenHTML = `<p>${hut.oeffnungszeiten.replace(/\n/g, '<br>')}</p>`;
                        }
                        // *** ENDE √ñFFNUNGSZEITEN-LOGIK ***

                        const popupContent = `
                            <div class="popup-card overflow-hidden">
                                ${bilderUrls.length > 0 ? `
                                <div class="swiper popup-swiper">
                                  <div class="swiper-wrapper">
                                    ${bilderUrls.map(url => `<div class="swiper-slide"><img src="${url}" alt="${hut.name}"></div>`).join('')}
                                  </div>
                                  <div class="swiper-pagination"></div><div class="swiper-button-prev !text-white"></div><div class="swiper-button-next !text-white"></div>
                                </div>
                                ` : `<img src="${config.noImagePlaceholders[0]}" class="popup-swiper-img">`}
                                
                                <div class="popup-content-area space-y-3"> 
                                    <div class="flex justify-between items-start">
                                        <h3 class="font-bold text-lg leading-tight pr-2">${hut.name}</h3>
                                        ${hut.premium ? `<span class="text-xs font-bold text-yellow-800 bg-yellow-200 dark:bg-yellow-800 dark:text-yellow-200 px-2 py-1 rounded-full flex-shrink-0">PREMIUM</span>` : ''}
                                    </div>

                                    ${hut.beschreibung ? `<p class="text-sm text-gray-600 dark:text-gray-300 border-t border-b border-[var(--border-color)] py-2">${hut.beschreibung}</p>` : ''}
                                    
                                     <div class="text-sm border-t border-[var(--border-color)] pt-2">
                                        <h4 class="font-semibold text-xs uppercase text-gray-500 mb-1">√ñffnungszeiten</h4>
                                        <div>${oeffnungszeitenHTML}</div> <!-- Variable hier eingef√ºgt -->
                                    </div>


                                    <div class="grid grid-cols-2 gap-2 text-sm">
                                        <div class="flex items-center gap-2">
                                           <span>üêæ</span>
                                           <span>Tiere: ${hut.tiere ? hut.tiere.join(', ') : 'Keine'}</span>
                                        </div>
                                        <div class="flex items-center gap-2">
                                           <span>‚ö°Ô∏è</span>
                                           <span>Strom: ${hut.strom || 'k.A.'}</span>
                                        </div>
                                        <div class="flex items-center gap-2">
                                           <span>ü™ë</span>
                                           <span>Pl√§tze: ${hut.sitzplaetze || 'k.A.'}</span>
                                        </div>
                                    </div>
                                    
                                    ${hut.premium ? `
                                        <div class="space-y-1 text-sm border-t border-[var(--border-color)] pt-2">
                                            <h4 class="font-semibold text-xs uppercase text-gray-500">Premium Info</h4>
                                            ${hut.telefon ? `<p>üìû <a href="tel:${hut.telefon}" class="text-blue-500 hover:underline">${hut.telefon}</a></p>`: ''}
                                            ${hut.website ? `<p>üåê <a href="${hut.website}" target="_blank" rel="noopener" class="text-blue-500 hover:underline">Website</a></p>`: ''}
                                        </div>
                                    `: ''}
                                </div> 
                                <div class="popup-button-container">
                                    <button id="btn-${hut.id}" class="w-full p-2 rounded-lg font-semibold text-white ${isSelected ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600'} transition-colors">
                                        ${isSelected ? 'Von Tour entfernen' : 'Zur Tour hinzuf√ºgen'}
                                    </button>
                                </div>
                            </div>
                        `;
                        marker.setPopupContent(popupContent).openPopup();
                        
                        setTimeout(() => {
                           const btn = document.getElementById(`btn-${hut.id}`);
                           if(btn) {
                               btn.onclick = () => {
                                    routeManager.toggleSelect(hut);
                                    marker.closePopup();
                                };
                           }
                            const swiperEl = marker.getPopup()?.getElement()?.querySelector('.popup-swiper');
                            if (swiperEl && !swiperEl.swiper) {
                                new Swiper(swiperEl, {
                                    loop: true,
                                    pagination: { el: '.swiper-pagination', clickable: true },
                                    navigation: {
                                        nextEl: '.swiper-button-next',
                                        prevEl: '.swiper-button-prev',
                                    },
                                });
                            }
                        }, 0);
                    });
                  mapManager.clusterGroup.addLayer(marker);
             });
        },


        loadHuts() {
            this.db.collection("eierhuetten").where("status", "==", "angenommen").onSnapshot(snapshot => {
                const huts = [];
                snapshot.forEach(doc => {
                    const data = doc.data();
                    if (data.location) {
                       huts.push({ id: doc.id, ...data, lat: data.location.latitude, lng: data.location.longitude });
                    }
                });
                appState.allHuts = huts;
                this.displayHuts(huts); // Use helper to display
                // Save huts to localStorage for offline use
                 localStorage.setItem('allHutsData', JSON.stringify(huts));
            }, err => {
                console.error("Fehler beim Laden der H√ºtten:", err);
                uiManager.showToast("H√ºtten konnten nicht geladen werden. Versuche Offline-Daten...");
                this.loadOfflineHuts(); // Attempt offline load on error
            });
        },
        
        rejoinLastRoom() {
            const lastRoomId = localStorage.getItem('lastRoomId');
            if(lastRoomId) {
                if(confirm(`M√∂chtest du dem Raum "${lastRoomId}" wieder beitreten?`)) {
                    this.joinRoom(lastRoomId);
                }
            }
        },
        
        joinRoom(id = null) {
            let roomId = id || document.getElementById('roomIdInput').value.trim();
            if(!roomId) roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
            
            appState.currentRoom.id = roomId;
            localStorage.setItem('lastRoomId', roomId);
            
            this.listenToRoom(roomId);
            this.listenToUsersInRoom(roomId);
            userManager.startWatchingPosition(); 
            
            uiManager.updateRoomUI(appState.currentRoom);
            uiManager.showToast(`Raum ${roomId} beigetreten.`);
        },
        
        leaveRoom() {
            if(appState.roomUnsubscribe) appState.roomUnsubscribe();
            if(appState.userPositionsUnsubscribe) appState.userPositionsUnsubscribe();
            
            localStorage.removeItem('lastRoomId');
            
            if(appState.currentRoom.id) {
                this.db.collection('room_positions').doc(appState.currentRoom.id).collection('users').doc(userManager.userId).delete();
            }

            appState.currentRoom.id = null;
            appState.currentRoom.guideId = null;
            
            Object.keys(mapManager.groupMarkers).forEach(id => mapManager.removeGroupMarker(id));

            uiManager.updateRoomUI(appState.currentRoom);
            uiManager.showToast("Raum verlassen.");
        },
        
        listenToRoom(roomId) {
            if(appState.roomUnsubscribe) appState.roomUnsubscribe();
            appState.roomUnsubscribe = this.db.collection("rooms").doc(roomId).onSnapshot(doc => {
                const roomData = doc.data() || {};
                appState.currentRoom = {id: roomId, ...roomData};
                
                const isSelfGuide = userManager.userId === roomData.guideId;

                // Sync tour for non-guides
                if (!isSelfGuide) {
                    const hutIds = roomData.hutIds || [];
                    const localIds = appState.selectedHuts.map(h => h.id).join(',');
                    if (hutIds.join(',') !== localIds) {
                        appState.selectedHuts = hutIds.map(id => appState.allHuts.find(h => h.id === id)).filter(Boolean);
                        uiManager.updateSelectedList();
                        routeManager.recalculatePreviewRoute();
                         uiManager.showToast("Tour im Raum wurde aktualisiert!");
                    }
                    // Sync navigation for non-guides
                     if(roomData.isNavigating && !appState.isNavigating && roomData.guidedRoute) {
                        routeManager.routeData = roomData.guidedRoute;
                        mapManager.drawRoute(roomData.guidedRoute.coords);
                        uiManager.setNavigationState(true);
                        userManager.startWatchingPosition(); // Start watching to follow guide
                    } else if (!roomData.isNavigating && appState.isNavigating && !isSelfGuide) {
                        routeManager.stopNavigation(); // Stop navigation if guide stops
                    }
                }
                uiManager.updateRoomUI(appState.currentRoom);
            });
        },
        
        listenToUsersInRoom(roomId) {
            if (appState.userPositionsUnsubscribe) appState.userPositionsUnsubscribe();
            appState.userPositionsUnsubscribe = this.db.collection('room_positions').doc(roomId).collection('users').onSnapshot(snapshot => {
                const activeUsers = [];
                const now = Date.now();
                const currentMemberIds = new Set();
                
                snapshot.forEach(doc => {
                    const user = doc.data();
                    const userId = doc.id;
                    currentMemberIds.add(userId);

                    if (userId !== userManager.userId && user.timestamp && (now - user.timestamp) < 60000) { // Check timestamp existence
                        mapManager.updateGroupMarker({ id: userId, ...user });
                        activeUsers.push(user);
                    } else if (userId !== userManager.userId) {
                        mapManager.removeGroupMarker(userId);
                    }
                });

                Object.keys(mapManager.groupMarkers).forEach(markerId => {
                    if (!currentMemberIds.has(markerId)) {
                        mapManager.removeGroupMarker(markerId);
                    }
                });

                uiManager.updateRoomUI(appState.currentRoom, activeUsers);
            });
        },
        
        updateUserPositionInRoom(pos) {
            if(!appState.currentRoom.id) return;
            const name = localStorage.getItem('username') || 'Anonym';
            const colors = ['#e11d48', '#2563eb', '#16a34a', '#f97316', '#9333ea'];
            const color = colors[Math.abs(userManager.userId.charCodeAt(0) % colors.length)];
            
            this.db.collection('room_positions').doc(appState.currentRoom.id).collection('users').doc(userManager.userId).set({
                lat: pos.lat,
                lng: pos.lng,
                name: name,
                color: color,
                timestamp: Date.now()
            }, { merge: true });
        },
        
        updateRoomHuts() {
            if(!appState.currentRoom.id) return;
            const hutIds = appState.selectedHuts.map(h => h.id);
            this.db.collection("rooms").doc(appState.currentRoom.id).set({ hutIds }, { merge: true });
        },

        setGuide() {
            if(!appState.currentRoom.id) return;
            let newGuideId = userManager.userId;
            let newGuideName = localStorage.getItem('username') || 'Anonym';

            if (appState.currentRoom.guideId === userManager.userId) {
                newGuideId = null;
                newGuideName = null;
                 firebaseManager.updateGuidedRoute(false, null); // Stop navigation if relinquishing guide role
            } else if (appState.currentRoom.guideId) {
                uiManager.showToast("Es gibt bereits einen Guide.");
                return; // Only allow setting if no guide or self
            }
            this.db.collection("rooms").doc(appState.currentRoom.id).set({ guideId: newGuideId, guideName: newGuideName }, { merge: true });
        },

        updateGuidedRoute(isNavigating, routeData) {
            if(!appState.currentRoom.id) return;
            this.db.collection("rooms").doc(appState.currentRoom.id).set({
                isNavigating: isNavigating,
                guidedRoute: routeData ? JSON.parse(JSON.stringify(routeData)) : null, // Ensure serializability
            }, { merge: true });
        },

        addWarning() {
            const type = document.getElementById('warning-type').value;
            const description = document.getElementById('warning-description').value;
            const latlng = uiManager.tempWarningLatLng;
            if(!latlng) return;

            this.db.collection('warnings').add({
                lat: latlng.lat,
                lng: latlng.lng,
                type: type,
                description: description,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                userId: userManager.userId,
            }).then(() => {
                uiManager.showToast("Gefahr gemeldet!");
                uiManager.hideAddWarningModal();
            });
        },

       listenToWarnings() {
            const twentyFourHoursAgoTimestamp = firebase.firestore.Timestamp.fromMillis(Date.now() - (24 * 60 * 60 * 1000));
            
            this.db.collection('warnings')
               .where('createdAt', '>', twentyFourHoursAgoTimestamp) // Query directly in Firestore
               .onSnapshot(snapshot => {
                    const currentWarningIds = new Set();
                    appState.allWarnings = [];

                    snapshot.forEach(doc => {
                        const warning = { id: doc.id, ...doc.data() };
                        // Ensure createdAt is a Date object for comparison if needed client-side
                        if (warning.createdAt && warning.createdAt.toDate) {
                           warning.createdAt = warning.createdAt.toDate();
                        } else {
                            // Handle cases where createdAt might not be a Firestore timestamp
                            warning.createdAt = new Date(); // Fallback to now if missing/invalid
                        }

                        appState.allWarnings.push(warning);
                        currentWarningIds.add(warning.id);
                        if (!mapManager.warningMarkers[warning.id]) {
                           mapManager.addWarningMarker(warning);
                        }
                    });

                    // Remove markers for expired or deleted warnings
                    Object.keys(mapManager.warningMarkers).forEach(markerId => {
                        if (!currentWarningIds.has(markerId)) {
                            mapManager.removeWarningMarker(markerId);
                        }
                    });
                    // Reset warnedAbout set for potentially expired warnings
                    userManager.warnedAbout.forEach(warnedId => {
                        if (!currentWarningIds.has(warnedId)) {
                            userManager.warnedAbout.delete(warnedId);
                        }
                    });
            });
        }
    };
    
    const dragAndDrop = {
        draggedIndex: null,
        start(event, index) {
            this.draggedIndex = index;
            event.dataTransfer.effectAllowed = 'move';
        },
        drop(event, targetIndex) {
            event.preventDefault();
            if (this.draggedIndex === null || this.draggedIndex === targetIndex) return;

            const draggedItem = appState.selectedHuts.splice(this.draggedIndex, 1)[0];
            appState.selectedHuts.splice(targetIndex, 0, draggedItem);

            this.draggedIndex = null;
            uiManager.updateSelectedList();
            
            // *** √ÑNDERUNG HIER: Live-Neuberechnung ***
            if (appState.isNavigating) {
                uiManager.showToast("Route wird aktualisiert...");
                routeManager.startNavigation(); // Live-Update der Navigation
            } else {
                routeManager.recalculatePreviewRoute(); // Nur Vorschau aktualisieren
            }
            
            if (appState.currentRoom.id) {
                firebaseManager.updateRoomHuts();
            }
        }
    };

    const weatherManager = {
        lastFetchTime: 0,
        currentWeather: null, // SMARTER: Wetter f√ºr KI-Prompts speichern

        async fetchWeather(lat, lng) {
            const now = Date.now();
            if (now - this.lastFetchTime < 10 * 60 * 1000) return; // Update every 10 mins
            this.lastFetchTime = now;
            
            if (!navigator.onLine) return; // Nicht fetchen, wenn offline

            try {
                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true`);
                const data = await response.json();
                if(data && data.current_weather) {
                    this.updateWidget(data.current_weather);
                }
            } catch (error) {
                console.error("Fehler beim Laden des Wetters:", error);
            }
        },
        updateWidget(weather) {
            this.currentWeather = weather; // SMARTER: Wetter speichern
            const widget = document.getElementById('weather-widget');
            const icon = this.getWeatherIcon(weather.weathercode);
            const temp = Math.round(weather.temperature);
            // Update widget content, but keep offline indicator
            widget.querySelector('span:first-child').textContent = icon;
            widget.querySelector('span:nth-child(2)').textContent = `${temp}¬∞C`;
        },
        getWeatherIcon(code) {
            if (code === 0) return '‚òÄÔ∏è';
            if (code >= 1 && code <= 3) return '‚õÖÔ∏è';
            if (code === 45 || code === 48) return 'üå´Ô∏è';
            if (code >= 51 && code <= 55) return 'üå¶Ô∏è';
            if (code >= 61 && code <= 67) return 'üåßÔ∏è';
            if (code >= 71 && code <= 77) return '‚ùÑÔ∏è';
            if (code >= 80 && code <= 82) return '‚õàÔ∏è';
            if (code >= 95 && code <= 99) return 'üå©Ô∏è';
            return '-';
        },
        
        /**
         * SMARTER: Ruft H√∂hendaten f√ºr eine Reihe von Koordinaten ab.
         * @param {Array<Array<number>>} coordinates - Ein Array von [lat, lng] Koordinaten.
         * @returns {object | null} Ein Objekt mit einem 'elevation' Array oder null bei Fehler.
         */
        async fetchElevation(coordinates) {
            if (!navigator.onLine) {
                uiManager.showToast("Offline. H√∂henprofil kann nicht geladen werden.");
                return null;
            }
            // Open-Meteo ben√∂tigt separate Lat/Lng-Arrays
            // Reduziere die Anzahl der Punkte f√ºr die API-Anfrage, um die URL-L√§nge nicht zu sprengen
            const sampleRate = Math.max(1, Math.floor(coordinates.length / 100)); // Max 100 Punkte
            const sampledCoords = coordinates.filter((_, i) => i % sampleRate === 0);
            
            const lats = sampledCoords.map(c => c[0].toFixed(2)).join(',');
            const lngs = sampledCoords.map(c => c[1].toFixed(2)).join(',');
            
            const url = `https://api.open-meteo.com/v1/elevation?latitude=${lats}&longitude=${lngs}`;
            
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error('H√∂hen-API nicht erreichbar.');
                const data = await response.json();
                if (!data || !data.elevation) throw new Error('Ung√ºltige H√∂hendaten.');
                return data;
            } catch (error) {
                console.error("Fehler beim Laden des H√∂henprofils:", error);
                uiManager.showToast("H√∂henprofil konnte nicht geladen werden.");
                return null;
            }
        }
    };

    // ----------------------------------------------------------
    //  5. INITIALISIERUNG
    // ----------------------------------------------------------
    document.addEventListener('DOMContentLoaded', () => {
        uiManager.setLoading(true);
        uiManager.init();
        mapManager.init(config.map.defaultCenter, config.map.defaultZoom);
        firebaseManager.init();
        userManager.init();
    });

  </script>
</body>
</html>

