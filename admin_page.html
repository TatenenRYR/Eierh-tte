//=================================================//
// === NEUE FUNKTIONEN (AB HIER EINF√úGEN) ===
//=================================================//

// === 1. NEU: EINSTELLUNGEN (CONFIG) ===
async function loadSettings() {
    try {
        const [configDoc, typesDoc, animalsDoc] = await Promise.all([
            db.collection('config').doc('support').get(),
            db.collection('config').doc('hutTypes').get(),
            db.collection('config').doc('animalTypes').get()
        ]);

        if (configDoc.exists) {
            systemConfig.cannedResponses = configDoc.data().responses || [];
        } else {
            // Fallback, falls DB-Eintrag fehlt
            systemConfig.cannedResponses = [{ title: "Standard (Fallback)", text: "Hallo, danke f√ºr Ihre Nachricht." }];
        }

        if (typesDoc.exists) {
            systemConfig.hutTypes = typesDoc.data() || {};
        } else {
            systemConfig.hutTypes = { 'Eierh√ºtte': 'ü•ö', 'Hofladen': 'üè™' }; // Fallback
        }
        
        if (animalsDoc.exists) {
            systemConfig.animalTypes = animalsDoc.data() || {};
        } else {
            systemConfig.animalTypes = { 'ü¶ô': 'Alpaka', 'üêÑ': 'Kuh', '‚ùå': 'Keine Tiere' }; // Fallback
        }
        
        // Listener f√ºr Settings-Seite, falls sie gerade angezeigt wird
        if (document.getElementById('settings').classList.contains('active')) {
             renderSettingsEditors();
        }
    } catch (e) {
        console.error("Fehler beim Laden der System-Config:", e);
        showNotification("‚ùå Fehler beim Laden der Config.");
    }
}

// Wird beim Klick auf den "Einstellungen"-Tab im Men√º aufgerufen
document.querySelector('.nav-btn[onclick="showSection(\'settings\')"]')?.addEventListener('click', renderSettingsEditors);

function renderSettingsEditors() {
    renderCannedResponsesEditor();
    renderHutTypesEditor();
    renderAnimalTypesEditor();
    renderMyAccountTab(); // Sicherstellen, dass der Account-Tab auch gerendert wird
}

// Textbaustein-Editor
function renderCannedResponsesEditor() {
    const listEl = document.getElementById('canned-response-editor-list');
    if (!listEl) return;
    listEl.innerHTML = systemConfig.cannedResponses.map((r, idx) => `
        <div class="border rounded p-3">
            <input class="w-full border-b font-semibold p-1" value="${escapeAttr(r.title)}" onchange="updateCannedResponse(${idx}, 'title', this.value)">
            <textarea class="w-full border-t p-1 mt-2 text-sm" rows="3" onchange="updateCannedResponse(${idx}, 'text', this.value)">${escapeHtml(r.text)}</textarea>
            <button onclick="deleteCannedResponse(${idx})" class="text-red-500 text-xs hover:underline">L√∂schen</button>
        </div>
    `).join('') || '<p>Keine Textbausteine.</p>';
}
async function updateCannedResponse(idx, field, value) {
    if (!systemConfig.cannedResponses[idx]) return;
    systemConfig.cannedResponses[idx][field] = value;
    await saveCannedResponses();
}
async function deleteCannedResponse(idx) {
    if (!confirm("Textbaustein l√∂schen?")) return;
    systemConfig.cannedResponses.splice(idx, 1);
    await saveCannedResponses();
    renderCannedResponsesEditor();
}
async function saveCannedResponse(idx) { // F√ºr neuen Baustein
    const title = document.getElementById('canned-new-title').value.trim();
    const text = document.getElementById('canned-new-text').value.trim();
    if (!title || !text) return;
    systemConfig.cannedResponses.push({ title, text });
    await saveCannedResponses();
    renderCannedResponsesEditor();
    document.getElementById('canned-new-title').value = '';
    document.getElementById('canned-new-text').value = '';
}
async function saveCannedResponses() {
    try {
        await db.collection('config').doc('support').set({ responses: systemConfig.cannedResponses });
        showNotification("‚úÖ Textbausteine gespeichert.");
    } catch (e) { showNotification("‚ùå Fehler: " + e.message); }
}

// H√ºtten-Typen-Editor
function renderHutTypesEditor() {
    const listEl = document.getElementById('hut-types-editor-list');
    if (!listEl) return;
    listEl.innerHTML = Object.entries(systemConfig.hutTypes).map(([name, icon]) => `
        <div class="flex gap-2 p-2 border rounded">
            <span class="text-xl">${icon}</span>
            <span class="font-semibold flex-grow">${escapeHtml(name)}</span>
            <button onclick="deleteHutType('${escapeAttr(name)}')" class="text-red-500 text-xs hover:underline">L√∂schen</button>
        </div>
    `).join('');
}
async function saveHutType() {
    const icon = document.getElementById('hut-type-new-icon').value.trim();
    const name = document.getElementById('hut-type-new-name').value.trim();
    if (!icon || !name) return;
    systemConfig.hutTypes[name] = icon;
    try {
        await db.collection('config').doc('hutTypes').set(systemConfig.hutTypes);
        showNotification("‚úÖ Typ gespeichert.");
        renderHutTypesEditor();
        document.getElementById('hut-type-new-icon').value = '';
        document.getElementById('hut-type-new-name').value = '';
    } catch (e) { showNotification("‚ùå Fehler: " + e.message); }
}
async function deleteHutType(name) {
    if (!confirm(`Typ "${name}" l√∂schen?`)) return;
    delete systemConfig.hutTypes[name];
    try {
        await db.collection('config').doc('hutTypes').set(systemConfig.hutTypes);
        showNotification("‚úÖ Typ gel√∂scht.");
        renderHutTypesEditor();
    } catch (e) { showNotification("‚ùå Fehler: " + e.message); }
}

// Tier-Typen-Editor
function renderAnimalTypesEditor() {
    const listEl = document.getElementById('animal-types-editor-list');
    if (!listEl) return;
    listEl.innerHTML = Object.entries(systemConfig.animalTypes).map(([icon, name]) => `
        <div class="flex gap-2 p-2 border rounded">
            <span class="text-xl">${icon}</span>
            <span class="font-semibold flex-grow">${escapeHtml(name)}</span>
            <button onclick="deleteAnimalType('${escapeAttr(icon)}')" class="text-red-500 text-xs hover:underline">L√∂schen</button>
        </div>
    `).join('');
}
async function saveAnimalType() {
    const icon = document.getElementById('animal-type-new-icon').value.trim();
    const name = document.getElementById('animal-type-new-name').value.trim();
    if (!icon || !name) return;
    systemConfig.animalTypes[icon] = name;
    try {
        await db.collection('config').doc('animalTypes').set(systemConfig.animalTypes);
        showNotification("‚úÖ Tier gespeichert.");
        renderAnimalTypesEditor();
        document.getElementById('animal-type-new-icon').value = '';
        document.getElementById('animal-type-new-name').value = '';
    } catch (e) { showNotification("‚ùå Fehler: " + e.message); }
}
async function deleteAnimalType(icon) {
    if (!confirm(`Tier "${icon}" l√∂schen?`)) return;
    delete systemConfig.animalTypes[icon];
    try {
        await db.collection('config').doc('animalTypes').set(systemConfig.animalTypes);
        showNotification("‚úÖ Tier gel√∂scht.");
        renderAnimalTypesEditor();
    } catch (e) { showNotification("‚ùå Fehler: " + e.message); }
}

// === 2. NEU: COMMUNITY (BEWERTUNGEN) ===
function initLiveReviewQueue() {
    db.collection('hutReviews').where('status', '==', 'offen').orderBy('createdAt', 'desc').onSnapshot(snap => {
        allReviews = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        renderReviewTable();
        const b = document.getElementById('review-queue-badge');
        b.textContent = allReviews.length;
        b.classList.toggle('hidden', allReviews.length === 0);
    }, err => console.error("Review Listener:", err));
}

function renderReviewTable() {
    const tableBody = document.getElementById('review-table-body');
    if (!tableBody) return;
    if (allReviews.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="5" class="text-center italic py-4">Keine offenen Bewertungen.</td></tr>`;
        return;
    }
    tableBody.innerHTML = allReviews.map(r => {
        const hut = allHuts.find(h => h.id === r.hutId);
        const hutName = hut ? hut.name : (r.hutId || 'Unbekannt');
        const stars = '‚≠ê'.repeat(r.rating || 0) + '‚òÜ'.repeat(5 - (r.rating || 0));
        return `
            <tr>
                <td><a onclick="openHutModal('${r.hutId}')" class="text-blue-600 hover:underline cursor-pointer">${escapeHtml(hutName)}</a></td>
                <td>${escapeHtml(r.userName || r.userId.substring(0, 8))}...</td>
                <td class="review-stars">${stars}</td>
                <td class="text-sm">${escapeHtml(r.comment || '')}</td>
                <td>
                    <button onclick="approveReview('${r.id}')" class="bg-green-500 text-white px-3 py-1 rounded text-sm">Freigeben</button>
                    <button onclick="rejectReview('${r.id}')" class="bg-red-500 text-white px-3 py-1 rounded text-sm ml-1">L√∂schen</button>
                </td>
            </tr>
        `;
    }).join('');
}

async function approveReview(reviewId) {
    try {
        await db.collection('hutReviews').doc(reviewId).update({ status: 'angenommen' });
        logAdminAction('Bewertung freigegeben', { reviewId });
        showNotification('‚úÖ Bewertung frei.');
    } catch(e) { console.error(e); showNotification("‚ùå Fehler."); }
}
async function rejectReview(reviewId) {
    if (!confirm('Bewertung l√∂schen?')) return;
    try {
        await db.collection('hutReviews').doc(reviewId).delete();
        logAdminAction('Bewertung gel√∂scht', { reviewId });
        showNotification('üóëÔ∏è Bewertung weg.');
    } catch(e) { console.error(e); showNotification("‚ùå Fehler."); }
}

// Funktion f√ºr den "Bewertungen"-Tab im H√ºtten-Modal
async function loadReviewsForHut(hutId) {
    const listEl = document.getElementById('modal-review-list');
    if (!listEl) return;
    listEl.innerHTML = "L√§dt...";
    try {
        const snap = await db.collection('hutReviews')
            .where('hutId', '==', hutId)
            .orderBy('createdAt', 'desc')
            .limit(50)
            .get();
        if (snap.empty) {
            listEl.innerHTML = '<p>Keine Bewertungen f√ºr diese H√ºtte.</p>';
            return;
        }
        listEl.innerHTML = snap.docs.map(doc => {
            const r = doc.data();
            const stars = '‚≠ê'.repeat(r.rating || 0) + '‚òÜ'.repeat(5 - (r.rating || 0));
            const statusClass = r.status === 'offen' ? 'bg-yellow-100' : 'bg-white';
            const d = r.createdAt?.toDate?.().toLocaleString("de-DE") || "-";
            return `
                <div class="border-b pb-2 mb-2 ${statusClass} p-2 rounded">
                    <div class="flex justify-between text-xs text-gray-500 mb-1">
                        <span>Von: ${escapeHtml(r.userName || 'Gast')}</span>
                        <span class="review-stars">${stars}</span>
                        <span>${d}</span>
                    </div>
                    <p>${escapeHtml(r.comment || "")}</p>
                    <div class="mt-2">
                        ${r.status === 'offen' ? `<button onclick="approveReview('${doc.id}')" class="text-xs bg-green-500 text-white px-2 py-0.5 rounded">Freigeben</button>` : ''}
                        <button class="text-red-500 text-xs hover:underline ml-2" onclick="rejectReview('${doc.id}')">L√∂schen</button>
                    </div>
                </div>
            `;
        }).join('');
    } catch (e) {
        console.error(e);
        listEl.innerHTML = '<p class="text-red-500">Fehler beim Laden der Reviews.</p>';
    }
}
// Hook f√ºr den Tab-Klick im H√ºtten-Modal
function showModalTab(tabId) {
    // ... (existierende Logik) ...
    document.getElementById(`tab-${tabId}`)?.classList.add('active');
    
    // MODIFIZIERT: Review-Tab-Hook
    if(tabId==='stammdaten'){ /* ... (existierende Map-Logik) ... */ }
    if(tabId==='fotos'){ /* ... (existierende Foto-Logik) ... */ }
    if(tabId==='reviews' && currentEditingHutId) {
        loadReviewsForHut(currentEditingHutId);
    }
}

// === 3. NEU: COMMUNITY (ADMIN-ZU-USER-NACHRICHT) ===
const userMessageModal = document.getElementById('user-message-modal');
function openUserMessageModal(userId, email) {
    document.getElementById('user-message-uid').value = userId;
    document.getElementById('user-message-email').innerText = email;
    document.getElementById('user-message-body').value = '';
    userMessageModal.classList.add('flex');
}
function closeUserMessageModal() {
    userMessageModal.classList.remove('flex');
}
async function sendUserMessage() {
    const btn = document.getElementById('user-message-send-btn');
    btn.disabled = true;
    btn.classList.add('button-loading');
    
    const userId = document.getElementById('user-message-uid').value;
    const email = document.getElementById('user-message-email').innerText;
    const subject = document.getElementById('user-message-subject').value;
    const body = document.getElementById('user-message-body').value;
    
    if (!userId || !subject || !body) {
        showNotification("‚ùå Alle Felder ausf√ºllen.");
        btn.disabled = false;
        btn.classList.remove('button-loading');
        return;
    }

    try {
        // HIER IST DIE EIGENTLICHE IMPLEMENTIERUNG N√ñTIG
        // Dies erfordert eine Firebase Function, die z.B. per HTTPS
        // aufgerufen wird oder in eine "mailQueue"-Collection schreibt.
        
        // Simulation: Wir loggen es nur
        console.log(`SIMULATION: Sende Mail an ${email}`);
        console.log(`Betreff: ${subject}`);
        console.log(`Body: ${body}`);
        
        // Wir k√∂nnen die Nachricht aber in einer DB speichern (f√ºr den User sichtbar?)
        // oder einfach als Admin-Log vermerken.
        await logAdminAction('Admin-Mail an User', { userId, email, subject });
        
        showNotification("‚úÖ Mail-Versand (simuliert).");
        closeUserMessageModal();
        
    } catch (e) {
        console.error("Mail-Fehler:", e);
        showNotification("‚ùå Mail-Fehler: " + e.message);
    } finally {
        btn.disabled = false;
        btn.classList.remove('button-loading');
    }
}

// === 4. NEU: CONTENT (ROUTEN-MANAGEMENT) ===
const routeEditModal = document.getElementById('route-edit-modal');
let selectedHutsForRoute = []; // [{id, name}]

function initRoutesListener() {
    db.collection('routes').orderBy('createdAt', 'desc').onSnapshot(snap => {
        allRoutes = snap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        renderRoutesTable();
    }, err => console.error("Routes Listener:", err));
}

function renderRoutesTable() {
    const tableBody = document.getElementById('route-table-body');
    if (!tableBody) return;
    if (allRoutes.length === 0) {
        tableBody.innerHTML = `<tr><td colspan="4" class="text-center italic py-4">Keine Routen erstellt.</td></tr>`;
        return;
    }
    tableBody.innerHTML = allRoutes.map(r => `
        <tr>
            <td>${escapeHtml(r.name)}</td>
            <td>${(r.hutIds || []).length}</td>
            <td>${r.createdAt?.toDate().toLocaleDateString('de-DE') || '-'}</td>
            <td>
                <button onclick="openRouteModal('${r.id}')" class="bg-blue-600 text-white px-3 py-1 rounded text-sm">Bearbeiten</button>
            </td>
        </tr>
    `).join('');
}

function openRouteModal(routeId) {
    currentEditingRouteId = routeId;
    const titleEl = document.getElementById('route-modal-title');
    const nameEl = document.getElementById('route-modal-name');
    const descEl = document.getElementById('route-modal-desc');
    const idEl = document.getElementById('route-modal-id');
    const delBtn = document.getElementById('route-delete-btn');
    
    if (routeId) {
        const route = allRoutes.find(r => r.id === routeId);
        if (!route) return;
        titleEl.textContent = 'Route bearbeiten';
        nameEl.value = route.name || '';
        descEl.value = route.desc || '';
        idEl.value = route.id;
        delBtn.style.display = 'block';
        
        // Lade H√ºtten-Objekte basierend auf den IDs
        selectedHutsForRoute = (route.hutIds || []).map(id => {
            const hut = allHuts.find(h => h.id === id);
            return hut ? { id: hut.id, name: hut.name } : null;
        }).filter(Boolean);
        
    } else {
        titleEl.textContent = 'Neue Route erstellen';
        nameEl.value = '';
        descEl.value = '';
        idEl.value = '';
        delBtn.style.display = 'none';
        selectedHutsForRoute = [];
    }
    
    renderAvailableHutsForRoute();
    renderSelectedHutsForRoute();
    routeEditModal.classList.add('flex');
}

function closeRouteModal() {
    routeEditModal.classList.remove('flex');
    currentEditingRouteId = null;
    selectedHutsForRoute = [];
}

function renderAvailableHutsForRoute() {
    const listEl = document.getElementById('route-available-huts');
    const search = document.getElementById('route-hut-search').value.toLowerCase();
    if (!listEl) return;
    
    const available = allHuts.filter(h => 
        h.status === 'angenommen' && // Nur angenommene H√ºtten
        !selectedHutsForRoute.some(s => s.id === h.id) && // Nicht schon ausgew√§hlt
        (search === '' || h.name.toLowerCase().includes(search)) // Suchfilter
    );
    
    listEl.innerHTML = available.slice(0, 50).map(h => `
        <div class="flex justify-between items-center p-2 hover:bg-gray-100">
            <span class="text-sm truncate">${escapeHtml(h.name)}</span>
            <button onclick="addHutToRoute('${h.id}', '${escapeAttr(h.name)}')" class="text-green-600 font-bold text-lg">+</button>
        </div>
    `).join('') || '<p class="text-xs italic p-2">Keine H√ºtten gefunden.</p>';
}

function renderSelectedHutsForRoute() {
    const listEl = document.getElementById('route-selected-huts');
    if (!listEl) return;
    listEl.innerHTML = selectedHutsForRoute.map((h, index) => `
        <div class="route-hut-list-item" draggable="true" data-index="${index}">
            <span class="text-sm"><strong>${index + 1}.</strong> ${escapeHtml(h.name)}</span>
            <button onclick="removeHutFromRoute(${index})" class="text-red-500 font-bold text-lg">√ó</button>
        </div>
    `).join('') || '<p class="text-xs italic p-2">Noch keine H√ºtten.</p>';
    
    // Drag & Drop Listener
    addRouteDragDropListeners();
}

function addHutToRoute(id, name) {
    selectedHutsForRoute.push({ id, name: unescapeAttr(name) });
    renderAvailableHutsForRoute();
    renderSelectedHutsForRoute();
}

function removeHutFromRoute(index) {
    selectedHutsForRoute.splice(index, 1);
    renderAvailableHutsForRoute();
    renderSelectedHutsForRoute();
}

function addRouteDragDropListeners() {
    const list = document.getElementById('route-selected-huts');
    list.querySelectorAll('.route-hut-list-item').forEach(item => {
        item.addEventListener('dragstart', handleRouteDragStart);
        item.addEventListener('dragover', handleRouteDragOver);
        item.addEventListener('drop', handleRouteDrop);
        item.addEventListener('dragend', handleRouteDragEnd);
    });
}
function handleRouteDragStart(e) {
    routeHutDragEl = this;
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/html', this.innerHTML);
    this.classList.add('opacity-50');
}
function handleRouteDragOver(e) {
    e.preventDefault();
    this.classList.add('bg-emerald-100');
}
function handleRouteDrop(e) {
    e.stopPropagation();
    if (routeHutDragEl !== this) {
        const fromIndex = parseInt(routeHutDragEl.dataset.index);
        const toIndex = parseInt(this.dataset.index);
        
        // Array neu sortieren
        const [movedItem] = selectedHutsForRoute.splice(fromIndex, 1);
        selectedHutsForRoute.splice(toIndex, 0, movedItem);
        
        renderSelectedHutsForRoute();
    }
    this.classList.remove('bg-emerald-100');
    return false;
}
function handleRouteDragEnd() {
    this.classList.remove('opacity-50');
    document.querySelectorAll('#route-selected-huts .route-hut-list-item').forEach(item => {
        item.classList.remove('bg-emerald-100');
    });
    routeHutDragEl = null;
}
function unescapeAttr(s) {
    return String(s).replace(/&quot;/g, '"').replace(/&#039;/g, "'");
}

async function saveRouteFromModal() {
    const name = document.getElementById('route-modal-name').value.trim();
    const desc = document.getElementById('route-modal-desc').value.trim();
    if (!name || selectedHutsForRoute.length === 0) {
        showNotification("‚ùå Name und min. 1 H√ºtte n√∂tig.");
        return;
    }
    
    const hutIds = selectedHutsForRoute.map(h => h.id);
    const data = {
        name,
        desc,
        hutIds,
        adminId: currentUser.uid,
    };
    
    try {
        if (currentEditingRouteId) {
            await db.collection('routes').doc(currentEditingRouteId).update(data);
            logAdminAction('Route aktualisiert', { routeId: currentEditingRouteId, name });
        } else {
            data.createdAt = firebase.firestore.FieldValue.serverTimestamp();
            const ref = await db.collection('routes').add(data);
            logAdminAction('Route erstellt', { routeId: ref.id, name });
        }
        showNotification("‚úÖ Route gespeichert.");
        closeRouteModal();
    } catch (e) {
        console.error(e);
        showNotification("‚ùå Fehler: " + e.message);
    }
}
async function deleteRoute() {
    if (!currentEditingRouteId || !confirm("Route wirklich l√∂schen?")) return;
    try {
        await db.collection('routes').doc(currentEditingRouteId).delete();
        logAdminAction('Route gel√∂scht', { routeId: currentEditingRouteId });
        showNotification("üóëÔ∏è Route gel√∂scht.");
        closeRouteModal();
    } catch (e) {
        console.error(e);
        showNotification("‚ùå Fehler: " + e.message);
    }
}

// === 5. NEU: ERWEITERTER EXPORT ===
function exportUsersToCSV() {
    if (filteredUsers.length === 0) { showNotification("Keine User zum Export."); return; }
    const headers = ["ID", "Name", "Email", "Rolle", "HutCount", "Premium", "PremiumBis", "Banned", "LetzterLogin"];
    const rows = filteredUsers.map(u => [
        u.id, u.name, u.email, u.role, u.hutCount, u.isPremium,
        u.premiumUntil ? new Date(u.premiumUntil).toISOString() : '',
        u.banned, u.lastLogin
    ]);
    downloadCSV(headers, rows, "users_export.csv");
    logAdminAction("CSV Export (User)", { count: filteredUsers.length });
}
function exportSupportToCSV() {
    if (currentSupportTickets.length === 0) { showNotification("Keine Tickets zum Export."); return; }
    const headers = ["ID", "Datum", "Email", "Status", "Priorit√§t", "LetzteNachricht (Vorschau)"];
    const rows = currentSupportTickets.map(t => [
        t.id, t.createdAt?.toDate().toISOString(), t.mail, t.status, t.priority || 'Normal',
        document.getElementById(`msgs-preview-${t.id}`)?.textContent || t.msg || ''
    ]);
    downloadCSV(headers, rows, "support_export.csv");
    logAdminAction("CSV Export (Support)", { count: currentSupportTickets.length });
}
function exportLogsToCSV() {
    if (fullLogDataCache.length === 0) { showNotification("Keine Logs zum Export."); return; }
    const headers = ["ID", "Timestamp", "AdminName", "AdminEmail", "Aktion", "Details"];
    const rows = fullLogDataCache.map(l => [
        l.id, l.timestamp?.toDate().toISOString(), l.adminName, l.adminEmail, l.action,
        JSON.stringify(Object.fromEntries(Object.entries(l).filter(([k]) => !['id', 'timestamp', 'adminName', 'adminEmail', 'action'].includes(k))))
    ]);
    downloadCSV(headers, rows, "admin_logs_export.csv");
    logAdminAction("CSV Export (Logs)", { count: fullLogDataCache.length });
}
// Hilfsfunktion f√ºr CSV-Download
function downloadCSV(headers, rows, filename) {
    let csv = "data:text/csv;charset=utf-8," + headers.join(",") + "\n" +
              rows.map(r => r.map(c => `"${String(c || '').replace(/"/g, '""')}"`).join(",")).join("\n");
    const link = document.createElement("a");
    link.setAttribute("href", encodeURI(csv));
    link.setAttribute("download", filename);
    link.click();
    link.remove();
}


// === 6. NEU: VERTIEFTE KI-INTEGRATION (GEMINI) ===

// A. KI-Bildmoderation (Vision)
async function callGeminiVision(imageUrl) {
    // Diese Funktion ben√∂tigt ein Modell wie 'gemini-pro-vision'.
    // Da die API-Struktur f√ºr Vision-Modelle (inline_data) komplexer ist,
    // ist dies eine *vereinfachte Simulation*.
    // Ein echter Aufruf w√ºrde das Bild als base64 oder GCS-URI senden.
    
    // Wir simulieren die Analyse mit einer Text-API.
    try {
        const systemPrompt = "Analysiere die BILD-URL. Ist das Bild unpassend (NSFW, Gewalt, irrelevant) oder von schlechter Qualit√§t (unscharf, dunkel)? Antworte mit EINEM Wort: 'OK' oder 'Unpassend' oder 'Schlecht'.";
        const userQuery = `BILD-URL: ${imageUrl}`;
        
        // HINWEIS: callGeminiAPI ist f√ºr Text. Ein Vision-Modell
        // (wie gemini-2.5-flash-preview-09-2025) kann Text UND Bild-URLs verarbeiten.
        // Wir nehmen an, die existierende `callGeminiAPI` kann dies.
        // const result = await callGeminiAPI(systemPrompt, userQuery, true); // (true = annehmen, dass Vision unterst√ºtzt wird)
        
        // Da die existierende callGeminiAPI keine Vision-Parts unterst√ºtzt, simulieren wir das Ergebnis:
        const mockResults = ['OK', 'OK', 'OK', 'OK', 'Unpassend', 'Schlecht', 'OK'];
        const result = mockResults[Math.floor(Math.random() * mockResults.length)];
        // Ende Simulation

        if (result === 'OK') return null; // Kein Flag
        return result; // 'Unpassend' oder 'Schlecht'
        
    } catch (e) {
        console.error("Gemini Vision Error:", e);
        return 'Fehler'; // Flag f√ºr Admin
    }
}

// B. KI-Duplikat-Erkennung
async function checkForDuplicates(newHutData) {
    try {
        // 1. Grobe Vorauswahl (z.B. gleicher Name oder sehr nah)
        // (Diese Logik kann verfeinert werden, z.B. mit Geo-Queries)
        const nameMatches = await db.collection('eierhuetten')
            .where('name', '==', newHutData.name)
            .limit(1).get();
            
        let potentialDuplicates = [];
        if (!nameMatches.empty) {
            potentialDuplicates = nameMatches.docs.map(d => ({id: d.id, ...d.data()}));
        }
        
        // (Hier k√∂nnte man noch eine Geo-Query f√ºr nahe Standorte hinzuf√ºgen)

        if (potentialDuplicates.length === 0) return null;

        // 2. KI-Feinabgleich
        const hutA = `Name: ${newHutData.name}, Typ: ${newHutData.typ}, Lat: ${newHutData.location.latitude}`;
        const hutB = `Name: ${potentialDuplicates[0].name}, Typ: ${potentialDuplicates[0].typ}, Lat: ${potentialDuplicates[0].location?.latitude}`;

        const systemPrompt = "Sind diese zwei Eintr√§ge Duplikate? Antworte mit 'Ja (ID: [ID])' oder 'Nein'.";
        const userQuery = `Eintrag 1: ${hutA}\nEintrag 2: ${hutB}\n---\nAntwort:`;
        
        const result = await callGeminiAPI(systemPrompt, userQuery);
        
        if (result.toLowerCase().startsWith('ja')) {
            return `M√∂gliches Duplikat von "${potentialDuplicates[0].name}" (ID: ${potentialDuplicates[0].id}).`;
        }
        return null;

    } catch (e) {
        console.error("Duplicate Check Error:", e);
        return null; // Im Fehlerfall nicht blockieren
    }
}

// C. KI-Log-Analyse (Trigger & Anzeige)
// Wir f√ºgen einen Button zur Log-Sektion hinzu
// (HTML wurde bereits in Schritt 4.C angepasst, wir f√ºgen nur den Trigger hinzu)

async function analyzeLogsWithKI() {
    const btn = event.target;
    btn.disabled = true;
    btn.classList.add('button-loading');
    
    const logsText = fullLogDataCache.slice(0, 50).map(l => 
        `${l.timestamp?.toDate().toISOString()}: ${l.adminName} -> ${l.action} (${l.hutName || l.ticketId || ''})`
    ).join('\n');
    
    try {
        const systemPrompt = "Analysiere die Admin-Logs. Fasse die Hauptaktivit√§ten (z.B. 'viele H√ºtten bearbeitet'), die aktivsten Admins und auff√§llige Muster (z.B. 'viele L√∂schungen') in 3-4 Stichpunkten zusammen.";
        const userQuery = `Logs:\n${logsText}\n---\nAnalyse:`;
        const analysis = await callGeminiAPI(systemPrompt, userQuery);
        
        // Anzeige der Analyse (z.B. in einem Modal oder Alert)
        alert(`KI-Log-Analyse:\n\n${analysis}`);
        logAdminAction("KI Log-Analyse durchgef√ºhrt");

    } catch (e) {
        console.error("Log Analysis Error:", e);
        showNotification("‚ùå KI-Analyse-Fehler.");
    } finally {
        btn.disabled = false;
        btn.classList.remove('button-loading');
    }
}

// F√ºge den Button-Handler zur "system-logs" Sektion hinzu:
// Ersetze in `id="system-logs"` im HTML:
// <button onclick="exportLogsToCSV()" ...>Logs CSV</button>
// Mit:
// <button onclick="exportLogsToCSV()" ...>Logs CSV</button>
// <button onclick="analyzeLogsWithKI()" class="bg-purple-600 text-white px-3 py-1 rounded text-sm hover:bg-purple-700">‚ú® KI Analyse</button>

/*
  HINWEIS: Da ich das HTML nicht direkt bearbeiten kann, 
  f√ºgen Sie bitte den KI-Analyse-Button manuell hinzu, wie oben beschrieben:
  
  In <section id="system-logs">, in der <div> mit den Export-Buttons,
  f√ºgen Sie diesen Button hinzu:
  
  <button onclick="analyzeLogsWithKI()" class="bg-purple-600 text-white px-3 py-1 rounded text-sm hover:bg-purple-700">‚ú® KI Analyse</button>
*/
